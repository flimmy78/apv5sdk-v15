/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: apWholeInfo.c
* description:  implementation for the whole statistic information of AP
* 
*
* 
************************************************************************************/
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "apWholeInfo.h"


#define  MAX_LEN  2048
#define  MIN_LEN   128

/* 
 * apWholeInfo_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

//oid apWholeInfo_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,2,1,9 };
oid *apWholeInfo_variables_oid;
/* 
 * variable4 apWholeInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the apWholeInfo mib section 
 */

struct variable4 apWholeInfo_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define AP80211STATSVALUE		1
{AP80211STATSVALUE,  ASN_OCTET_STR,  RONLY ,  var_apWholeInfo, 1,  { 1 }},
#define APATHSTATSVALUE		2
{APATHSTATSVALUE,  ASN_OCTET_STR,  RONLY ,  var_apWholeInfo, 1,  { 2 }},
#define APINTERFACERATE		3
{APINTERFACERATE,  ASN_OCTET_STR,  RONLY ,  var_apWholeInfo, 1,  { 3 }},
#define APUSERRATE		4
{APUSERRATE,  ASN_OCTET_STR,  RONLY ,  var_apWholeInfo, 1,  { 4 }},
#define APNETETH0CONNETSTATES		5
{APNETETH0CONNETSTATES,  ASN_OCTET_STR,  RONLY ,  var_apWholeInfo, 1,  { 5 }},
#define APNETETH1CONNETSTATES		6
{APNETETH1CONNETSTATES,  ASN_OCTET_STR,  RONLY ,  var_apWholeInfo, 1,  { 6 }},
#define APGATEWAY		7
{APGATEWAY,  ASN_OCTET_STR,  RONLY ,  var_apWholeInfo, 1,  { 7}},

};
/*    (L = length of the oidsuffix) */


/** Initializes the apWholeInfo module */
void
init_apWholeInfo(void)
{
  	FILE *fp;
  	char oid_str[64]={0};
  	char oid_tmp[64]={0};
  	int  oid_len=0;
  	int  count = 0;
  	char *p = NULL;
  	char *ptr=NULL;
	
    fp=fopen( "/jffs/.OEM/.vendor_oid","r");
    if(fp)
    {
		memset(oid_str,0,64);
    	fgets(oid_str,sizeof(oid_str),fp);
	    oid_str[strlen(oid_str)-1] = '\0';
		fclose(fp);
    }
    else
     {
		memset(oid_str,0,64);
     	strcpy(oid_str, "1.3.6.1.4.1.31656"); 
	 }
	

	memset(oid_tmp,0,64);
	strcpy(oid_tmp,oid_str);
		 
    ptr = strtok(oid_tmp, "."); 
	while(NULL != ptr)
	{
		oid_len++;
		ptr = strtok(NULL,".");
	 }
	
    oid_len = oid_len + 5;	
	apWholeInfo_variables_oid = (oid *)malloc(sizeof(oid)*(oid_len));

    p = strtok(oid_str, ".");
    while( NULL != p)
    {
         apWholeInfo_variables_oid[count++] = (oid)atoi(p);
         p = strtok(NULL,".");
    }
    apWholeInfo_variables_oid[count ++] = 2;
    apWholeInfo_variables_oid[count ++] = 3;
    apWholeInfo_variables_oid[count ++] = 2;
    apWholeInfo_variables_oid[count ++] = 1;
    apWholeInfo_variables_oid[count ++] = 9;
	
    DEBUGMSGTL(("apWholeInfo", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("apWholeInfo", apWholeInfo_variables, variable4,
               apWholeInfo_variables_oid,count); 

    /* place any other initialization junk you need here */
}

/*
 * var_apWholeInfo():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_apWholeInfo(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[MAX_LEN];
    static unsigned char buffer[MIN_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case AP80211STATSVALUE:
  { 
	  FILE *fp;
	  if(fp=popen( "/usr/sbin/80211stats","r")){
		  memset( string, 0, MAX_LEN );
		  memset(buffer,0,MIN_LEN);
		  while(NULL != fgets(buffer,sizeof(buffer),fp)){
		  	strcat(string, buffer);
		    }
		  pclose(fp);
		  string[strlen(string)-1]='\0';
		  *var_len = strlen (string );
		  return (u_char*)string;
	   }
 }
 
    case APATHSTATSVALUE:
   { 
	  FILE *fp;
	  if(fp=popen( "/usr/sbin/athstats","r")){
		  memset( string, 0,MAX_LEN );
		  memset(buffer,0,MIN_LEN);
		  while(NULL != fgets(buffer,sizeof(buffer),fp)){
		  	strcat(string, buffer);
		   }
		  pclose(fp);
		  string[strlen(string)-1]='\0';
		  *var_len = strlen (string );
		  return (u_char*)string;
	   }
   }     

    case APINTERFACERATE:
   { 
	  FILE *fp;
	  if(fp=popen( "cat   /tmp/interface-rate","r")){
		  memset( string, 0,MAX_LEN );
		  memset(buffer,0,MIN_LEN);
		  while(NULL != fgets(buffer,sizeof(buffer),fp)){
		  	strcat(string, buffer);
		     }
		  pclose(fp);
		  string[strlen(string)-1]='\0';
		  *var_len = strlen (string );
		  return (u_char*)string;
	   }
   }    

	case APUSERRATE:
    { 
		  FILE *fp;
		  if(fp=popen( "cat   /tmp/user-rate","r")){
		  memset( string, 0,MAX_LEN );
		  memset(buffer,0,MIN_LEN);
		  while(NULL != fgets(buffer,sizeof(buffer),fp)){
		  	strcat(string, buffer);
		     }
		  pclose(fp);
		  string[strlen(string)-1]='\0';
		  *var_len = strlen (string );
		  return (u_char*)string;
		  }
	}   

   case APNETETH0CONNETSTATES:
     { 
		  FILE *fp;
		  if(fp=popen( "/usr/sbin/ethtool    eth0","r")){
		  memset( string, 0,MAX_LEN );
		  memset(buffer,0,MIN_LEN);
		  while(NULL != fgets(buffer,sizeof(buffer),fp)){
		  	strcat(string, buffer);
		     }
		  pclose(fp);
		  string[strlen(string)-1]='\0';
		  *var_len = strlen (string );
		  return (u_char*)string;
		  }
	}   
    case APNETETH1CONNETSTATES:
     { 
		  FILE *fp;
		  if(fp=popen( "/usr/sbin/ethtool    eth1","r")){
		  memset( string, 0,MAX_LEN );
		  memset(buffer,0,MIN_LEN);
		  while(NULL != fgets(buffer,sizeof(buffer),fp)){
		  	strcat(string, buffer);
		     }
		  pclose(fp);
		  string[strlen(string)-1]='\0';
		  *var_len = strlen (string );
		  return (u_char*)string;
		  }
	}   

 
    case APGATEWAY:
     { 
		  FILE *fp;
		 if(fp=popen( "/sbin/route","r")){
		  memset( string, 0,MAX_LEN );
		  memset(buffer,0,MIN_LEN);
		  while(NULL != fgets(buffer,sizeof(buffer),fp)){
		  	strcat(string, buffer);
		     }
		  pclose(fp);
		  string[strlen(string)-1]='\0';
		  *var_len = strlen (string );
		  return (u_char*)string;
		  }
	}

  default:
      ERROR_MSG("");
    }
    return NULL;
}

