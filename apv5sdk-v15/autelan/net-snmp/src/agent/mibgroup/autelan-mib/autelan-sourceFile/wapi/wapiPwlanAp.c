/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: wapiPwlanAp.c
* description:  implementation for WAPI information of AP.
* 
*
* 
************************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf,v 1.3.4.2 2007/06/28 18:31:38 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "wireless.h"


#include "wapiPwlanAp.h"

/* 
 * wapiPwlanAp_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */





#include <unistd.h>
#include <dirent.h>
#include <stdio.h>
#include <time.h>

#include <sys/ipc.h>
#include <sys/sem.h>
#include <signal.h>

#include <sys/types.h>

#include <string.h>
#include <dirent.h>
#include <stdlib.h>
#include <malloc.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <errno.h>

#include  <sys/param.h>
#include  <sys/stat.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>


#include "p80211def.h"
#include "wapiiofunc.h"
#include "wapicgifunc.h"
#include "wapiconfig.h"
#include "iwlib.h"


#include  "ieee80211.h"
#include "ieee80211_ioctl.h"
#include  "ieee80211_crypto.h"
#include "../../../mibII/interfaces.h"
#include "wapidebug.h"
#include "wapid.c"


#define MAX_TRAP_LIST_NUM 32
#define IFNAME_LEN  20
#define SIOCG80211STATS (SIOCDEVPRIVATE+2)
#define	SIOCSNMPDAGENT  (SIOCDEVPRIVATE+13)		/*ljy--modified to match driver ioctl num*/

#define IEEE80211_IOCTL_SET_TRAFFIC (SIOCDEVPRIVATE+15)		/*ljy--modified to match driver ioctl num*/

// ioctl command id
#define	SIOCGATHSTATS	(SIOCDEVPRIVATE+0)

//oid    wapiPwlanAp_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,4};

oid    *wapiPwlanAp_variables_oid;


oid    notification_oid[] ={1,3,6,1,4,1,31656,2,3,4,8,3,1,1,1};



// 2008-11-28 
static char    wireless_datarate_str[][8] = {"auto", "1M",  "2M",  "5.5M", "6M",
                             								"9M",   "11M", "12M", "18M",  "24M",
                             								"36M",  "48M", "54M"};
#define WIRELESS_DATARATE_TYPE_FIXED "fixed"

extern unsigned char *
var_wapiAuthenticationAlgorithmTable(struct variable *vp,
    	    				oid     *name,
    	    				size_t  *length,
    	    				int     exact,
    	    				size_t  *var_len,
    	    				WriteMethod **write_method);


struct variable4  wapiPwlanAp_variables[] = {
#define WAPIBASICFLASH		1
{WAPIBASICFLASH,  ASN_OCTET_STR,  RONLY ,  var_wapiPwlanAp, 2,  {5, 3 }},
#define WAPIBASICCPU		2
{WAPIBASICCPU,  ASN_OCTET_STR,  RONLY ,  var_wapiPwlanAp, 2,  {5, 1 }},
#define WAPIBASIC80211G		3
{WAPIBASIC80211G,  ASN_OCTET_STR,  RONLY ,  var_wapiPwlanAp, 2,  {5, 6 }},
#define WAPIBASICMEMORY		4
{WAPIBASICMEMORY,  ASN_OCTET_STR,  RONLY ,  var_wapiPwlanAp, 2,  {5, 2 }},
#define WAPIBASIC80211B		5
{WAPIBASIC80211B,  ASN_OCTET_STR,  RONLY ,  var_wapiPwlanAp, 2,  {5, 5 }},
#define WAPIBASICMAC		6
{WAPIBASICMAC,  ASN_OCTET_STR,  RONLY ,  var_wapiPwlanAp, 2,  {5, 4 }},
#define WAPIHARDWAREVERSION		7
{WAPIHARDWAREVERSION,  ASN_OCTET_STR,  RONLY ,  var_wapiPwlanAp, 2,  {5, 7 }},
#define WAPIAPTYPE		8
{WAPIAPTYPE,  ASN_OCTET_STR,  RONLY ,  var_wapiPwlanAp, 2,  {5, 8 }},

#define WAPIAPSOFTPRIMVERSION		9
{WAPIAPSOFTPRIMVERSION,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {4, 1 }},
#define WAPIAPSOFTSECONDVERSION		10
{WAPIAPSOFTSECONDVERSION,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {4,5 }},

#define WAPIAPSOFTDEBUG               11 
{WAPIAPSOFTDEBUG,  ASN_INTEGER ,  RWRITE,  var_wapiPwlanAp, 2,  {4, 2 }},

#define WAPICONFIGTXPOWER		12
{WAPICONFIGTXPOWER,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 5 }},
#define WAPICONFIGREBOOT		13
{WAPICONFIGREBOOT,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 11 }},
#define WAPICONFIGRTSTHRESHOLD	14
{WAPICONFIGRTSTHRESHOLD,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 8 }},
#define WAPICONFIGDTIMPERIOD		15
{WAPICONFIGDTIMPERIOD,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 9 }},
#define WAPICONFIGLANIP		16
{WAPICONFIGLANIP,  ASN_IPADDRESS,  RWRITE,  var_wapiPwlanAp, 2,  { 2,1 }},
#define WAPICONFIGLANGATEWAY		17
{WAPICONFIGLANGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_wapiPwlanAp, 2,  {2, 3 }},
#define WAPICONFIGLANMASK		18
{WAPICONFIGLANMASK,  ASN_IPADDRESS,  RWRITE,  var_wapiPwlanAp, 2,  {2, 2 }},
#define WAPICONFIGWIRELESSMODEBG		19
{WAPICONFIGWIRELESSMODEBG,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 10 }},
#define WAPICONFIGHOSTNAME		20
{WAPICONFIGHOSTNAME,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {2, 4 }},

#define WAPICONFIGBEACONINTERVAL		21
{WAPICONFIGBEACONINTERVAL,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 7 }},
#define WAPICONFIGWIRELESSMODEA  	22
{WAPICONFIGWIRELESSMODEA,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  {2, 6 }},
#define WAPICONFIGFACTORYDEFAULT		23
{WAPICONFIGFACTORYDEFAULT,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 12 }},

#define WAPISERVERURL		24
{WAPISERVERURL,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {6, 1 }},
#define WAPISTARTUPGRADE		25
{WAPISTARTUPGRADE,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {6, 2}},


#define WAPINTPSERVERIP             26
{WAPINTPSERVERIP,  ASN_IPADDRESS,  RWRITE,  var_wapiPwlanAp, 2,  {9, 1 }},
#define WAPINTPNETTIMES             27
{WAPINTPNETTIMES,  ASN_UNSIGNED,  RWRITE,  var_wapiPwlanAp, 2,  {9, 2 }},

#define WAPIASTYPE              28
{WAPIASTYPE,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  {11, 1 }},
#define WAPIASIP              29
{WAPIASIP,  ASN_IPADDRESS,  RWRITE,  var_wapiPwlanAp, 2,  {11, 2 }},
#define WAPIASPORT              30
{WAPIASPORT,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  {11, 3 }},
#define WAPICERTTYPE             31
{WAPICERTTYPE,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  {11, 4 }},
#define WAPICERTSTATE              32
{WAPICERTSTATE,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  {11, 5 }},
#define WAPIASCERT              33
{WAPIASCERT,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {11, 6 }},
#define WAPIUSERCERT            34
{WAPIUSERCERT,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {11, 7}},
#define WAPIINSTALLCERT              35
{WAPIINSTALLCERT,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  {11, 8}},




//WAPI   security    config  Information     MOBILE  test            modify   by  sys0418    start

//gb15629dot11wapiConfigVersion   实体支持的WAPI 最高版本号
#define WAPICONFIGVERSION              36
{WAPICONFIGVERSION,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 1 }},


//gb15629dot11wapiControlledAuthControl	实体是否启用鉴别
#define WAPICONTROLLEDAUTHCONTROL              37
{WAPICONTROLLEDAUTHCONTROL,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 2 }},


//gb15629dot11wapiControlledPortControl   实体端口的控制类型 
#define WAPICONTROLLEDPORTCONTROL              38
{WAPICONTROLLEDPORTCONTROL,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 3 }},


//实体是否支持WAPI预鉴别 gb15629dot11wapiPreauthenticationImplemented
#define WAPIOPTIONIMPLEMENTED              39
{WAPIOPTIONIMPLEMENTED,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 4 }},


//实体上的WAPI预鉴别是否已激活 gb15629dot11wapiPreauthenticationEnabled
#define WAPIPREAUTHENTICATIONIMPLEMENTED              40
{WAPIPREAUTHENTICATIONIMPLEMENTED,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 5 }},


#define WAPIENABLED              41
{WAPIENABLED,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 6 }},


//重新建立WAPI密钥USK的机制 gb15629dot11wapiConfigUnicastRekeyMethod
#define WAPIPREAUTHENTICATIONENABLED              42
{WAPIPREAUTHENTICATIONENABLED,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 7 }},


//WAPI实体支持的单播密钥个数 gb15629dot11wapiConfigUnicastKeysSupported
#define WAPICONFIGUNICASTKEYSSUPPORTED              43
{WAPICONFIGUNICASTKEYSSUPPORTED,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 8 }},



//重新建立WAPI密钥USK的机制 gb15629dot11wapiConfigUnicastRekeyMethod
#define WAPICONFIGUNICASTREKEYMETHOD             44
{WAPICONFIGUNICASTREKEYMETHOD ,  ASN_INTEGER,  RWRITE,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 9 }},



//WAPI USK需要更新的秒级定时gb15629dot11wapiConfigUnicastRekeyTime
#define WAPICONFIGUNICASTREKEYTIME              45
{WAPICONFIGUNICASTREKEYTIME,  ASN_INTEGER,  RWRITE,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 10 }},



//WAPI USK需要更新的分组计数 gb15629dot11wapiConfigUnicastRekeyPackets
#define WAPICONFIGUNICASTREKEYPACKETS             46
{WAPICONFIGUNICASTREKEYPACKETS,  ASN_INTEGER,  RWRITE,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 11 }},



//实体必须采用的组播密码套件gb15629dot11wapiConfigMulticastCipher
#define WAPICONFIGMULTICASTCIPHER              47
{WAPICONFIGMULTICASTCIPHER,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 12 }},



//重新建立WAPI密钥MSK的机制 gb15629dot11wapiConfigMulticastRekeyMethod
#define WAPICONFIGMULTICASTREKEYMETHOD               48
{WAPICONFIGMULTICASTREKEYMETHOD ,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 13 }},


//WAPI MSK需要更新的秒级定时 gb15629dot11wapiConfigMulticastRekeyTime
#define WAPICONFIGMULTICASTREKEYTIME              49
{WAPICONFIGMULTICASTREKEYTIME,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 14 }},


//WAPI MSK需要更新的分组计数 gb15629dot11wapiConfigMulticastRekeyPackets
#define WAPICONFIGMULTICASTREKEYPACKETS               50
{WAPICONFIGMULTICASTREKEYPACKETS ,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 15 }},

//STA离开BSS是否发信号通知密钥MSK进行更新 gb15629dot11wapiConfigMulticastRekeyStrict
#define WAPICONFIGMULTICASTREKEYSTRICT               51
{WAPICONFIGMULTICASTREKEYSTRICT ,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 16 }},


//将PSK模式选为WAPI的AKM套件时的PSK值 gb15629dot11wapiConfigPSKValue
#define WAPICONFIGPSKVALUE               52
{WAPICONFIGPSKVALUE ,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 17 }},



//将PSK模式选为WAPI的AKM套件时的PSK口令字 gb15629dot11wapiConfigPSKPassPhrase
#define WAPICONFIGPSKPASSPHRASE              53
{WAPICONFIGPSKPASSPHRASE,  ASN_UNSIGNED,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 18 }},


//WAPI证书鉴别握手协议的消息重传次数 gb15629dot11wapiConfigCertificateUpdateCount
#define WAPICONFIGCERTIFICATEUPDATECOUNT              54
{WAPICONFIGCERTIFICATEUPDATECOUNT,  ASN_UNSIGNED,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 19 }},


//WAPI组播密钥握手协议的消息重传的次数 gb15629dot11wapiConfigMulticastUpdateCount
#define WAPICONFIGMULTICASTUPDATECOUNT               55
{WAPICONFIGMULTICASTUPDATECOUNT ,  ASN_UNSIGNED,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 20 }},


//WAPI单播密钥握手协议的消息重传的次数 gb15629dot11wapiConfigUnicastUpdateCount
#define WAPICONFIGUNICASTUPDATECOUNT               56
{WAPICONFIGUNICASTUPDATECOUNT ,  ASN_UNSIGNED,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 21 }},


//组播密钥长度的位数 gb15629dot11wapiConfigMulticastCipherSize
#define WAPICONFIGMULTICASTCIPHERSIZE               57
{WAPICONFIGMULTICASTCIPHERSIZE ,  ASN_UNSIGNED,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 22 }},


//BK的最大生存期 gb15629dot11wapiConfigBKLifetime
#define WAPICONFIGBKLIFETIME               58
{WAPICONFIGBKLIFETIME ,  ASN_UNSIGNED,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 23 }},


//渡过BK生存期的百分比 gb15629dot11wapiConfigBKReauthThreshold
#define WAPICONFIGBKREAUTHTHRESHOLD              59
{WAPICONFIGBKREAUTHTHRESHOLD,  ASN_UNSIGNED,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 24 }},


//安全关联建立需要的最长时间 gb15629dot11wapiConfigSATimeout
#define WAPICONFIGSATIMEOUT              60
{WAPICONFIGSATIMEOUT,  ASN_UNSIGNED,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 25 }},


//最后一次协商的AKM套件 gb15629dot11wapiAuthenticationSuiteSelected
#define WAPIAUTHENTICATIONSUITESELECTED              61
{WAPIAUTHENTICATIONSUITESELECTED,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 26 }},

//最后一次协商的单播密码套件 gb15629dot11wapiUnicastCipherSelected
#define WAPIUNICASTCIPHERSELECTED               62
{WAPIUNICASTCIPHERSELECTED ,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 27 }},


//最后一次协商的组播密码套件gb15629dot11wapiMulticastCipherSelected
#define WAPIMULTICASTCIPHERSELECTED               63
{WAPIMULTICASTCIPHERSELECTED ,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 28 }},


//最后一次单播密钥握手过程中所使用的BKID   gb15629dot11wapiBKIDUsed
#define WAPIBKIDUSED              64
{WAPIBKIDUSED,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 29 }},


//最后一次请求的AKM套件 gb15629dot11wapiAuthenticationSuiteRequested
#define WAPIAUTHENTICATIONSUITEREQUESTED               65
{WAPIAUTHENTICATIONSUITEREQUESTED ,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 30 }},


//最后一次请求的单播密码套件gb15629dot11wapiUnicastCipherRequested
#define WAPIUNICASTCIPHERREQUESTED              66
{WAPIUNICASTCIPHERREQUESTED,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 31 }},


//最后一次请求的组播密码套件 gb15629dot11wapiGroupCipherRequested
#define WAPIGROUPCIPHERREQUESTED              67
{WAPIGROUPCIPHERREQUESTED,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1,32 }}, 


//所支持的单播密码套件 gb15629dot11wapiConfigUnicastCipher
#define WAPIMULTICASTCIPHERREQUESTED              68
{WAPIMULTICASTCIPHERREQUESTED,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 32 }},

//WAPI   security    config  Information     MOBILE  test            modify   by  sys0418    end




#define WAPIRWCOMMUNITY            69
{WAPIRWCOMMUNITY,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {1, 3 }},
#define WAPIROCOMMUNITY              70
{WAPIROCOMMUNITY,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {1, 2 }},
#define WAPITRAPIP              71
{WAPITRAPIP,  ASN_IPADDRESS,  RWRITE,  var_wapiPwlanAp, 2,  {1, 1 }},

#define WAPIAPSOFTWAREVENDOR              72
{WAPIAPSOFTWAREVENDOR,  ASN_OCTET_STR,  RONLY,  var_wapiPwlanAp, 2,  {4, 3 }},
#define WAPIAPSOFTWARENAME              73
{WAPIAPSOFTWARENAME,  ASN_OCTET_STR,  RONLY,  var_wapiPwlanAp, 2,  {4, 4 }},

//modify by piyp 2008-11-21
#if 1
#define RFPOWERMANAGER              74
{RFPOWERMANAGER,  ASN_INTEGER,  RWRITE,  var_wapiPowerMgmtTable, 4,  {2, 13,1,1}},
#endif

#if 1
#define WAPICONFIGLOADBALANCEPOLICY              75
{WAPICONFIGLOADBALANCEPOLICY,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 3,  {2, 14 ,1}},
#endif

#define WAPIAPMULTIMODEACCESSCONTROL              76
{WAPIAPMULTIMODEACCESSCONTROL,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  {2, 18 }},
#define WAPIDOT11QOSENABLED              77
{WAPIDOT11QOSENABLED,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 19 }},
#define WAPIAPSYSNEID              78
{WAPIAPSYSNEID,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {2, 20 }},
#define WAPIAPSYSHOSTNAME              79
{WAPIAPSYSHOSTNAME,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {2, 21 }},
#define WAPIAPSYSLOCATION              80
{WAPIAPSYSLOCATION,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {2, 22 }},
#define WAPIBASICMANUFACTURER              81
{WAPIBASICMANUFACTURER,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {2, 23 }},
#define WAPICONFIGUSERSEPARATE              82
{WAPICONFIGUSERSEPARATE,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 15 }},
#if 0
#define WAPICONFIGUSERSQOS              95
{WAPICONFIGUSERSQOS,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 30 }},
#endif

#define WAPICONFIGWIRELESSDATARATEBG              83
{WAPICONFIGWIRELESSDATARATEBG,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 27 }},

#define WAPICONFIGWIRELESSDATARATEA              84
{WAPICONFIGWIRELESSDATARATEA,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 28 }},

#define WAPICONFIGWAPISTATE              85
{WAPICONFIGWAPISTATE,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 26 }},

#define WAPIAPCONFIGBSSID              86
{WAPIAPCONFIGBSSID,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {2, 34 }},
#define WAPIBSSIDNUMINESSID              87
{WAPIBSSIDNUMINESSID,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 36 }},
#define WAPIAPCONFIGBSSIDNUM             88
{WAPIAPCONFIGBSSIDNUM,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 37 }},
#define WAPIEAPAUTHENSUPPORT              89
{WAPIEAPAUTHENSUPPORT,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 39 }},
#define WAPIAPWORKMODE              90
{WAPIAPWORKMODE,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  {2, 40 }},
//#define IWNAPTXRATES              91
//{IWNAPTXRATES,  ASN_INTEGER,  RWRITE,  var_iwncommPwlanAp, 2,  {2, 41 }},
#define WAPIAPDOT11AANTENNAGAIN              92
{WAPIAPDOT11AANTENNAGAIN,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 43 }},
#define WAPIAPDOT11GANTENNAGAIN              93
{WAPIAPDOT11GANTENNAGAIN,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 44 }},
#define WAPICONDNSSERVER              94
{WAPICONDNSSERVER,  ASN_IPADDRESS,  RWRITE,  var_wapiPwlanAp, 2,  {2, 48 }},
#define WAPIDOT11QOSTRAFFICCLASS              95
{WAPIDOT11QOSTRAFFICCLASS,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 49 }},

//WAPI   security    config  Information     MOBILE  test            modify   by  sys0418    start

//所支持的单播密码套件 gb15629dot11wapiConfigUnicastCipher
#define WAPICONFIGUNICASTCIPHER              96
{WAPICONFIGUNICASTCIPHER,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 33 }},


//对象激活或禁止单播密码 gb15629dot11wapiConfigUnicastCipherEnabled
#define WAPICONFIGUNICASTCIPHERENABLED              97
{WAPICONFIGUNICASTCIPHERENABLED,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 34 }},


//单播密钥长度的位数 gb15629dot11wapiConfigUnicastCipherSize
#define WAPICONFIGUNICASTCIPHERSIZE              98
{WAPICONFIGUNICASTCIPHERSIZE,  ASN_INTEGER, RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 35 }},


//AKM套件 gb15629dot11wapiConfigAuthenticationSuite
#define WAPICONFIGAUTHENTICATIONSUITE              99
{WAPICONFIGAUTHENTICATIONSUITE,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 36 }},


//AKM套件是处于激活还是禁止状态 gb15629dot11wapiConfigAuthenticationSuiteEnabled
#define WAPICONFIGAUTHENTICATIONSUITEENABLED              100
{WAPICONFIGAUTHENTICATIONSUITEENABLED,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 37 }},


#define WAPIIFINDEX              101
{WAPIIFINDEX,  ASN_INTEGER, RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 38}},
#define WAPIIFNMAE             102
{WAPIIFNMAE,  ASN_OCTET_STR,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 39 }},
//WAPI   security    config  Information     MOBILE  test            modify   by  sys0418    end





#define CHSTATSCHANNEL		103
{CHSTATSCHANNEL,  ASN_INTEGER,  RWRITE,  var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 1 }},
#define CHSTATSNUMSTATIONS		104
{CHSTATSNUMSTATIONS,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 2 }},
#define CHSTATSTOTPKTS		105
{CHSTATSTOTPKTS,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 3 }},
#define CHSTATSTOTBYTES		106
{CHSTATSTOTBYTES,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 4 }},
#define CHSTATSTOTRETRYPKTS		107
{CHSTATSTOTRETRYPKTS,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 5 }},
#define CHSTATSTOTFRAGMENTEDPKTS		108
{CHSTATSTOTFRAGMENTEDPKTS,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 6 }},
#define CHSTATSTOTPHYERRPKTS		109
{CHSTATSTOTPHYERRPKTS,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 7 }},
#define CHSTATSTOTMACERRPKTS		110
{CHSTATSTOTMACERRPKTS,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 8 }},
#define CHSTATSFRAMEERRORRATE		111
{CHSTATSFRAMEERRORRATE,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 9 }},
#define CHSTATSFRAMERETRYRATE		112
{CHSTATSFRAMERETRYRATE,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 10 }},
#define CHSTATSFRAMENONUNICASTRATE		113
{CHSTATSFRAMENONUNICASTRATE,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 11 }},
#define CHSTATSFRAMEBANDWIDTHRATE		114
{CHSTATSFRAMEBANDWIDTHRATE,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 12 }},
#define CHSTATSFRAMEFRAGMENTATIONRATE		115
{CHSTATSFRAMEFRAGMENTATIONRATE,  ASN_INTEGER,  RONLY,   var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 13 }},
#define CHSTATSMONITOREDTIME		116
{CHSTATSMONITOREDTIME,  ASN_INTEGER,  RWRITE,  var_wapiApWifiInterfaceStatisticsTable, 4,  { 17, 1, 1, 14 }},



//================================================================
//查询AP的WAPI安全相关的性能统计参数          modify   by  sys0418    start

#define WAPISTATSINDEX		117
{WAPISTATSINDEX,  ASN_UNSIGNED,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 1 }},


//	被统计AP的MAC地址 gb15629dot11wapiStatsSTAAddress
#define WAPISTAADDRESS		118  
{WAPISTAADDRESS,  ASN_OCTET_STR,  RWRITE,  var_wapiSTAPortStatusTable, 4,  { 18, 2, 1, 1 }},

//#define WAPISTAADDRESS		118
//{WAPISTAADDRESS,  ASN_OCTET_STR,  RWRITE,  var_wapiStatsTable, 4,  { 18, 1, 1, 2 }},



//被统计AP所关联的WAPI版本  gb15629dot11wapiStatsVersion
#define WAPISTATSVERSION		119    
{WAPISTATSVERSION,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 3 }},
														


//鉴别子系统实体的受控端口的状态 gb15629dot11wapiStatsControlledPortStatus
#define CONTROLLEDPORTSTATUS		120
{CONTROLLEDPORTSTATUS,  ASN_INTEGER,  RONLY,   var_wapiSTAPortStatusTable, 4,  { 18, 2, 1, 2 }},
//#define CONTROLLEDPORTSTATUS		120
//{CONTROLLEDPORTSTATUS,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 4 }},



//关联过程中所使用的单播密码套件gb15629dot11wapiStatsSelectedUnicastCipher
#define SELECTEDUNICASTCIPHER		121
{SELECTEDUNICASTCIPHER,  ASN_OCTET_STR,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 5 }},



//根据重放机制丢弃的WPI MPDU的数目 gb15629dot11wapiStatsWPIReplayCounter
#define WPIREPLAYCOUNTER		122
{WPIREPLAYCOUNTER,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 6 }},


//WPI-SMS4解密时没有有效的密钥而丢弃的MPDU数目 gb15629dot11wapiStatsWPIDecryptableErrors
#define WPIDECRYPTABLEERRORS		123
{WPIDECRYPTABLEERRORS,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 7 }},


//WPI-SMS4解密时MIC校验出错而丢弃的MPDU数目 gb15629dot11wapiStatsWPIMICErrors
#define WPIMICERRORS		124
{WPIMICERRORS,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 8 }},


//接收到的WAI分组验证签名错数gb15629dot11wapiStatsWAISignatureErrors
#define WAISIGNATUREERRORS		125
{WAISIGNATUREERRORS,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 9 }},


//接收到的WAI分组消息鉴别码校验出错数gb15629dot11wapiStatsWAIHMACErrors
#define WAIHMACERRORS		126
{WAIHMACERRORS,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 10 }},


//WAI鉴别结果不成功数gb15629dot11wapiStatsWAIAuthenticationResultFailures
#define WAIAUTHENTICATIONRESULTFAILURES		127
{WAIAUTHENTICATIONRESULTFAILURES,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 11 }},


//接收到的WAI分组被丢弃数 gb15629dot11wapiStatsWAIDiscardCounters
#define WAIDISCARDCOUNTERS		128
{WAIDISCARDCOUNTERS,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 12 }},


//检测到WAI分组超时次数 gb15629dot11wapiStatsWAITimeoutCounters
#define WAITIMEOUTCOUNTERS		129
{WAITIMEOUTCOUNTERS,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 13 }},


//检测到WAI分组格式出错数 gb15629dot11wapiStatsWAIFormatErrors
#define WAIFORMATERRORS		130
{WAIFORMATERRORS,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 14 }},


//WAI证书鉴别过程失败次数 gb15629dot11wapiStatsWAICertificateHandshakeFailures
#define WAICERTIFICATEHANDSHAKEFAILURES		131
{WAICERTIFICATEHANDSHAKEFAILURES,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 15 }},


//WAI单播密钥协商过程失败次数 gb15629dot11wapiStatsWAIUnicastHandshakeFailures
#define WAIUNICASTHANDSHAKEFAILURES		132
{WAIUNICASTHANDSHAKEFAILURES,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 16 }},


//WAI组播密钥通告过程失败次数 gb15629dot11wapiStatsWAIMulticastHandshakeFailures
#define WAIMULTICASTHANDSHAKEFAILURES		133
{WAIMULTICASTHANDSHAKEFAILURES,  ASN_INTEGER,  RONLY,   var_wapiStatsTable, 4,  { 18, 1, 1, 17 }},


//WAPI安全相关的性能统计参数 end  

//========================================================================



#define STAADDRESS		134
{STAADDRESS,  ASN_OCTET_STR,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 1 }},
#define STATXPKTS		135
{STATXPKTS,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 2 }},
#define STATXBYTES		136
{STATXBYTES,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 3 }},
#define STARXPKTS		137
{STARXPKTS,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 4 }},
#define STARXBYTES		138
{STARXBYTES,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 5 }},

#define STATXRETRYPKTS		139    
{STATXRETRYPKTS,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 6 }}, 
#define STARXRETRYPKTS		140   
{STARXRETRYPKTS,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 7 }},

#define STATXFRAGMENTEDPKTS		141
{STATXFRAGMENTEDPKTS,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 8 }},
#define STARXFRAGMENTEDPKTS		142
{STARXFRAGMENTEDPKTS,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 9 }},


#define STARECEIVEERRPKTS		143
{STARECEIVEERRPKTS,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 10 }},
#define STATXTOTSIGNAL		144
{STATXTOTSIGNAL,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 11 }},
#define STATXSIGNALPKTS		145
{STATXSIGNALPKTS,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 12 }},

#define STAFRAMENONUNICASTRATE		146
{STAFRAMENONUNICASTRATE,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 13 }},
#define STAFRAMEBANDWIDTHRATE		147
{STAFRAMEBANDWIDTHRATE,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 14 }},


#define BGUSERASSOCOUNT		148
{BGUSERASSOCOUNT,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 15 }},
#define AUSERASSOCOUNT		149
{AUSERASSOCOUNT,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 16 }},
#define BGUSERASSOFAILCOUNT		150
{BGUSERASSOFAILCOUNT,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 17 }},
#define AUSERASSOFAILCOUNT		151
{AUSERASSOFAILCOUNT,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 18 }},
#define BGUSERASSOREASSOCOUNT		152
{BGUSERASSOREASSOCOUNT,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 19 }},
#define AUSERASSOREASSOCOUNT		153
{AUSERASSOREASSOCOUNT,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 20 }},
#define SMENFAINSUFFICIENTRESOURCE		154
{SMENFAINSUFFICIENTRESOURCE,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 21 }},


#define INACROAMINGSUCCRATE		155
{INACROAMINGSUCCRATE,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 22 }},
#define OUTACROAMINGSUCCRATE		156
{OUTACROAMINGSUCCRATE,  ASN_INTEGER,  RONLY,   var_wapiWlanUserTable, 4,  { 15, 1, 1, 23 }},

#define APSNRBSSIDAVERAGESIGNALSTRENGTH		157
{APSNRBSSIDAVERAGESIGNALSTRENGTH,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 1 }},
#define APSNRBSSIDSIGNALPKTS		158
{APSNRBSSIDSIGNALPKTS,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 2 }},
#define APSNRBSSIDHIGHESTRXSIGNALSTRENGTH		159
{APSNRBSSIDHIGHESTRXSIGNALSTRENGTH,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 3 }},
#define APSNRBSSIDLOWESTRXSIGNALSTRENGTH		160
{APSNRBSSIDLOWESTRXSIGNALSTRENGTH,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 4 }},
#define APSNRBSSIDSAMPLETIME		161
{APSNRBSSIDSAMPLETIME,  ASN_INTEGER,  RWRITE,  var_wapiApWirelessTable, 4,  { 16, 1, 1, 5 }},
#define WAPIAPUPLINKDATETHROUGHPUT		162
{WAPIAPUPLINKDATETHROUGHPUT,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 6 }},
#define WAPIAPDOWNLINKDATETHROUGHPUT		163
{WAPIAPDOWNLINKDATETHROUGHPUT,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 7 }},
#define WAPIAPUPLINKUPDOWNTIMES		164
{WAPIAPUPLINKUPDOWNTIMES,  ASN_UNSIGNED,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 8 }},
#define WAPIAPDOWNLINKUPDOWNTIMES		165
{WAPIAPDOWNLINKUPDOWNTIMES,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 9 }},
#define WARPTLOCTETSINQUEUE		166
{WARPTLOCTETSINQUEUE,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 10 }},
#define WARPTLPACKETSINQUEUE		167
{WARPTLPACKETSINQUEUE,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 11 }},
#define WARPTLAVGDATARATE		168
{WARPTLAVGDATARATE,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 12 }},
#define WARPTLOUTPACKETS		169
{WARPTLOUTPACKETS,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 13 }},
#define WARPTLINPACKETS		170
{WARPTLINPACKETS,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 14 }},
#define UPLINKSLOTTIMEEFFAVG		171
{UPLINKSLOTTIMEEFFAVG,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 15 }},
#define WARPTLPHYDATARATE		172
{WARPTLPHYDATARATE,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 16 }},
#define WARPTLPHYTXDISTRIBUTION		173
{WARPTLPHYTXDISTRIBUTION,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 17 }},
#define WARPTLPHYRXDISTRIBUTION		174
{WARPTLPHYRXDISTRIBUTION,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 18 }},
#define WARPTLPHYFAILEDTRANSMISSION		175
{WARPTLPHYFAILEDTRANSMISSION,  ASN_INTEGER,  RONLY,   var_wapiApWirelessTable, 4,  { 16, 1, 1, 19 }},
#define WAPIESSIDIFINDEX		176
{WAPIESSIDIFINDEX,  ASN_INTEGER,  RONLY,   var_wapiAPESSIDTable, 4,  {2, 35, 1, 1 }},
//midify piyp 2008-12-25
#define WAPIDEVNAMEBG		177
{WAPIDEVNAMEBG,  ASN_OCTET_STR,  RONLY,   var_wapiAPESSIDTable, 4,  {2, 35, 1, 2 }},
#define APCONFIGBSSIDBG		178
{APCONFIGBSSIDBG,  ASN_OCTET_STR,  RONLY,   var_wapiAPESSIDTable, 4,  {2, 35, 1, 3 }},
//midify piyp 2008-12-25
#define WAPIDEVNAMEA		179
{WAPIDEVNAMEA,  ASN_OCTET_STR,  RONLY,   var_wapiAPESSIDTable, 4,  {2, 35, 1, 4 }},
#define APCONFIGBSSIDA		180
{APCONFIGBSSIDA,  ASN_OCTET_STR,  RONLY,   var_wapiAPESSIDTable, 4,  {2, 35, 1, 5 }},
#define APDOT11DESIREDSSID		181
{APDOT11DESIREDSSID,  ASN_OCTET_STR,  RWRITE,   var_wapiAPESSIDTable, 4,  {2, 35, 1,6 }},
#define APMAXSIMULTUSERS		182
{APMAXSIMULTUSERS,  ASN_INTEGER,  RWRITE,   var_wapiAPESSIDTable, 4,  {2, 35, 1,7}},
#define APMAXSIMULTTRAFFIC		183
{APMAXSIMULTTRAFFIC,  ASN_INTEGER,  RWRITE,   var_wapiAPESSIDTable, 4,  {2, 35, 1, 8 }},
#define APBSSIDENCRYPTION		184
{APBSSIDENCRYPTION,  ASN_INTEGER,  RWRITE,   var_wapiAPESSIDTable, 4,  {2, 35, 1, 9}},
#define WAPIMULTIMODEACCESSSTATUS		185
{WAPIMULTIMODEACCESSSTATUS,  ASN_INTEGER,  RWRITE ,  var_wapiPwlanAp, 2,  {2, 50 }},

#define FRAMERETRYRATEEXCEEDED		186
{FRAMERETRYRATEEXCEEDED,  ASN_INTEGER,  RONLY ,  var_wapiPwlanAp, 2,  {2,53 }},
 #define DFSFREECOUNTBELOWTHRESHOLD		187
{DFSFREECOUNTBELOWTHRESHOLD,  ASN_INTEGER,  RONLY ,  var_wapiPwlanAp, 2,  {2, 54 }},
#define BEACONTIMEOUT		188
{BEACONTIMEOUT,  ASN_INTEGER,  RONLY ,  var_wapiPwlanAp, 2,  {2, 55 }},
#define MICHAELERROROVERTHRESHOLD		189
{MICHAELERROROVERTHRESHOLD,  ASN_INTEGER,  RONLY ,  var_wapiPwlanAp, 2,  {2, 56 }},
#define VAPMISSINGBSSIDRANGE		190
{VAPMISSINGBSSIDRANGE,  ASN_INTEGER,  RONLY ,  var_wapiPwlanAp, 2,  {2, 57 }},
#define VAPMISCONFIGURED		191
{VAPMISCONFIGURED,  ASN_INTEGER,  RONLY ,  var_wapiPwlanAp, 2,  {2, 58 }},

#define WAPIMSSIDIFINDEX		192
{WAPIMSSIDIFINDEX,  ASN_INTEGER,  RONLY,   var_wapiMssidTable, 4, { 10, 3, 1, 1 }},
#define WAPIMSSIDDEVNAME		193
{WAPIMSSIDDEVNAME,  ASN_OCTET_STR,  RONLY,   var_wapiMssidTable, 4, { 10, 3, 1, 2 }},
#define WAPIMSSIDWLANSSID		194
{WAPIMSSIDWLANSSID,  ASN_OCTET_STR,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 3 }},
#define WAPIMSSIDHIDESSID		195
{WAPIMSSIDHIDESSID,  ASN_INTEGER,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 4 }},
#define WAPIMSSIDWAPI		196
{WAPIMSSIDWAPI,  ASN_INTEGER,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 5 }},
#define WAPIMSSIDPSKTYPE		197
{WAPIMSSIDPSKTYPE,  ASN_INTEGER,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 6 }},
#define WAPIMSSIDPSK		198
{WAPIMSSIDPSK,  ASN_OCTET_STR,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 7 }},
#define WAPIMSSIDVLANID		199
{WAPIMSSIDVLANID,  ASN_INTEGER,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 8 }},
#define WAPIMSSIDQOS		200
{WAPIMSSIDQOS,  ASN_INTEGER,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 9 }},
#define WAPIMSSIDMACPOLICY		201
{WAPIMSSIDMACPOLICY,  ASN_INTEGER,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 10 }},
#define WAPIMSSIDMAXUSER		202
{WAPIMSSIDMAXUSER,  ASN_INTEGER,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 11 }},
#define WAPIMSSIDMAXTRAFFIC		203
{WAPIMSSIDMAXTRAFFIC,  ASN_INTEGER,  RWRITE,  var_wapiMssidTable, 4, { 10, 3, 1, 12 }},
#define WAPISSIDNUMBER		204
{WAPISSIDNUMBER,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  { 10, 2 }},
#define WAPIVLANONOFF		205
{WAPIVLANONOFF,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 10, 1 }},
#define WAPIMSSIDADD		206
{WAPIMSSIDADD,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 10, 4 }},
#define WAPIMSSIDDEL		207
{WAPIMSSIDDEL,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  { 10, 5 }},
#define WAPIAPARF		208
{WAPIAPARF,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2, 59 }},
#define WAPIAPBRF		209
{WAPIAPBRF,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2, 60 }},
#define WAPIAPWZC		210
{WAPIAPWZC,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2, 61}},
#define WAPIAPFREQUENCYSWITCH		211
{WAPIAPFREQUENCYSWITCH,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2, 62 }},
#define WAPICONFIGAUTOPOWER		212
{WAPICONFIGAUTOPOWER,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2, 63}},
#define WAPICONFIGFILE		214
{WAPICONFIGFILE,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 2,  {13, 1}},
#define WAPISTARTCONFIGAP		215
{WAPISTARTCONFIGAP,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 13, 2 }},
#define WAPIMEMUSAGE               216 
{WAPIMEMUSAGE,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  { 5, 10 }},
#define WAPICPUUSAGE               217 
{WAPICPUUSAGE,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  { 5, 9 }},

#define RUNTIMES        218      
{RUNTIMES,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 4,  { 5, 2, 1, 42 }},
#define WAPICONFIGAUTOADJUSTINTERVAL		219
{WAPICONFIGAUTOADJUSTINTERVAL,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2, { 2, 64 }},
#if 1
#define WAPITRAPSECONDARYIP              221
{WAPITRAPSECONDARYIP,  ASN_IPADDRESS,  RWRITE,  var_wapiPwlanAp, 2,  {1, 4 }},
#endif
#define RFTXPOWER              222
{RFTXPOWER,  ASN_INTEGER,  RONLY,  var_wapiPowerMgmtTable, 4,  {2, 13, 1 ,2 }},
#define RFCURRENTCHANNEL              223
{RFCURRENTCHANNEL,  ASN_INTEGER,  RWRITE,  var_wapiPowerMgmtTable, 4,  {2, 13, 1 ,3 }},
#define WAPIACCESSCONTROLUSERS              224
{WAPIACCESSCONTROLUSERS,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {1, 5 }},
#define ACCESSCONTROLINDEX              225
{ACCESSCONTROLINDEX,  ASN_INTEGER,  RONLY,  var_wapiAccessControlSettingTable, 4,  {1, 6, 1, 1 }},
#define ACCESSCONTROLIPLIST             226
{ACCESSCONTROLIPLIST,  ASN_IPADDRESS,  RWRITE,  var_wapiAccessControlSettingTable, 4,  {1, 6, 1, 2 }},

#define WAPICONFIGLOADBALANCEGROUPNAME             227
{WAPICONFIGLOADBALANCEGROUPNAME,  ASN_OCTET_STR,  RWRITE,  var_wapiPwlanAp, 3,  {2, 14, 2 }},
#define WAPICONFIGUSERSLOADVALUE             228
{WAPICONFIGUSERSLOADVALUE,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 3,  {2, 14, 3 }},
#define WAPICONFIGFLUXLOADVALUE             229
{WAPICONFIGFLUXLOADVALUE,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 3,  {2, 14, 4 }},
#define WAPIPSKTYPE              230
{WAPIPSKTYPE,  ASN_INTEGER,  RONLY,  var_wapiApwapiConfigTable, 4,  { 12, 1, 1, 40 }},
#define WAPIACCESSCONTROLENABLED              231
{WAPIACCESSCONTROLENABLED,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {1, 7 }},

#define WAPIAPMANUFACTURER		232
{WAPIAPMANUFACTURER,  ASN_OCTET_STR,  RONLY,  var_wapiPwlanAp, 2,  {4,6 }},

#define WAPIAPSYSVERSION		233
{WAPIAPSYSVERSION,  ASN_OCTET_STR,  RONLY,  var_wapiPwlanAp, 2,  {4,7 }},
#define WAPIDOT11AUTHENTICATIONALGORITHM    234
{WAPIDOT11AUTHENTICATIONALGORITHM,  ASN_INTEGER,  RWRITE,  var_wapiAuthenticationAlgorithmTable, 4,  {2, 51,1,1 }},

#define WAPICONFIGFILTERPKTS		235
{WAPICONFIGFILTERPKTS,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2,65 }},


#define WAPIAPACCESSMAXUSERS		236
{WAPIAPACCESSMAXUSERS,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2,41 }},

#define WAPICONMULTIMODEACCESSSTATE		237
{WAPICONMULTIMODEACCESSSTATE,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  {2,66 }},

#define SYSCONFIGWAPIACSTATE		238
{SYSCONFIGWAPIACSTATE,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2,67 }},
#define SYSACONLINEUSERMAX		239
{SYSACONLINEUSERMAX,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2,68 }},
#define SYSACONLINEUSERCOUNT		240
{SYSACONLINEUSERCOUNT,  ASN_INTEGER,  RONLY,  var_wapiPwlanAp, 2,  { 2,69 }},
#define SYSACPORTALCERTCONNECTMAX		241
{SYSACPORTALCERTCONNECTMAX,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2,70 }},
#define SYSACPORTALCERTCONNECTCURRENT		242
{SYSACPORTALCERTCONNECTCURRENT,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2,71 }},
#define SYSACPPPOECONNECTMAX		243
{SYSACPPPOECONNECTMAX,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2,72 }},
#define SYSACPPPOECONNECTCURRENT		244
{SYSACPPPOECONNECTCURRENT,  ASN_INTEGER,  RWRITE,  var_wapiPwlanAp, 2,  { 2,73 }},

};

int temp_wapiConfigDownlink=136;
int temp_wapiConfigUsersQos=1;
int temp_wapiConfigUplink=500;
int temp_wapiConfigBandwidthQos=1;
int temp_wapiConfigMultiModeAccessState=1;
int temp_wapiConfigWapiState=1;
int temp_wapiBSSIDMaxUser=13;
int temp_wapiESSIDMaxUser=21;

char  temp_wapiapConfigBSSID[60]="BSSID";
char temp_wapidot11DesiredSSID[60]="CMCC";
int temp_wapiBSSIDNumInESSID=1;
int temp_wapiapConfigBSSIDNum=1;
int temp_wapiEAPAuthenSupport=0;
int temp_wapiApWorkMode=1;
int temp_wapiapTxRates=54;
int temp_wapiapBSSIDEncryption=3;
int temp_wapiapDot11aAntennaGain=5;
int temp_wapiapDot11gAntennaGain=10;
int temp_wapiconRadiusServerPort=308;
char temp_wapiconDNSServer[20]="219.40.19.30";
int temp_wapidot11QosTrafficClass=4;

char temp_wapiConfigUnicastCipher[60]="00147201";
int temp_wapiConfigUnicastCipherEnabled=1;
int temp_wapiConfigUnicastCipherSize=256;
char temp_wapiConfigAuthenticationSuite[60]="00147201";
int temp_wapiConfigAuthenticationSuiteEnabled=1;
int temp_wapidot11AuthenticationAlgorithm=1;

char temp_apMaxSimultTraffic[8] = {23,23,23,23,23,23,23,23};

int temp_wapiUserMaxBandwidth = 20;

static time_t sysAgentTimes;
static int timeCleanFlagbg = 0;
static int timeCleanFlaga = 0;
static time_t  channelMonitoreTimebg;
static time_t  channelMonitoreTimea;
int VAR,VALUE;
int alarmCount;
struct alarmTable  atValue;
static int alarmTimes;
static  unsigned long  alarmId;
static int alarmFlag;
int  pid_flag=0;
int wapiApSoftDebug;
int  wapiApMode;
int WapiInstallCertFlag;
char asCert[1024];
char userCert[1024];
int  upgradSocketFD=-1;
int  userSocketFD_A=-1;
int  userSocketFD_B=-1;
int addDelEdit=0;
unsigned int  switch_rf_A=1;
unsigned int  switch_rf_B=1;

int  cgiSocketFD=-1;
int get_ioctl_parameter( char * ifname ,struct ieee80211_stats *s);



/* record the rekey informations */
static unsigned int rekey_u_policy      = 0;
static unsigned int rekey_u_seconds   = 0;
static unsigned int rekey_u_packets   = 0;
static unsigned int rekey_m_policy      = 0;
static unsigned int rekey_m_seconds   = 0;
static unsigned int rekey_m_packets   = 0;
extern int wapi_send_notify_wapid(struct srv_info *wai_srv, const void *send_buf, int len);
extern int wapi_recv_notify_wapid (struct srv_info *wai_srv, unsigned char *recv_buf, int buf_len);

static int wapi_is_wapi_by_devname(const unsigned char *dev_name);
static int wapi_is_psk_by_devname(const unsigned char *dev_name);
static int wapi_is_cert_by_devname(const unsigned char *dev_name);

static int wapi_get_psktype_by_devname(const unsigned char *dev_name);
static int wapi_read_reusk_info(int index);
static int wapi_read_remsk_info(int index);
static int wapi_read_int_for_key(unsigned char *filename, unsigned char *key);
static int wapi_notify_wapid(unsigned char *buff, int len, int max_len);
static int wapi_is_hex_str(const unsigned char *in, int len);
extern int getOnceMemUsage(float  *memusage);   
extern int ncm_cab_read_cpu(float *cpu_usage);   
static void write_word(void* buffer, unsigned short content, unsigned short site)
{
        content = htons(content);
	 memcpy ((u8*)buffer+site, &content, 2);
}

static void write_dword(void* buffer, unsigned int content, unsigned short site)
{
	content = htonl(content);
	memcpy( (u8*)buffer+site, &content, 4);
}


static unsigned short read_word(const void* buffer, unsigned short site)
{
	unsigned short result;
	
    	memcpy(&result, (u8*)buffer+site, 2);
    	result = ntohs(result);
		
	return result;
}

static unsigned int read_dword(const void* buffer, unsigned short site)
{
	unsigned int result;
	
    	memcpy(&result, (u8*)buffer+site, 4);		
    	result = ntohl(result);
	
	return result;
}


static inline char *
iw_get_ifname(char *	name,	/* Where to store the name */
	      int	nsize,	/* Size of name buffer */
	      char *	buf)	/* Current position in buffer */
{
  char *	end;

  /* Skip leading spaces */
  while(isspace(*buf))
    buf++;

#ifndef IW_RESTRIC_ENUM
  /* Get name up to the last ':'. Aliases may contain ':' in them,
   * but the last one should be the separator */
  end = strrchr(buf, ':');
#else
  /* Get name up to ": "
   * Note : we compare to ": " to make sure to process aliased interfaces
   * properly. Doesn't work on /proc/net/dev, because it doesn't guarantee
   * a ' ' after the ':'*/
  end = strstr(buf, ": ");
#endif

  /* Not found ??? To big ??? */
  if((end == NULL) || (((end - buf) + 1) > nsize))
    return(NULL);

  /* Copy */
  memcpy(name, buf, (end - buf));
  name[end - buf] = '\0';

  return(end + 2);
}



void
init_wapiPwlanAp(void)
{
  //  'cat  /jffs/.OEM/.vendor_oid'
  FILE *fp;
  char oid_str[64]={0};
  char oid_tmp[64]={0};
  int  oid_len=0;
  int  count = 0;
  char *p = NULL;
  char *ptr=NULL;
  
  fp=fopen( "/jffs/.OEM/.vendor_oid","r");
  if(fp)
  {
	  memset(oid_str,0,64);
	  fgets(oid_str,sizeof(oid_str),fp);
	  oid_str[strlen(oid_str)-1] = '\0';
	  fclose(fp);
  }
  else
   {
	  memset(oid_str,0,64);
	  strcpy(oid_str, "1.3.6.1.4.1.31656"); 
   }
  
  
  memset(oid_tmp,0,64);
  strcpy(oid_tmp,oid_str);
	   
  ptr = strtok(oid_tmp, "."); 
  while(NULL != ptr)
  {
	  oid_len++;
	  ptr = strtok(NULL,".");
   }
  
  oid_len = oid_len + 3;  
  wapiPwlanAp_variables_oid = (oid *)malloc(sizeof(oid)*(oid_len));

    p = strtok(oid_str, ".");
    while( NULL != p)
    {
         wapiPwlanAp_variables_oid[count++] = (oid)atoi(p);
         p = strtok(NULL,".");
    }
    wapiPwlanAp_variables_oid[count ++] = 2;
    wapiPwlanAp_variables_oid[count ++] = 3;
    wapiPwlanAp_variables_oid[count ++] = 4;
	
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    char ap_parameter[256];
    int ret ;
    DEBUGMSGTL(("wapiPwlanAp", "Initializing\n"));
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("wapi/wapiPwlanAp", wapiPwlanAp_variables, variable4,
               wapiPwlanAp_variables_oid,count);

    /* place any other initialization junk you need here */
	
#if UPGRADE_SELECT_FLAG
    if(open_socket_upgrade(&upgradSocketFD,(int)SNMPD_UPGRADE_PORT)!=1){	
        printf("exit1\n");
        exit(-1);
    }   
#endif

if(open_socket_upgrade(&cgiSocketFD,(int)SNMPD_CGI_PORT)!=1){	
        printf("exit2\n");
        exit(-1);
}   
  
    /*inspect trap ip */
    bzero(&ap_parameter, 256);
	get_trap_ip("/etc/snmp/snmpd.conf",ap_parameter);
    ret=inet_addr(ap_parameter);
	if((ret&0x000000ff)==255){
        ret=ret&0xffffff00|0x000000fe;
	 	bzero(&ap_parameter, 256);
	 	sprintf(ap_parameter,"%d.%d.%d.%d",(ret>>24&0x000000ff),(ret>>16&0x000000ff),(ret>>8&0x000000ff),(ret&0x000000ff));
	 	set_trap_ip("/etc/snmp/snmpd.conf",ap_parameter,1);
    }
    /*get agent start times .*/    
    time(&sysAgentTimes);  

    /*   init value  */   
	
    bzero(&ap_parameter, 256);
    prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
    get_prop("WLAN0_WMODE",ap_parameter,properties,prop_count);
    ret=atoi(ap_parameter);
     wapiApMode=ret;
    free_prop(properties,prop_count);
    wapiApSoftDebug=0;

    /* get basic info */
    prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
    memset(ap_parameter,0,256);
    get_prop("PRODUCT_ID",ap_parameter,properties,prop_count); 
    pid_flag= atoi(ap_parameter);

    /* whether installed cert  */
    prop_count=load_prop(SEP_EQUAL,WLAN_CONF,properties);
    /* get rekey unicast policy */
    bzero(ap_parameter, 256);
	#if 0
    	get_prop(WAPI_REKEY_U_POLICY_STR, ap_parameter, properties, prop_count);
	#else
	if(get_prop(WAPI_REKEY_U_POLICY_STR, ap_parameter, properties, prop_count)==NULL){
			save_global_conf(SEP_EQUAL,WLAN_CONF,"",WAPI_REKEY_U_POLICY_STR, "2");
	}
	#endif
    rekey_u_policy = atoi(ap_parameter);
    /* get rekey unicast timeout seconds */
    bzero(ap_parameter, 256);
	#if 0
    	get_prop(WAPI_REKEY_U_TIME_STR, ap_parameter, properties, prop_count);
	#else
	if(get_prop(WAPI_REKEY_U_TIME_STR, ap_parameter, properties, prop_count)==NULL){
			save_global_conf(SEP_EQUAL,WLAN_CONF,"",WAPI_REKEY_U_TIME_STR, "86400");
	}
	#endif
    rekey_u_seconds = atoi(ap_parameter);
    /* get rekey unicast data packets */
    bzero(ap_parameter, 256);
	#if 0
    	get_prop(WAPI_REKEY_U_PACKET_STR, ap_parameter, properties, prop_count);
	#else
	if( get_prop(WAPI_REKEY_U_PACKET_STR, ap_parameter, properties, prop_count)==NULL){
			save_global_conf(SEP_EQUAL,WLAN_CONF,"",WAPI_REKEY_U_PACKET_STR, "67108864");
	}
	#endif
    rekey_u_packets= atoi(ap_parameter);
    /* get rekey group policy */
    bzero(ap_parameter, 256);
    if(get_prop(WAPI_REKEY_M_POLICY_STR, ap_parameter, properties, prop_count)==NULL){
			save_global_conf(SEP_EQUAL,WLAN_CONF,"",WAPI_REKEY_M_POLICY_STR, "2");
			rekey_m_policy = 2;
    }
    else
	rekey_m_policy = atoi(ap_parameter);
    /* get rekey group timeout seconds */
    bzero(ap_parameter, 256);
    if(get_prop(WAPI_REKEY_M_TIME_STR, ap_parameter, properties, prop_count)==NULL){
			save_global_conf(SEP_EQUAL,WLAN_CONF,"",WAPI_REKEY_M_TIME_STR, "86400");
			rekey_m_seconds = 86400;
    }
    else
	rekey_m_seconds = atoi(ap_parameter);
    /* get rekey group data packets */
    bzero(ap_parameter, 256);
    if( get_prop(WAPI_REKEY_M_PACKET_STR, ap_parameter, properties, prop_count)==NULL){
			save_global_conf(SEP_EQUAL,WLAN_CONF,"",WAPI_REKEY_M_PACKET_STR, "67108864");
			rekey_m_packets = 67108864;
    }
    else
	rekey_m_packets = atoi(ap_parameter);

    bzero(ap_parameter, 256);
    get_prop("CERT_STATUS",ap_parameter,properties,prop_count);
    free_prop(properties,prop_count);
    WapiInstallCertFlag=atoi(ap_parameter);
    if(WapiInstallCertFlag!=1)
        WapiInstallCertFlag=0;

   bzero(&ap_parameter, 256);
   prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
   get_prop("WLAN0_RF",ap_parameter,properties,prop_count);
   switch_rf_A=atoi(ap_parameter);
   printf("switch_rf_A:%d\n",switch_rf_A);
   bzero(&ap_parameter, 256);
   get_prop("AWLAN0_RF",ap_parameter,properties,prop_count);
   switch_rf_B=atoi(ap_parameter);
   free_prop(properties,prop_count);
}

/*
 * var_wapiPwlanAp():
 */
unsigned char *
var_wapiPwlanAp(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{

#ifdef  DEBUG_PWLAN  
    char buf[200];  
    bzero(buf, 200);
    sprint_mib_oid(buf, name, *length);
    printf("read wapiPwlanAp %s \n",buf);        
#endif
    static u_long   ulret;
    /* variables we may use later */
    static long  long_ret;
    static int    int_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    int ret=0,i=0,open=0;
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    static char ap_parameter[256];
  //  int result;   //modify by heyh  091118
    int result,rf=0;
    char strTemp[256];
    char ifnameList[IFNAME_MAX],*np;
    struct wlan_info_t wlaninfo;   
    int wlanSize=0;
    char *wp;
	float mem_usage=0.001;
	float cpu_usage=0.001;
	long tmp_arr_ind = -1;
	int mode;
	int countUsers = 0;
       time_t now;


       FILE *stream;
	int k;
	char buffer[4][32];
	char *token;

	   
    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;


    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {

	 case RUNTIMES:
     	    ulret = netsnmp_get_agent_uptime();
	    	return ((u_char *) & ulret);
		
       case WAPIMEMUSAGE :
           getOnceMemUsage(&mem_usage);
           ulong_ret=(u_long)(mem_usage);           
           return (u_char*) &ulong_ret;
       case WAPICPUUSAGE :   
           ncm_cab_read_cpu(&cpu_usage);
           //printf("cpuusage=%f\n", cpu_usage);
           ulong_ret=(u_long)(cpu_usage)+1;
           return (u_char*) &ulong_ret;
       case WAPISTARTCONFIGAP:
	    // *write_method = write_wapiStartConfigAP;	
	     ulong_ret =0;
            return (u_char*) &ulong_ret;
       case WAPICONFIGFILE:
	    // *write_method = write_wapiConfigFile;  
		memset(ap_parameter,0,256);
	     *var_len = 0;
            return (u_char*) ap_parameter;
			
	  case WAPICONFIGAUTOPOWER:
	   #if 0
            *write_method = write_wapiConfigAutoPower;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
            get_prop("WLAN0_AUTOGL",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
	     	ulong_ret =atoi(ap_parameter);
	 #endif
	     ulong_ret =0;   // by sunyushuang0320
            return (u_char*) &ulong_ret;
			
	   case WAPICONFIGFILTERPKTS:
	   	#if  0
            *write_method = write_wapiConfigFilterPkts;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            if(get_prop("FILTER",ap_parameter,properties,prop_count)==NULL){
				save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","FILTER", "0");
			}
            free_prop(properties,prop_count);
	     	ulong_ret =atoi(ap_parameter);
	#endif 
	     ulong_ret=0;
            return (u_char*) &ulong_ret;


   case  WAPICONMULTIMODEACCESSSTATE:
   	     *write_method = write_wapiConfigWapiState;;
           memset(ap_parameter, 0, sizeof(ap_parameter));
            prop_count = load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
            get_prop("PRODUCT_SEC",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	     long_ret = atoi(ap_parameter);
	     if (long_ret == 1)
		 	long_ret = 1;
	     else
		 	long_ret = 0;
            return (u_char*) &long_ret ;

					 
case  SYSCONFIGWAPIACSTATE:
        *write_method = write_wapiConfigWapiState;
	     memset(ap_parameter, 0, sizeof(ap_parameter));
            prop_count = load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
            get_prop("PRODUCT_SEC",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	     long_ret = atoi(ap_parameter);
	     if (long_ret == 1)
		 	long_ret = 1;
	     else
		 	long_ret = 0;
            return (u_char*) &long_ret ;


case  SYSACONLINEUSERMAX:
	     memset(ap_parameter,0,256);
	   *write_method = write_sysAcOnlineUserMax;
            prop_count=load_prop(SEP_EQUAL,AC_SNMP_CONF,properties);
	     printf("count:%d\n",prop_count);
            printf("key:%s\n",properties[0].key);
	     printf("value:%s\n",properties[0].value);
            get_prop("ACMAXONLINE",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;	   
	     ulong_ret =atoi(ap_parameter);
            return (unsigned char *)& ulong_ret;
	   

case  SYSACONLINEUSERCOUNT:

{ FILE *fp;
  char cmd[SPRINT_MAX_LEN];
  char bfr[SPRINT_MAX_LEN];
  static u_long num;
  static u_long count;
  memset( cmd, 0, SPRINT_MAX_LEN );
  sprintf(cmd, "%s %s %s %s", "/usr/sbin/wlanconfig","ath0","list","|wc -l");
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset( bfr, 0, SPRINT_MAX_LEN );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 num=atoi(bfr);
	 if(num>1)
	       count=num-1;
	 else
	 	count=num;
	 pclose(fp);
	}
  	  return (unsigned char *) &count;	

}
	  

case  SYSACPORTALCERTCONNECTMAX:
	     memset(ap_parameter,0,256);
           *write_method = write_sysAcPortalCertConnectMax;
	     prop_count=load_prop(SEP_EQUAL,AC_SNMP_CONF,properties);
	     printf("count:%d\n",prop_count);
            printf("key:%s\n",properties[0].key);
	     printf("value:%s\n",properties[0].value);
            get_prop("PORTAL_MAX",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;	   
	     	ulong_ret =atoi(ap_parameter);
            return (unsigned char *)&ulong_ret;
		
case  SYSACPORTALCERTCONNECTCURRENT:
	     memset(ap_parameter,0,256);
            *write_method = write_sysAcPortalCertConnectCurrent;
	     prop_count=load_prop(SEP_EQUAL,AC_SNMP_CONF,properties);
            get_prop("PORTAL_CURRENT",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;	   
	     	ulong_ret =atoi(ap_parameter);
            return (unsigned char *)& ulong_ret;
		
case  SYSACPPPOECONNECTMAX:
	 memset(ap_parameter,0,256);
        *write_method = write_sysAcPPPOEConnectMax;
	prop_count=load_prop(SEP_EQUAL,AC_SNMP_CONF,properties);
       get_prop("PPPOE_MAX",ap_parameter,properties,prop_count);
       free_prop(properties,prop_count) ;	   
	     	ulong_ret =atoi(ap_parameter);
            return (unsigned char *)& ulong_ret;
	
case  SYSACPPPOECONNECTCURRENT:
	memset(ap_parameter,0,256);
      *write_method = write_sysAcPPPOEConnectCurrent;
	prop_count=load_prop(SEP_EQUAL,AC_SNMP_CONF,properties);
      get_prop("PPPOE_CURRENT",ap_parameter,properties,prop_count);
       free_prop(properties,prop_count) ;	   
        ulong_ret =atoi(ap_parameter);
        return (unsigned char *) &ulong_ret;
					

			
case WAPICONFIGAUTOADJUSTINTERVAL:

			#if 0
            *write_method = write_wapiConfigAutoAdjustInterval;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_AUTOGL1",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
	     	ulong_ret =atoi(ap_parameter);
	#endif
	     ulong_ret =0;   // by sunyushuang0320
            return (u_char*) &ulong_ret;
        case WAPIAPARF:	
	#if 0
	     *write_method = write_wapiApARF; // b and g
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_RF",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret =atoi(ap_parameter);
	#endif
	      ulong_ret =0; // by sunyushuang0320
            return (u_char*) &ulong_ret;
        case WAPIAPBRF:	

	     *write_method = write_wapiApBRF; 
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("AWLAN0_RF",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret =atoi(ap_parameter);
            return (u_char*) &ulong_ret;
        case WAPIAPWZC:			
            *write_method = write_wapiApWZC;
	#if 0
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_NOPRIVACY",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret =atoi(ap_parameter);
	#endif
	     ulong_ret =0;   // by sunyushuang0320
            return (u_char*) &ulong_ret;
        case WAPIAPFREQUENCYSWITCH:
	#if 0
            *write_method = write_wapiApFrequencySwitch;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("COUNTRYCODE",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret =atoi(ap_parameter);
	     if(ulong_ret==156)
		 	ulong_ret=0;
	     if(ulong_ret==36)
		 	ulong_ret=1;
		 #endif
	     ulong_ret =0;   // by sunyushuang0320
            return (u_char*) &ulong_ret;
	
        case WAPIVLANONOFF:
       	    *write_method = write_wapiVlanOnOff;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
       	    get_prop("VLAN",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
            ulong_ret =atoi(ap_parameter);
            return (u_char*) &ulong_ret;
        case WAPISSIDNUMBER:
            long_ret =count_mssib(WLAN_CONFIG, WLAN_BEGIN, WLAN_END);
            return (u_char*) &long_ret;
		case WAPIMSSIDADD:
            *write_method = write_wapiMssidAdd;
            long_ret = 0;	/* XXX */
            return (u_char*) &long_ret;
        case WAPIMSSIDDEL:
            *write_method = write_wapiMssidDel;
             *var_len = 0;
            return (u_char*) "";
			
		 case WAPIMULTIMODEACCESSSTATUS:
            *write_method = write_wapiMultiModeAccessStatus;    //heyh add start  ----091118
	        memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
	        get_prop("WLAN_RF_FLAG",ap_parameter,properties,prop_count);
	        rf = atoi(ap_parameter);
			free_prop(properties,prop_count);
			 long_ret = (get_ap_rf_status())&&rf;      //heyh add end  -----091118
			//long_ret =0;                     ---by heyh 091118
             return (u_char*) &long_ret;
		
        case	FRAMERETRYRATEEXCEEDED:
            long_ret=0;
            return (u_char*) &long_ret ;
    	case	DFSFREECOUNTBELOWTHRESHOLD:
    	    long_ret=0;
            return (u_char*) &long_ret ;
    	case	BEACONTIMEOUT:
    	    long_ret=0;
            return (u_char*) &long_ret ;
    	case	MICHAELERROROVERTHRESHOLD:
    	    long_ret=0;
            return (u_char*) &long_ret ;
    	case	VAPMISSINGBSSIDRANGE:
    	    long_ret=0;
            return (u_char*) &long_ret ;    	 
    	case	VAPMISCONFIGURED:
    	    long_ret=0;
            return (u_char*) &long_ret ;
    	case	WAPIAPCONFIGBSSID:
	    memset(ap_parameter,0,256);
            ret=wlan_getioctl_dev_addr(ap_parameter,"default");		/*ljy--modified br0 to default.*/
            if( ret !=1 )
            printf(" get Mac error .");
            *var_len = 6;
            return (u_char*) ap_parameter ;
    	case	WAPIBSSIDNUMINESSID:
    	    //*write_method = write_wapiBSSIDNumInESSID;
    	    bzero(ap_parameter, 256);
    	    long_ret=iw_enum_wlan_interface( ap_parameter);  
            return (u_char*) &long_ret ;
    	case	WAPIAPCONFIGBSSIDNUM:
    	    //*write_method = write_wapiapConfigBSSIDNum;
    	    bzero(ap_parameter, 256);
    	    long_ret=iw_enum_wlan_interface( ap_parameter);
            return (u_char*) &long_ret ;
    	case	WAPIEAPAUTHENSUPPORT:
    	    *write_method = write_wapiEAPAuthenSupport;
	    /* #0045-2 guoxd_002 20081109 modify start */
	     memset(ap_parameter, 0, sizeof(ap_parameter));
            prop_count = load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
            get_prop("PRODUCT_SEC",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	     long_ret = atoi(ap_parameter);			
	     if (long_ret == 2)
		 	long_ret = 1;
	     else
		 	long_ret = 0;
	    /* #0045-2 guoxd_002 20081109 modify end */
            return (u_char*) &long_ret ;
    	case	WAPIAPWORKMODE:
    	    //*write_method = write_wapiApWorkMode;
    	    long_ret=1;
            return (u_char*) &long_ret ;
    	case	WAPIAPDOT11AANTENNAGAIN:
	   *write_method = write_wapiapDot11aAntennaGain;
    	    long_ret=temp_wapiapDot11aAntennaGain;
    	    //long_ret = 20;
            return (u_char*) &long_ret ;
    	case	WAPIAPDOT11GANTENNAGAIN:
     	    *write_method = write_wapiapDot11gAntennaGain;
    	    long_ret=temp_wapiapDot11gAntennaGain;
    	    //long_ret = 23;
            return (u_char*) &long_ret ;
    	case	WAPICONDNSSERVER:
    	    *write_method = write_wapiconDNSServer; 
    	    //long_ret=inet_addr(temp_wapiconDNSServer); 
    	    int_ret=inet_addr(temp_wapiconDNSServer); 
    	    memcpy(string, (char *)&int_ret, 4);
    	    *var_len = 4;
	    return (unsigned char *) string; 	      
    	case	WAPIDOT11QOSTRAFFICCLASS:
    	    //*write_method = write_wapidot11QosTrafficClass;
    	    long_ret=4;
            return (u_char*) &long_ret ;
        case	WAPISERVERURL:
	    *write_method = write_wapiServerURL;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
       	    get_prop("URL",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	    *var_len = strlen(ap_parameter);
	    ap_parameter[*var_len]='\0';        
            return (unsigned char *) ap_parameter;    
        case	WAPISTARTUPGRADE:
	    *write_method = write_wapiStartUpgrade;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
       	    get_prop("START_UPGRADE",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
            ulong_ret =atoi(ap_parameter);
            return (u_char*) &ulong_ret;
        case	WAPICONFIGWIRELESSDATARATEBG:
            *write_method = write_wapiConfigWirelessDataRateBG;
	         memset(ap_parameter,0,265);
	         prop_count=load_prop(SEP_EQUAL, WIRELESS_CONF, properties);
		     get_prop("WLAN0_DATARATE",ap_parameter,properties,prop_count);
		     free_prop(properties, prop_count);
		     ulong_ret = 0;
		     wp = NULL;
		     wp = strstr(ap_parameter, WIRELESS_DATARATE_TYPE_FIXED);
		     if (NULL != wp)
		     {
		         wp--;
		         *wp = '\0';
		         for (tmp_arr_ind=0; i<sizeof(wireless_datarate_str); ++tmp_arr_ind)
		         {
		           if (strcasecmp(ap_parameter, wireless_datarate_str[tmp_arr_ind]) == 0)
		           {
		              ulong_ret = tmp_arr_ind;
		              break;
		           }
		         }
		     }
	         return  (u_char*) &ulong_ret;
        case	WAPICONFIGWIRELESSDATARATEA:
	    	 *write_method = write_wapiConfigWirelessDataRateA;
	         memset(ap_parameter,0,265);
	         prop_count=load_prop(SEP_EQUAL, WIRELESS_CONF, properties);
		     get_prop("AWLAN0_DATARATE",ap_parameter,properties,prop_count);
		     free_prop(properties, prop_count);
		     ulong_ret = 0;
		     wp = NULL;
		     wp = strstr(ap_parameter, WIRELESS_DATARATE_TYPE_FIXED);
		     if (NULL != wp)
		     {
		         wp--;
		         *wp = '\0';
		        for (tmp_arr_ind=0; i<sizeof(wireless_datarate_str); ++tmp_arr_ind)
		        {
		           if (strcasecmp(ap_parameter, wireless_datarate_str[tmp_arr_ind]) == 0)
		           {
		              ulong_ret = tmp_arr_ind;
		              break;
		           }
		        }
		      }
          return  (u_char*) &ulong_ret;
	case	WAPICONFIGWAPISTATE:
	    *write_method = write_wapiConfigWapiState;
	    /* #0045-2 guoxd_002 20081109 modify start */
	     memset(ap_parameter, 0, sizeof(ap_parameter));
            prop_count = load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
            get_prop("PRODUCT_SEC",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	     long_ret = atoi(ap_parameter);
	     if (long_ret == 1)
		 	long_ret = 1;
	     else
		 	long_ret = 0;
	    /* #0045-2 guoxd_002 20081109 modify end */
            return (u_char*) &long_ret ;
        case	WAPIAPSOFTWAREVENDOR:
	 case	WAPIAPMANUFACTURER:
    	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
            get_prop("AP_MANUFACTURER",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	    *var_len = strlen(ap_parameter);
	    ap_parameter[*var_len]='\0';        

	    if (atoi(ap_parameter) == 7)
	    {
	    		memset(ap_parameter, 0, sizeof(ap_parameter));
			strcpy(ap_parameter, "HONGTEC");
			*var_len = strlen(ap_parameter);
	    }		
            return (unsigned char *) ap_parameter;           
        case WAPICONFIGUSERSEPARATE:
            *write_method = write_wapiConfigUserSeparate;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_BRIDGE",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret =atoi(ap_parameter);
            return (u_char*) &ulong_ret;
        case 	WAPIAPSOFTWARENAME: 		

   	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
            get_prop("AP_MANUFACTURER",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	    *var_len = strlen(ap_parameter);
	    ap_parameter[*var_len]='\0';

	    if (atoi(ap_parameter) == 8)   //modify by hyh--091028
	    {
	    		memset(ap_parameter, 0, sizeof(ap_parameter));
			strcpy(ap_parameter, "HM-API01");
			*var_len = strlen(ap_parameter);
	    }
	    else
	    {
    	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
            get_prop("APSOFTWARENAME",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	    	*var_len = strlen(ap_parameter);
	    	ap_parameter[*var_len]='\0';        
	    }  
            return (unsigned char *) ap_parameter;

	case	WAPICONFIGLOADBALANCEPOLICY:
            *write_method = write_wapiConfigLoadBalancePolicy;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
            get_prop("WLAN0_LB",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret =atoi(ap_parameter);
            return (u_char*) &ulong_ret;
	case	WAPICONFIGLOADBALANCEGROUPNAME:
            *write_method = write_wapiConfigLoadBalanceGroupName;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_LBGROUP",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
           	*var_len = strlen(ap_parameter);
	    	ap_parameter[*var_len]='\0';        
            return (unsigned char *) ap_parameter;
	case	WAPICONFIGUSERSLOADVALUE:
            *write_method = write_wapiConfigUsersloadValue;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_LBUSER",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret =atoi(ap_parameter);
            return (u_char*) &ulong_ret;
	case	WAPICONFIGFLUXLOADVALUE:
            *write_method = write_wapiConfigFluxloadValue;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_LBDATA",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret =atoi(ap_parameter);
            return (u_char*) &ulong_ret;
		
	case	WAPIAPMULTIMODEACCESSCONTROL:
	    //long_ret=1;     ---modify by heyh  091118
		long_ret = get_ap_rf_status();
	    return (u_char*) &long_ret ;	
	case	WAPIDOT11QOSENABLED:
            //	*write_method = write_wapidot11QosEnabled;
            long_ret=0;
            if(iw_get_wifis()==0) long_ret=0;
            else {
   	        wlanSize=iw_enum_wlan_interface( ifnameList );		    
			printf("wlansize=%d\n",wlanSize);
    		wp=ifnameList;
    		for(i=0;i<wlanSize;i++,wp=wp+IFNAME_LEN){
		    memset(&wlaninfo,0,sizeof(wlaninfo));
		    ret=0 ;			   
		    if(strstr(wp,"ath")!=NULL)   continue ;
		        serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wp,&wlaninfo); 
        		ret=atoi(wlaninfo.qos); 
			printf("ret=%d  wlaninfo.qos=%s \n",ret,wlaninfo.qos);
			if(ret==1) {
        		    long_ret=1 ;
			    break ; 			
			} 			   
   		    }		    
              }
    	    return (u_char*) &long_ret ;		  
	case	WAPIAPSYSNEID:
	    memset(ap_parameter,0,256);
	    *write_method = write_wapiapSysNEId;
            prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
	     printf("count:%d\n",prop_count);
            printf("key:%s\n",properties[0].key);
	     printf("value:%s\n",properties[0].value);
            get_prop("APSYSNEID",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;	   
            *var_len = strlen(ap_parameter);
	    ap_parameter[*var_len]='\0';
            return (unsigned char *) ap_parameter;
	case	WAPIAPSYSHOSTNAME:
	    memset(ap_parameter,0,256);
	    *write_method = write_wapiapSysHostName;
            prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
            get_prop("APSYSHOSTNAME",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;	   
            *var_len = strlen(ap_parameter);
	    ap_parameter[*var_len]='\0';
            return (unsigned char *) ap_parameter;
        case	WAPIAPSYSLOCATION:
            *write_method = write_wapiapSysLocation;
	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
            get_prop("APSYSLOCATION",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;	       
	    *var_len = strlen(ap_parameter);
	    ap_parameter[*var_len]='\0';
            return (unsigned char *) ap_parameter;
        case	WAPIBASICMANUFACTURER:	
	    //*write_method = write_wapiBasicManufacturer;
	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
            get_prop("AP_MANUFACTURER",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;	      
	    *var_len = strlen(ap_parameter);
	    ap_parameter[*var_len]='\0';
            return (unsigned char *) ap_parameter;
        case WAPIRWCOMMUNITY:    	
	    *write_method = write_wapiRwcommunity;
		memset(string,0,SPRINT_MAX_LEN);
		memset(ap_parameter,0,256);
		stream=fopen(SNMPD_CONF,"r");
		if(stream)
		{
			fgets(string,64,stream);
			fgets(string,64,stream);
			token=strtok(string," ");
			while(NULL!=token)
				{
		                 strcpy(buffer[i],token);
				   token=strtok(NULL," ");
				    i++;
				  }
			 strcpy(ap_parameter,buffer[3]);
			 fclose(stream);
		 }
	    strcpy(ap_parameter,buffer[3]);
	    *var_len = strlen(ap_parameter);
            return (unsigned char *) ap_parameter;

	case WAPIROCOMMUNITY:
	    *write_method = write_wapiRocommunity;
	       memset(ap_parameter,0,256);
		memset(string,0,SPRINT_MAX_LEN);
		stream=fopen(SNMPD_CONF,"r");
		if(stream)
		{
			fgets(string,64,stream);
			token=strtok(string," ");
			while(NULL!=token)
				{
		                 strcpy(buffer[i],token);
				   token=strtok(NULL," ");
				    i++;
				  }
		       strcpy(ap_parameter,buffer[3]);
			fclose(stream);
		 }
             *var_len = strlen(ap_parameter);
            return (unsigned char *) ap_parameter;

	case WAPITRAPIP:
    	    		*write_method = write_wapiTrapIP;	
			 memset(ap_parameter,0,256);
			get_trap_ip("/etc/snmp/snmpd.conf",ap_parameter);
			printf("ap_parameter = %s\n", ap_parameter);
			char ip_addr[20];
			memset(ip_addr,0,20);
			memcpy(&ip_addr,ap_parameter,20);
			printf("ip_addr = %s\n", ip_addr);
	     		int_ret=inet_addr(ip_addr); 	   //long_ret=inet_addr(ip_addr); by sunyushuang0319
    	    		memcpy(string, (char *)&int_ret, 4);
    	    		*var_len = 4;
	    		printf("int_ret=%d\n",(int_ret&0x000000ff));
	   		 return (unsigned char *) string;

	case WAPITRAPSECONDARYIP:
    	   		 *write_method = write_wapiTrapSecondaryIP;	
			 memset(ap_parameter,0,256);
			get_trap_ip("/etc/snmp/snmpd.conf",ap_parameter);
			char ip_addr1[20];
			char *ap_param;
			ap_param = ap_parameter;
			ap_param +=20;	
			memcpy(ip_addr1,ap_param,20);
    	   		 int_ret=inet_addr(ip_addr1);    // long_ret=inet_addr(ip_addr1); by sunyushuang0319  
    	    		memcpy(string, (char *)&int_ret, 4);
    	   		 *var_len = 4;
	    		return (unsigned char *) string;

	case WAPIACCESSCONTROLUSERS:
	    	*write_method = write_wapiAccessControlUsers;
	    	//add by piyp 2008-11-25 init accessControlUsers
			memset(ap_parameter,0,256);
    		prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
    		if(get_prop("ACCESS_CONTROL_USERS", ap_parameter, properties, prop_count)==NULL){	
				save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"","ACCESS_CONTROL_USERS", "10");
			}
    		free_prop(properties,prop_count);
			printf("prop_count = %d, ACCESS_CONTROL_USERS = %s\n", prop_count, ap_parameter);
			*var_len = 4;
			ap_parameter[*var_len]='\0';
			long_ret = atoi(ap_parameter);
			printf("long_ret = %ld\n", long_ret);
            return (unsigned char *) &long_ret;	
			
		case WAPIACCESSCONTROLENABLED:
	    	*write_method = write_wapiAccessControlEnabled;
	    	//add by piyp 2008-12-11 
			memset(ap_parameter,0,256);
    		prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
    		if(get_prop("ACCESS_CONTROL_ENABLED", ap_parameter, properties, prop_count)==NULL){	
				save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"","ACCESS_CONTROL_ENABLED", "0");
			}
    		free_prop(properties,prop_count);
			*var_len = 4;
			ap_parameter[*var_len]='\0';
			long_ret = atoi(ap_parameter);
            return (unsigned char *) &long_ret;	
        case WAPIASTYPE:
			//by piyp midify 2008-11-20
            //long_ret=2;
			memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_CONF,properties);
            get_prop("ASU_IP", ap_parameter, properties, prop_count);
            free_prop(properties,prop_count);
			if(ap_parameter==NULL || strcmp(ap_parameter,"127.0.0.1")!=0)
			{
				long_ret=2;
			}else{
				long_ret=1;
			}
            return (u_char*) &long_ret ;
        case WAPIASIP:
	    *write_method = write_WapiAsIP;
            result = wapiget_ip(WLAN_CONF, SEP_EQUAL, "ASU_IP", string );
            if(result !=0)
                memset(string,0,4);
            *var_len = 4;
            return (u_char*) string;
        case WAPIASPORT:
            prop_count=load_prop(SEP_EQUAL,WLAN_CONF,properties);
            get_prop("ASU_PORT",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
            long_ret=atoi(ap_parameter);
            return (u_char*) &long_ret ;
			//heyanhua modify 2010-5-3
        case WAPICERTTYPE:
			{
				FILE *fp;
				char line[256];
				char *q;
				fp=popen("find /jffs/user.cer","r");
				if(fp){
					memset(line,0,256);
					fgets(line,sizeof(line),fp);
					line[strlen(line)-1]='\0';
					if(strcmp(line,"/jffs/user.cer")==0)
						long_ret=1;
					else
						long_ret=0;
					pclose(fp);
					}
				return (u_char *) &long_ret;
			}
        /*    prop_count=load_prop(SEP_EQUAL,WLAN_CONF,properties);
            get_prop("CERT_INDEX",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
            long_ret=atoi(ap_parameter);
            return (u_char*) &long_ret ;
            */
        case WAPICERTSTATE:
            prop_count=load_prop(SEP_EQUAL,WLAN_CONF,properties);
            get_prop("CERT_STATUS",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
            long_ret=atoi(ap_parameter);
            return (u_char*) &long_ret ;
        case WAPIASCERT: //heyanhua modify 2010-5-3
	    	*write_method = write_WapiAsCert;
         //   memset(ap_parameter,0,256);
            *var_len = strlen(asCert);
	    return (u_char*) asCert;	
        case WAPIUSERCERT:    //heyanhua modify 2010-5-3
	    	*write_method = write_WapiUserCert;
         //   memset(ap_parameter,0,256);
            *var_len = strlen(userCert);
            return (u_char*) userCert;
        case WAPIINSTALLCERT:   //heyanhua modify 2010-5-3
	    	*write_method = write_WapiInstallCert;   
			{
				FILE *fp;
				char line[256];
				char *q;
				fp=popen("find /jffs/user.cer","r");
				if(fp){
					memset(line,0,256);
					fgets(line,sizeof(line),fp);
					line[strlen(line)-1]='\0';
					if(strcmp(line,"/jffs/user.cer")==0)
						long_ret=1;
					else
						long_ret=0;
					pclose(fp);
					}
			}
			return (u_char *) &long_ret;
	    	//long_ret=WapiInstallCertFlag;
            //return (u_char*) &long_ret;
        case WAPINTPSERVERIP:
            *write_method = write_wapiNtpServerIP;
	    	memset(ap_parameter,0,256);
            result = wapiget_ip(NTP_CONF, SEP_EQUAL, "NTPIP",ap_parameter);
            if(result !=0)
                memset(ap_parameter,0,4);
            *var_len = 4;
            return (u_char*) ap_parameter;
        case WAPINTPNETTIMES:
            time(&now);
	    //printf("times=%d\n",now);
	    long_ret=abs(now+8*60*60);
            return  (u_char*) &long_ret;
        case WAPIBASICFLASH:
    	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
            get_prop("AP_FLASH",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	    *var_len = strlen(ap_parameter);
	    ap_parameter[*var_len]='\0';        
            return (unsigned char *) ap_parameter;
        case WAPIBASICCPU:
    	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
            get_prop("AP_CPU",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
	    *var_len = strlen(ap_parameter);
	    ap_parameter[*var_len]='\0';        
            return (unsigned char *) ap_parameter;
        case WAPIBASIC80211G:
	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
            get_prop("AP_80211G",ap_parameter,properties,prop_count);    
	    free_prop(properties,prop_count) ;	
	    *var_len = strlen(ap_parameter);
	    string[*var_len]='\0';
            return (u_char*) &ap_parameter ;
#if 0
        case WAPIALARMFLAG:
            *write_method = write_wapialarmflag;
            prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
            get_prop("ALARM_FLAG",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
            long_ret=atoi(ap_parameter);
            //printf("alarm flag = %d \n ",long_ret);
            return (u_char*) &long_ret ;
#endif
        case  WAPIAPSOFTPRIMVERSION:
	    prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
	    get_prop("AP_M_SOFTVER",ap_parameter,properties,prop_count);
	    free_prop(properties,prop_count);
            *var_len = strlen(ap_parameter);
	    string[*var_len]='\0';
            return (u_char*) ap_parameter;
        case  WAPIAPSOFTSECONDVERSION:
	    prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
	    get_prop("AP_S_SOFTVER",ap_parameter,properties,prop_count);
	    free_prop(properties,prop_count);
            *var_len = strlen(ap_parameter);
	    string[*var_len]='\0';
            return (u_char*) ap_parameter;
        case WAPIAPSOFTDEBUG:
	    //*write_method = write_wapiApSoftDebug;
	    ulong_ret=0;//wapiApSoftDebug;
	    return (u_char*) &ulong_ret;
        case WAPIBASICMEMORY:
	    	memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
            get_prop("AP_MEMORY",ap_parameter,properties,prop_count);    
	    	free_prop(properties,prop_count) ;
	    	*var_len = strlen(ap_parameter);
	    	string[*var_len]='\0';
            return (u_char*) &ap_parameter ;
        case WAPIHARDWAREVERSION :
	    	memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
            get_prop("PCB_HARDWAREVERSION",ap_parameter,properties,prop_count);    	    
	    	 free_prop(properties,prop_count) ;
	    	*var_len = strlen(ap_parameter);
	    	string[*var_len]='\0';
            return (u_char*) &ap_parameter ;
        case WAPIAPTYPE:
	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
            get_prop("AP_TYPE",ap_parameter,properties,prop_count);    
	    free_prop(properties,prop_count) ;
	    *var_len = strlen(ap_parameter);
	    string[*var_len]='\0';
            return (u_char*) &ap_parameter ;
#if 0
        case WAPIALARMTIMES:
            *write_method = write_wapialarmtimes;
	    	memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
            get_prop("ALARM_TIMES",ap_parameter,properties,prop_count);    
	    	free_prop(properties,prop_count) ;
	    	long_ret=atoi(ap_parameter);
	    	//printf("alarm times=%d\n",long_ret);
            return (u_char*) &long_ret ;
			
		case WAPISTARTSCANAPENABLED:
            *write_method = write_wapiStartScanApEnabled;	  
			long_ret=temp_start_scan_ap_enabled;
            return (u_char*) &long_ret ;

		case WAPIADDNEIGHBORHOODAPMACADDR:
           *write_method = write_wapiAddNeighborhoodApMacAddr;
			memset(ap_parameter,0,256);
			strcpy(ap_parameter,"00:00:00:00:00:00");
			*var_len = strlen(ap_parameter);
	    	ap_parameter[*var_len]='\0'; 
            return (u_char*) ap_parameter ;	
#endif
        case WAPIBASIC80211B:
	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
            get_prop("AP_80211B",ap_parameter,properties,prop_count);    
	    free_prop(properties,prop_count) ;
	    *var_len = strlen(ap_parameter);
	    string[*var_len]='\0';
            return (u_char*) &ap_parameter ;
        case WAPIBASICMAC:
            ret=wlan_getioctl_dev_addr(ap_parameter,"br0");
  	    if( ret !=1 ) 
  	       printf(" get Mac !!! .");
  	    *var_len = 6;
            return (u_char*) ap_parameter ;        
        case WAPICONFIGTXPOWER:
            *write_method = write_wapiConfigTxPower;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_TXPOWER",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            ulong_ret =atoi(ap_parameter);	
            return  (u_char*) &ulong_ret;
        case WAPICONFIGHOSTNAME:
            *write_method = write_wapiConfigHostName;
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	    get_prop("HOST_NAME",ap_parameter,properties,prop_count);
	    free_prop(properties,prop_count);
            *var_len = strlen(ap_parameter);
	    string[*var_len]='\0';
            return (u_char*) ap_parameter;
        case WAPICONFIGBEACONINTERVAL:
            *write_method = write_wapiConfigBeaconInterval;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_BEACON",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
	    ulong_ret =atoi(ap_parameter);        
            return (u_char*) &ulong_ret;
        case WAPICONFIGWIRELESSMODEA:
            // *write_method = write_wapiConfigWirelessModeA;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("AWLAN0_WMODE",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
	    ulong_ret=atoi(ap_parameter);
	    return  (u_char*) &ulong_ret;
        case WAPICONFIGWIRELESSMODEBG:
            *write_method = write_wapiConfigWirelessModeBG;
	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_WMODE",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            ulong_ret=atoi(ap_parameter);
            return (u_char*) &ulong_ret;
        case WAPICONFIGLANMASK:
            *write_method = write_wapiConfigLanMask;
            result = wapiget_ip(AP_BASE_CONF, SEP_EQUAL, "LAN_MASK", string );
	    if(result !=0)
	        memset(string,0,4);
            *var_len = 4;        
            return (u_char*) string;
        case WAPICONFIGLANGATEWAY:
            *write_method = write_wapiConfigLanGateway;
            result = wapiget_ip(AP_BASE_CONF, SEP_EQUAL, "LAN_GW", string );
	    if(result !=0)
	        memset(string,0,4);
            *var_len = 4;        
            return (u_char*) string;
        case WAPICONFIGLANIP:
            *write_method = write_wapiConfigLanIP;
	    	result = wapiget_ip(AP_BASE_CONF, SEP_EQUAL, "LAN_IP", string );
	    if(result !=0)
 	        memset(string,0,4);
            *var_len = 4;      
            return (u_char*) string; 
        case WAPICONFIGDTIMPERIOD:
            *write_method = write_wapiConfigDtimPeriod;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_FRAG",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret=atoi(ap_parameter);
            return  (u_char*) &ulong_ret;
        case WAPICONFIGFACTORYDEFAULT:
            *write_method = write_wapiConfigfactoryDefault;
            ulong_ret = 0;
            return (u_char*) &ulong_ret;
        case WAPICONFIGREBOOT:
            *write_method = write_wapiConfigReboot;
            ulong_ret = 0;
            return (u_char*) &ulong_ret;
        case WAPICONFIGRTSTHRESHOLD:
            *write_method = write_wapiConfigRtsThreshold;
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("WLAN0_RTS",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count);
            memcpy(string, ap_parameter, strlen(ap_parameter));
            ulong_ret =atoi(ap_parameter);     
          //  ulong_ret=atoi(string);
            return (u_char*) &ulong_ret;
			
 		case WAPIAPACCESSMAXUSERS:
		#if 0
			*write_method = write_wapiApAccessMaxUsers;
			memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            if(get_prop("AP_MAX_LIMLT_ACCESS_USERS",ap_parameter,properties,prop_count)==NULL){
				save_global_conf(SEP_EQUAL,WIRELESS_CONF,"",\
											"AP_MAX_LIMLT_ACCESS_USERS", "896");
			}
            free_prop(properties,prop_count);
			long_ret=get_ap_access_max_users(&countUsers); 
			if(long_ret > atoi(ap_parameter)){
				long_ret= atoi(ap_parameter);
			}
		#endif
	       long_ret =0;   // by sunyushuang0320
          	return (u_char*) &long_ret;
			
		case WAPIAPSYSVERSION:
   	     	memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,WLAN_SYSINFO,properties);
            get_prop("AP_MANUFACTURER",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
		    *var_len = strlen(ap_parameter);
		    ap_parameter[*var_len]='\0';

		    if (atoi(ap_parameter) == 7)
		    {
		    		memset(ap_parameter, 0, sizeof(ap_parameter));
				strcpy(ap_parameter, "HM-API01 V10.06");
				*var_len = strlen(ap_parameter);
		    }
		    else
		    {
		    		memset(ap_parameter, 0, sizeof(ap_parameter));
				strcpy(ap_parameter, "V10.06");
				*var_len = strlen(ap_parameter);
		    }
		    return (unsigned char *)ap_parameter;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


int 
get_ap_access_max_users(int *count){
	int mode=0;
	int ssidNum=0,i,temp;
	int users =0;
    struct wlan_info_t  *wlan_list ;
    static struct  wlan_info_t  wlantable[MSSID_NUMBER],*wlp,*wtp;

	mode=get_ap_work_mode();
	if(mode==1){
		ssidNum=get_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, &wlan_list); 
	}else if(mode==2){
		ssidNum=get_wlan_table(WLAN_11ITEMP_CONFIG, WLAN_BEGIN, WLAN_END, &wlan_list); 
	}
	
    bzero(wlantable,sizeof(wlantable));
    wlp=wlan_list;
    wtp=wlantable;
    while(wlp!=NULL){   
    	memcpy(wtp,wlp,sizeof(struct wlan_info_t));
    	wlp=wlp->next;
   		wtp++;
    }
    free_wlan_table(& wlan_list);
    wlan_list=wlantable;
	printf("ssidNum=%d\n",ssidNum);
	for(i=0;i<ssidNum;i++){
		users += atoi(wlan_list->max_user);
		printf("users=%d\n",users);
		wlan_list++;	
	}
	count[0]=users;
	printf("count=%d\n",&count);
	return users;
}

int
write_wapiApAccessMaxUsers(int      action,
									u_char   *var_val,
									u_char   var_val_type,
									size_t   var_val_len,
									u_char   *statP,
									oid      *name,
									size_t   name_len)
{
    char temp[10];
    int value;
	int status=0;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          	value = * (long *) var_val;
          	if( value < 0 || value > 896 ){
			  	return SNMP_ERR_WRONGVALUE;
			 }
          	break;
        case RESERVE2:
          	break;
        case FREE:
          	break;
        case ACTION:
			memset(temp,0,10);
			sprintf(temp, "%d",*(long *) var_val);
			save_global_conf(SEP_EQUAL,WIRELESS_CONF,"",\
							"AP_MAX_LIMLT_ACCESS_USERS", temp);
			system("/usr/local/boa/htmls/script/wireless_scr");		
          	break;
        case UNDO:
          	break;
        case COMMIT:
          	break;
    }
    return SNMP_ERR_NOERROR;
}

// add by piyp 2008-11-28
int
write_wapiConfigWirelessDataRateBG(int      action,
								u_char   *var_val,
								u_char   var_val_type,
								size_t   var_val_len,
								u_char   *statP,
								oid      *name,
								size_t   name_len){
    long tmpvalue;
    u_char value;
    prop_data properties[KEYS_MAX];
    int prop_count = 0;
   
    //11b/g:auto(0), 1M(1), 2M(2), 5aHalf(3), 6M(4), 9M(5),\
    //11M(6), 12M(7), 18M(8), 24M(9), 36M(10), 48M(11), 54M(12)
    //11b:0,1,2,5.5,11
    u_char rate11b_val[] = {0, 1, 2, 3, 6}; //值为数组下标
    //11g:0,6,9,12,18,24,36,48,54
    u_char rate11er_val[] = {0, 4, 5, 7, 8, 9, 10, 11, 12}; //值为数组下标
    size_t i = 0;
    char val_in_arr = 0; //0-not found,1-found
    char wlan0_wmode[8] = {0};
    char wmode = 0;
    char strtemp[256] = {0};

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	      tmpvalue = * (char *) var_val ;
	        if((tmpvalue <0)|| (tmpvalue >12) )
		        return SNMP_ERR_WRONGVALUE;
          break;
        case RESERVE2:
          break;
        case FREE:
             /* Release any resources that have been allocated */
          break;
        case ACTION:
   	      tmpvalue = * (long *) var_val ;
	        if((tmpvalue <0) || (tmpvalue >12) )
		        return SNMP_ERR_WRONGVALUE;

          value = (u_char)tmpvalue;
          prop_count = load_prop(SEP_EQUAL, WIRELESS_CONF,properties);	
          get_prop("WLAN0_WMODE", wlan0_wmode, properties, prop_count);
          free_prop(properties, prop_count);
          wmode = atol(wlan0_wmode);
          if ( (2 != wmode) && (3 != wmode) )
				return SNMP_ERR_WRONGVALUE;

          val_in_arr = 0;
          for(i=0; i<5; ++i) //sizeof(rate11b_val)/sizeof(u_char)
          {
            if (value == rate11b_val[i])
            {
              val_in_arr = 1;
              break;
            }
          }
          if((1 != val_in_arr) && (2 == wmode))
            return SNMP_ERR_WRONGVALUE;

          if (1 != val_in_arr)
          {
            for(i=0; i < 9; ++i) //sizeof(rate11er_val)/sizeof(u_char)
            {
              if (value == rate11er_val[i])
              {
                val_in_arr = 1;
                break;
              }
            }
          }
          if (1 != val_in_arr)
            return SNMP_ERR_WRONGVALUE;

          memset(strtemp, 0, sizeof(strtemp));
          if (0 == value)
          {
            if (2 == wmode)
              sprintf(strtemp, "%s", "11M auto");
            else //wmode = 3
              sprintf(strtemp, "%s", "54M auto");
          }
          else
          {
            sprintf(strtemp, "%s %s", wireless_datarate_str[value], WIRELESS_DATARATE_TYPE_FIXED);
          }
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_DATARATE", strtemp);
          system("/usr/local/boa/htmls/script/wireless_scr");  
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_wapiConfigWirelessDataRateA(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long tmpvalue;
    u_char value;
    //auto(0), 1M(1), 2M(2), 5aHalf(3), 6M(4), 9M(5), 11M(6), 
    //12M(7), 18M(8), 24M(9), 36M(10), 48M(11), 54M(12)
    u_char rate11a_val[] = {0, 4, 5, 7, 8, 9, 10, 11, 12};
    size_t i=0;
    char val_in_arr = 0;
    char strtemp[256] = {0};

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	      tmpvalue = * (long *) var_val ;
	      if((tmpvalue <0) || (tmpvalue >12) )
		        return SNMP_ERR_WRONGVALUE;
          break;
        case RESERVE2:
          break;
        case FREE:
          break;
        case ACTION:
          tmpvalue = * (long *) var_val ;
	        if((tmpvalue <0) || (tmpvalue >12) )
		        return SNMP_ERR_WRONGVALUE;

		      value = (u_char)tmpvalue;
		      val_in_arr = 0;
          for (i=0; i < 9; ++i) ////sizeof(rate11a_val)/sizeof(u_char)
          {
            if (value == rate11a_val[i])
            {
              val_in_arr = 1;
              break;
            }
          }
          if (1 != val_in_arr)
            return SNMP_ERR_WRONGVALUE;

          memset(strtemp, 0, sizeof(strtemp));
          if (0 == value)
            sprintf(strtemp, "%s", "54M auto");
          else
            sprintf(strtemp, "%s %s", wireless_datarate_str[value], WIRELESS_DATARATE_TYPE_FIXED);
            save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_DATARATE",strtemp);
		    system("/usr/local/boa/htmls/script/wireless_scr");
          
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



// add by piyp 2008-11-27

int
get_ap_rf_status(){
	prop_data properties[KEYS_MAX];
    int prop_count=0;
	static char ap_parameter[256];
	int rf1=0,rf2=0;
	memset(ap_parameter,0,256);
    prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
	get_prop("WLAN0_RF",ap_parameter,properties,prop_count);
	rf1 = atoi(ap_parameter);
	memset(ap_parameter,0,256);
	get_prop("AWLAN0_RF",ap_parameter,properties,prop_count);
	rf2 = atoi(ap_parameter);
	free_prop(properties,prop_count);
	
	if(rf1==1 && rf2==1){
		return 1;		
	}else {
		return 0;	
	}

}

int
write_wapiMultiModeAccessStatus(int      action,
									u_char   *var_val,
									u_char   var_val_type,
									size_t   var_val_len,
									u_char   *statP,
									oid      *name,
									size_t   name_len)
{
    char temp[10];
    int value;
	int status=0;
	prop_data properties[KEYS_MAX];  //heyh add start 091118
    int prop_count=0;
	static char ap_parameter[256];
	int rf=0;
	memset(ap_parameter,0,256);
    prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
	get_prop("WLAN_RF_FLAG",ap_parameter,properties,prop_count);
	rf = atoi(ap_parameter);
	free_prop(properties,prop_count);    //heyh add end 091118
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          	value = * (long *) var_val;
          	if( value < 0 || value > 1 ){
			  	fprintf( stderr, "value is'not 1 and 0)\n" );
			  	return SNMP_ERR_WRONGVALUE;
			 }
          	break;
        case RESERVE2:
          	break;
        case FREE:
          	break;
        case ACTION:
			memset(temp,0,10);
			sprintf( temp, "%d",*(long *) var_val);
			status = get_ap_rf_status();
			printf("value= %ld",value);
			printf("status= %ld",status);
			//if(*(long *) var_val==1){
			if(status==1){      //modify by heyh ------091118
			if(*(long *) var_val==1){
				save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_RF", temp);
				save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_RF", temp);
				save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN_RF_FLAG", temp);  // modify by heyh  ------091118
				//system("/usr/local/boa/htmls/script/wireless_scr");
			}else{
			//	if(status==1){   // modify by heyh  ------091118
			    if(status&&rf){
				//	save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_RF", "0");     //modify by heyh   -----091118
					save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN_RF_FLAG", "0");
					//system("/usr/local/boa/htmls/script/wireless_scr");
				}
			}
			}
			
          	break;
        case UNDO:
          	break;
        case COMMIT:
          	break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wapiAccessControlEnabled(int      action,
							u_char   *var_val,
							u_char   var_val_type,
							size_t   var_val_len,
							u_char   *statP,
							oid      *name,
							size_t   name_len)
{
    char temp[10];
    int value;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          	value = * (long *) var_val;
          	if( value < 0 || value > 1 ){
			  	fprintf( stderr, "value is'not 0 and 1)\n" );
			  	return SNMP_ERR_WRONGVALUE;
			 }
          	break;
        case RESERVE2:
          	break;
        case FREE:
          	break;
        case ACTION:
			memset(temp,0,10);
			sprintf( temp, "%d",*(long *) var_val);
            save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"","ACCESS_CONTROL_ENABLED", temp);
			system(IPTABLE_FILTER_SCR);
          	break;
        case UNDO:
          	break;
        case COMMIT:
          	break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiAccessControlUsers(int      action,
							u_char   *var_val,
							u_char   var_val_type,
							size_t   var_val_len,
							u_char   *statP,
							oid      *name,
							size_t   name_len)
{
    char temp[10];
    int index,value;
	prop_data properties[KEYS_MAX];
    int prop_count=0;
	static char ap_parameter[256];
	int i=0;
	char ipAddrName[25],indextemp[5];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          	value = * (long *) var_val;
          	if( value < 0 || value > 10 ){
			  	fprintf( stderr, "value is'not 1 and 10)\n" );
			  	return SNMP_ERR_WRONGVALUE;
			 }
          	break;
        case RESERVE2:
          	break;
        case FREE:
          	break;
        case ACTION:
			memset(temp,0,10);
			sprintf( temp, "%d",*(long *) var_val);
			prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
    		get_prop("ACCESS_CONTROL_USERS", ap_parameter, properties, prop_count);
			free_prop(properties,prop_count);
			index = atoi(ap_parameter);
			int ret =(index-(*(long *) var_val));
			if(*(long *) var_val<=index){
				for(i=1;i<= (index-(*(long *) var_val));i++){
					memset(ipAddrName,0,25);
					memset(indextemp,0,5);
					strcpy(ipAddrName,"ACCESS_CONTROL_IP_");
					sprintf(indextemp,"%d",(ret+i));
					strcat(ipAddrName,indextemp);
					save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"",ipAddrName, " ");
				}
			}		
            save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"","ACCESS_CONTROL_USERS", temp);
			//system(IPTABLE_FILTER_SCR);
          	break;
        case UNDO:
          	break;
        case COMMIT:
          	break;
    }
    return SNMP_ERR_NOERROR;
}
unsigned char *
var_wapiAccessControlSettingTable(struct variable *vp,
    	    				oid     *name,
    	    				size_t  *length,
    	    				int     exact,
    	    				size_t  *var_len,
    	    				WriteMethod **write_method)
{
 	static unsigned  long  ulong_ret;
	static long long_ret;
   	static unsigned char string[SPRINT_MAX_LEN];
 	int tableSize,i,id;
	struct ifnet wifi0,wifi1,*wp;
   	prop_data properties[KEYS_MAX];
   	int prop_count=0;
	static char ap_parameter[256];
	int j;
	
	prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
	if(get_prop("ACCESS_CONTROL_USERS",ap_parameter,properties,prop_count)==NULL){
		save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"","ACCESS_CONTROL_USERS", "10");		
	}
    free_prop(properties,prop_count);
	if(ap_parameter==NULL){
		tableSize = 0;
	}else{
	tableSize = atoi(ap_parameter);
	}
	if(tableSize==0)  return 0;
	
   
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tableSize)
                                                == MATCH_FAILED )
    {
    	return NULL;
    }
	id = (name[*length - 1]<2)?1:name[*length - 1];

    if (name[*length - 1] > tableSize)
    {       
        DEBUGMSGTL(("nb/wapiPwlanAp", "nb -- no match: %lu\n",i));
        return NULL;
    }
	
    
	for (i=1;i<name[*length-1];i++)
    {
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- %lu != %lu\n",i, name[*length - 1]));
		
    }
  

  /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
   
    case ACCESSCONTROLINDEX:
		ulong_ret = id;
	    return (unsigned char *)&ulong_ret;
	case ACCESSCONTROLIPLIST:
        *write_method = write_wapiAccessControlIpList;
		 get_ip_list(id,ap_parameter);
		long_ret=inet_addr(ap_parameter);    	  
    	memcpy(string, (char *)&long_ret, 4);
    	*var_len = 4;
	    return (unsigned char *)string;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
get_ip_list(int index,char *ip)
{
	prop_data properties[KEYS_MAX];
    int prop_count=0;
	char ipAddrName[25],temp[5];
	memset(ipAddrName,0,25);
	memset(temp,0,5);
	strcpy(ipAddrName,"ACCESS_CONTROL_IP_");
	sprintf(temp,"%d",index);
	strcat(ipAddrName,temp);
	
       prop_count=load_prop(SEP_EQUAL,AG_SNMP_CONF,properties);
	if(get_prop(ipAddrName,ip,properties,prop_count)==NULL){
		save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"",ipAddrName, "192.168.14.21");
	}
	free_prop(properties,prop_count);
	
	return 1;
	
}



int
write_wapiAccessControlIpList(int      action,
							u_char   *var_val,
							u_char   var_val_type,
							size_t   var_val_len,
							u_char   *statP,
							oid      *name,
							size_t   name_len)
{
    int index,value;
	char ipAddrName[25],indextemp[5],temp[20];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          
          	break;
        case RESERVE2:
          	break;
        case FREE:
          	break;
        case ACTION:
			memset(temp,0,20);
          		sprintf(temp,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
			index = (int)name[name_len-1];
			memset(ipAddrName,0,25);
			memset(indextemp,0,5);
			strcpy(ipAddrName,"ACCESS_CONTROL_IP_");
			sprintf(indextemp,"%d",index);
			strcat(ipAddrName,indextemp);
            		save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"",ipAddrName, temp);
          	break;
        case UNDO:
          	break;
        case COMMIT:
          	break;
    }
    return SNMP_ERR_NOERROR;
}



/*
*---------add by piyongping 2008-11-21----------------------
*          射频功率管理
*/


unsigned char *
var_wapiAuthenticationAlgorithmTable(struct variable *vp,
    	    				oid     *name,
    	    				size_t  *length,
    	    				int     exact,
    	    				size_t  *var_len,
    	    				WriteMethod **write_method)
{
 	static long  long_ret;
    struct wlan_info_t wlaninfo; 
 	int tableSize,i,id;
	static char ap_parameter[256];
	int mode=0,j;
	int temp_ret=0;

	static char ifname[IFNAME_MAX],tempIfname[IFNAME_MAX];
    char *ip,*tq,*iq;
	
    bzero(ifname,IFNAME_MAX);
    bzero(tempIfname,IFNAME_MAX);
	
    tableSize=iw_get_wifis();
    if(tableSize==0)  return 0;
    
    temp_ret = iw_enum_wlan_interface(tempIfname);
    if(temp_ret!=0){
        tq=tempIfname;
        iq=ifname;
        for(j=0,tableSize=0;j<temp_ret;tq=tq+IFNAME_LEN,j++){
            if(strstr(tq,"awlan")==NULL){
	           	strcpy(iq,tq);
		    	tableSize++; 
		    	iq=iq+IFNAME_LEN;		
	      	}
        }
	 	ip=ifname;	
    }
    
	
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tableSize)
                                                == MATCH_FAILED )
    {
    	return NULL;
    }
	id = (name[*length - 1]<2)?1:name[*length - 1];
	
    if (name[*length - 1] > tableSize)
    {       
        DEBUGMSGTL(("nb/wapiPwlanAp", "nb -- no match: %lu\n",name[*length - 1]));
        return NULL;
    }
	
    memset(&wlaninfo,0,sizeof(wlaninfo));
	mode=get_ap_work_mode();
	if(mode==1){
		serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ip,&wlaninfo); 
	}else if(mode==2){
		serch_by_name(WLAN_11ITEMP_CONFIG, WLAN_BEGIN, WLAN_END, ip,&wlaninfo); 
	}
	for (i=1;i<name[*length-1];i++)
    {
		ip+=IFNAME_LEN;
		memset(&wlaninfo,0,sizeof(wlaninfo));
		mode=get_ap_work_mode();
		if(mode==1){
			serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ip,&wlaninfo); 
		}else if(mode==2){
			serch_by_name(WLAN_11ITEMP_CONFIG, WLAN_BEGIN, WLAN_END, ip,&wlaninfo); 
		}
		
		DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- %lu != %lu\n",i, name[*length - 1]));
		
    }
  

  /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
   
    case	WAPIDOT11AUTHENTICATIONALGORITHM:
			   	   	
		 *write_method = write_wapidot11AuthenticationAlgorithm;
			
			if(atoi(wlaninfo.auth)==0) {
				long_ret=(atoi(wlaninfo.auth)| 0x0000001);	
				printf("long_ret1=%d\n",long_ret);
			}else if(atoi(wlaninfo.auth)==11){
		    	long_ret=((atoi(wlaninfo.auth)>>2) | 0x0000001);			 
		    	printf("long_ret2=%d\n",long_ret);
			}else{
				long_ret=2;
				printf("long_ret3=%d\n",long_ret);
				
	    	}
            return (u_char*) &long_ret ; 
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
*---------add by piyongping 2008-11-21----------------------
*          射频功率管理
*/


unsigned char *
var_wapiPowerMgmtTable(struct variable *vp,
    	    				oid     *name,
    	    				size_t  *length,
    	    				int     exact,
    	    				size_t  *var_len,
    	    				WriteMethod **write_method)
{
 	static unsigned  long  ulong_ret;
 	int tableSize,i,id;
	struct ifnet wifi0,wifi1,*wp;
   	prop_data properties[KEYS_MAX];
   	int prop_count=0;
	static char ap_parameter[256];
	int dbm=0,j;
	int temp_ret=0;
	int channel[2]={0,},*pc;
	static char ifname[IFNAME_MAX],tempIfname[IFNAME_MAX];
   	char *ip,*tq,*iq;
	
    bzero(ifname,IFNAME_MAX);
    bzero(tempIfname,IFNAME_MAX);
	
    tableSize=iw_get_wifis();
    if(tableSize==0)  return 0;
	memset(ap_parameter,0,256);
    prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
	if(get_prop("WLAN0_RF",ap_parameter,properties,prop_count)==NULL){
		save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_RF", "1");
	}
	free_prop(properties,prop_count);

    temp_ret = iw_enum_wlan_interface(tempIfname);
		
    if(temp_ret!=0){
        tq=tempIfname;
        iq=ifname;
        for(j=0;j<temp_ret;j++){	
             if(strstr(tq,"awlan")==NULL){
	           strcpy(iq,tq);		
		    iq=iq+IFNAME_LEN;		
	      	}else{
				strcpy(iq,tq);
	      }
			tq=tq+IFNAME_LEN;
        }
	 ip=ifname;	
    }
	dbm = iw_get_txPower(ip);
 	iw_enum_channel(tableSize, channel);
	pc =channel;
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tableSize)
                                                == MATCH_FAILED )
    {
    	return NULL;
    }
	id = (name[*length - 1]<2)?1:name[*length - 1];
    if (name[*length - 1] > tableSize)
    {       
        DEBUGMSGTL(("nb/wapiPwlanAp", "nb -- no match: %lu\n",i));
        return NULL;
    }
	
	for (i=1;i<name[*length-1];i++)
    	{
       		DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- %lu != %lu\n",i, name[*length - 1]));
		memset(ap_parameter,0,256);
    		prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
		if(get_prop("AWLAN0_RF",ap_parameter,properties,prop_count)==NULL){
			save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_RF", "1");
		}
		free_prop(properties,prop_count);
		 if(temp_ret!=0){
	     ip=ip+IFNAME_LEN;
	 	}
		 
		dbm = iw_get_txPower(ip);
		pc = channel+1;
    }

 /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case RFPOWERMANAGER:
        *write_method = write_rfPowerManager;
		ulong_ret = atoi(ap_parameter);
	       return (unsigned char *)&ulong_ret;
  case RFTXPOWER:
        *write_method = write_rfPowerManager;
	 	ulong_ret = dbm;
      return (unsigned char *)&ulong_ret;
   	case RFCURRENTCHANNEL:
        *write_method = write_ChStatsChannel;
		ulong_ret = *pc;;
	       return (unsigned char *)&ulong_ret;
    default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_rfPowerManager(int      action,
				u_char   *var_val,
				u_char   var_val_type,
				size_t   var_val_len,
				u_char   *statP,
				oid      *name,
				size_t   name_len)
{
    char temp[10];
    int index,value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          	value = * (long *) var_val;
          	if( value < 0 || value > 1 ){
			  	fprintf( stderr, "value is'not 1 and 0)\n" );
			  	return SNMP_ERR_WRONGVALUE;
			 }
          	break;
        case RESERVE2:
          	break;
        case FREE:
          	break;
        case ACTION:
			memset(temp,0,10);
			sprintf( temp, "%d",*(long *) var_val);
			index = (int)name[name_len-1];
			if(index==1){	
             	save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_RF", temp);
			}else{
				save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_RF", temp);
			}
			
			system("/usr/local/boa/htmls/script/wireless_scr");
			
          	break;
        case UNDO:
          	break;
        case COMMIT:
          	break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiStartConfigAP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[10];
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   value = * (long *) var_val ;
	   if(value==0){
              sprintf(temp,"%ld",156);
              save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","COUNTRYCODE",temp);
		save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_CHANNEL","0");
	   }

	   if(value==1){
              sprintf(temp,"%ld",36);
              save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","COUNTRYCODE",temp);
		save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_CHANNEL","0");
	   }
	   
          strcpy(scr_file, AP_REBOOT_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
          return SNMP_ERR_GENERR;

          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int write_wapiApFrequencySwitch(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[10];
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   value = * (long *) var_val ;
	   if(value==0){
              sprintf(temp,"%ld",156);
              save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","COUNTRYCODE",temp);
		save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_CHANNEL","0");
	   }

	   if(value==1){
              sprintf(temp,"%ld",36);
              save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","COUNTRYCODE",temp);
		save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_CHANNEL","0");
	   }
	   
          strcpy(scr_file, AP_REBOOT_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
          return SNMP_ERR_GENERR;

          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiApWZC(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[10];
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_NOPRIVACY",temp);

          strcpy(scr_file, WIRELESS_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
          return SNMP_ERR_GENERR;

          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



void  report_RF_trap()
{
    char trapStrA[]="changed ARF  ";
    char trapStrB[]="changed BRF  ";
    AAT aat;
    time_t nowTimes;
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    char ap_parameter[30];
    int ret1=0,ret2=0;  

   time(&nowTimes);	  
   bzero(ap_parameter,30);
   prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
   get_prop("WLAN0_RF",ap_parameter,properties,prop_count);
   ret1=atoi(ap_parameter);
   bzero(ap_parameter,30);
   get_prop("AWLAN0_RF",ap_parameter,properties,prop_count);
   ret2=atoi(ap_parameter);
   free_prop(properties,prop_count);
    if(switch_rf_A!=ret1){
          memset(&aat,0,sizeof(aat));
		  set_alarm( & aat,ALARM_ID_WLAN_RF_A,trapStrA);
          send_trap_string_notification(&aat);	
	   switch_rf_A=ret1;
    }
    if(switch_rf_B!=ret2){
          memset(&aat,0,sizeof(aat));
		  set_alarm( & aat,ALARM_ID_WLAN_RF_B,trapStrA);
          send_trap_string_notification(&aat);	  
          switch_rf_B=ret2;
    }

}

int write_wapiApARF(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[10];
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
#if 0
    char trapStr[]="changed ARF  ";
    AAT aat;
    time_t nowTimes;
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    char ap_parameter[30];
#endif	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_RF",temp);
#if 0
	   time(&nowTimes);	  
	   bzero(ap_parameter,30);
	   prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	   get_prop("LAN_IP",ap_parameter,properties,prop_count);
	   free_prop(properties,prop_count);
          memset(&aat,0,sizeof(aat));
         // set_alarm( & aat,27,ap_parameter,"1","3",0,nowTimes,nowTimes,1,"wapiApARF",trapStr);
          send_trap_string_notification(&aat);	
	   sleepTime=1;
#endif		  
          strcpy(scr_file, WIRELESS_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
          return SNMP_ERR_GENERR;

          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int write_wapiApBRF(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[10];
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
#if 0
    char trapStr[]="changed BRF  ";
    AAT aat;
    time_t nowTimes;
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    char ap_parameter[30];
#endif	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_RF",temp);
#if 0
	   time(&nowTimes);	  
	   bzero(ap_parameter,30);
	   prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	   get_prop("LAN_IP",ap_parameter,properties,prop_count);
	   free_prop(properties,prop_count);
          memset(&aat,0,sizeof(aat));
          set_alarm( & aat,28,ap_parameter,"1","3",0,nowTimes,nowTimes,1,"wapiApBRF",trapStr);
          send_trap_string_notification(&aat);	
	   sleepTime=1; 
#endif		  
          strcpy(scr_file, WIRELESS_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
          return SNMP_ERR_GENERR;

          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int	
write_wapiMssidDel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{ 

    long value,ret=0,tmp=0;
    int size,findFalg=-1;
    char user_info[1024]="";
    struct wlan_info_t wlan_info_item;
    static int delflag=0;
    char wlanName[32];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

          break;
        case RESERVE2:
          delflag=1;
          break;
        case FREE:
          break;

        case ACTION:
	     bzero(wlanName, 32);
	     memcpy(wlanName,var_val,var_val_len);
	     wlanName[var_val_len]='\0';
	     if (strstr(wlanName,"ath")==NULL) {
         	fprintf(stderr,"write to wapiPwlanAp: bad value\n");
            return SNMP_ERR_WRONGVALUE;
         }
		 
         value=find_mssid_count(WLAN_CONFIG, WLAN_BEGIN, WLAN_END,wlanName,&findFalg);
			 

	     if(findFalg==1){

       		ret=count_mssib(WLAN_CONFIG, WLAN_BEGIN, WLAN_END);	
       		if(value>ret){ 
       			return SNMP_ERR_WRONGVALUE;
       		}
       		memset(&wlan_info_item,0,sizeof(struct wlan_info_t));
       		tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, value,&wlan_info_item);
       	    if(tmp==0){
                fprintf(stderr,"write to wapiMssidWlanSSID: not config wlan \n");
       		   	delflag=0;
                return SNMP_ERR_NOCREATION;
       	    }
       		/*config wapi */
            del_MSSID_conf(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, value);      
       		bzero(user_info, 1024);
       	    sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
       			wlan_info_item.dev_name,
       			wlan_info_item.ssid,
       			wlan_info_item.ssid_hide,
       			wlan_info_item.auth,
       			wlan_info_item.psk_type,
       			wlan_info_item.psk_key,
       			wlan_info_item.vlan_id,
       			wlan_info_item.qos,
       			wlan_info_item.mac_cmd,
       			wlan_info_item.max_user);
       		
             ret = start_wlan_scr(DEL_FORK, &wlan_info_item);
       	     if(ret != 0)	{
       	  	     fprintf(stderr,"write_wapiMssidDel:  fork error \n");
       		     save_MSSID_conf1(WLAN_CONFIG, WLAN_BEGIN,WLAN_END, wlan_info_item);
       	     }
       	     ret = inform_wapid(CGI_CMD_DEL_DEV, user_info,strlen(user_info)+1);

	      	}

          break;
        case UNDO:

          break;
        case COMMIT:

          break;
    }

    return SNMP_ERR_NOERROR;
}


int
write_wapiMssidAdd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
 
    long value,ret=0,tmp=0,i=0;
    int size,tt=0,tl=0;
    char str[20];
    static char ap_parameter[256];
	static char ap_param[256];
    prop_data properties[KEYS_MAX];
    int prop_count=0;  
    char user_info[1024]="";
    struct wlan_info_t wla0;
	int ifnums,j,existusers=0;
	struct wlan_info_t *wlan_list;
	char usertmp[10];
	char ifname[IFNAME_MAX],*p;
    switch ( action ) {
        case RESERVE1:
          	if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          	}
          	if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          	}
	   		value = * (long *) var_val;
          	if (value<=0 ||  value >1 ) {
              fprintf(stderr,"write to wapiPwlanAp: date error \n");
              return SNMP_ERR_WRONGVALUE;
          	}	
	   		ret = count_mssib(WLAN_CONF, WLAN_BEGIN, WLAN_END);
			printf("ret1=%d\n",ret);
          	if (ret>=MSSID_NUMBER) {
              fprintf(stderr,"write to wapiPwlanAp: over ssid number   \n");
              return SNMP_ERR_WRONGVALUE;
          	}	  
          break;
        case RESERVE2:
          break;
        case FREE:
          break;

        case ACTION:
        	value = * (long *) var_val;
	   		memset(&mbssid_ver,0,sizeof(struct  wlan_info_t ));
			bzero(ap_parameter, 256);
			ret=init_wlanname_table( ap_parameter);
			if(ret==-1){  
	            return  SNMP_ERR_WRONGVALUE;
			}
			strcpy(mbssid_ver.dev_name,ap_parameter);				
			addDelEdit=MSSID_ADD;
			//get exist users  add by piyp 2009-01-13
			get_ap_access_max_users(&existusers);
			printf("existusers=%d\n",existusers);
			bzero(ap_param, 256);
			prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
            get_prop("AP_MAX_LIMLT_ACCESS_USERS",ap_param,properties,prop_count);
            free_prop(properties,prop_count);
			printf("ap_param=%d\n",atoi(ap_param));
			if(existusers >=(atoi(ap_param))){
				fprintf(stderr,"write to wapiPwlanAp: err user number,not user add\n");
              	return SNMP_ERR_WRONGVALUE;
			}else{
				bzero(usertmp, 10);
				sprintf(usertmp,"%d",(atoi(ap_param)-existusers));
				printf("usertmp=%s\n",usertmp);
			}
	   		//display_mssid(mbssid_ver);
	   		// by sunyushuang0321
	   		if(strstr(mbssid_ver.dev_name,"ath")==NULL){
				addDelEdit=0;
				return SNMP_ERR_WRONGVALUE;
	   		}
			if(strlen(mbssid_ver.ssid)==0){
		    	strcpy(mbssid_ver.ssid,"CMCC");
			}
			if(strlen(mbssid_ver.ssid_hide)==0){
		    	strcpy(mbssid_ver.ssid_hide,"0");
			}
			if(strlen(mbssid_ver.auth)==0){
		    	strcpy(mbssid_ver.auth,"0");
			}		
			if(strlen(mbssid_ver.psk_type)==0){
				   strcpy(mbssid_ver.psk_type,"N/A");
			}
			if(strlen(mbssid_ver.psk_key)==0){		    
				   strcpy(mbssid_ver.psk_key,"N/A");
			}
			if(strlen(mbssid_ver.vlan_id)==0){
				   strcpy(mbssid_ver.vlan_id,"0");
			}
			if(strlen(mbssid_ver.qos)==0){
				   strcpy(mbssid_ver.qos,"0");
			}
			if(strlen(mbssid_ver.mac_cmd)==0){
				   strcpy(mbssid_ver.mac_cmd,"0");
			}
			if(strlen(mbssid_ver.max_user)==0){
				   strcpy(mbssid_ver.max_user,usertmp);
			}
			/*auth*/
			//display_mssid(mbssid_ver);
			ret=atoi(mbssid_ver.auth);
	        if(ret==0){
        	    bzero(mbssid_ver.psk_type, sizeof(mbssid_ver.psk_type));
		    	bzero(mbssid_ver.psk_key, sizeof(mbssid_ver.psk_key));
		    	strcpy(mbssid_ver.psk_type,"N/A");
		    	strcpy(mbssid_ver.psk_key,"N/A"); 
			}else if(ret==7){
		    	//display_mssid(mbssid_ver);
		    	if(!strcmp(mbssid_ver.psk_type,"N/A")){
		       		goto error;
		    	}else {		    
		        	tmp=atoi(mbssid_ver.psk_type);
					if(tmp==0) {
			    		if(!strcmp(mbssid_ver.psk_key,"N/A")){
			        		goto error;
			    		}
					}else if (tmp==1){
			    		if(!strcmp(mbssid_ver.psk_key,"N/A")){
			        		goto error;
			    		}
			    		bzero(str, 20);
			    		strcpy(str,mbssid_ver.psk_key);
			    		printf("str16=%s\n",str);
			    		tl=strlen(str);
			    		for(i=0;i<tl;i++) { //whether hex number
			        		if(str[i]>='0' && str[i] <='9' ){  
								continue ;
							}else if  (str[i]>='a' && str[i] <='f' ){ 
								continue ;
							}else if  (str[i]>='A' && str[i] <='F' ){ 
								continue ;
							}else {
				     			fprintf(stderr,"write to write_wapiMssidPsk: auth value  not  hex number \n");
				     			goto error;					     
				 		}
			    	}
		        }else{
			     	goto error;
		       	}
		    	} 
			}
			else {
	        	bzero(mbssid_ver.psk_type, sizeof(mbssid_ver.psk_type));
			    bzero(mbssid_ver.psk_key, sizeof(mbssid_ver.psk_key));
			    strcpy(mbssid_ver.psk_type,"N/A");
			    strcpy(mbssid_ver.psk_key,"N/A"); 
			}
		
	      /*valn*/
		  #if 0
    	    memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
            get_prop("VLAN",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
            ret =atoi(ap_parameter);
		    if(ret==0) {
		    	bzero(mbssid_ver.vlan_id, sizeof(mbssid_ver.vlan_id));
				strcpy(mbssid_ver.vlan_id,"0");
		    }
		    if(ret==1){
				if(strlen(mbssid_ver.vlan_id)==0){
					goto error ;
				}
				tl=add_valn_to_mssid(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, atoi(mbssid_ver.vlan_id), mbssid_ver);
		        printf("vlanid error tl=%d  \n",tl );
				if(tl==-1){	
					printf("vlanid error \n");
				    goto error ;
		        }
		     }
			#endif
            addDelEdit=0;
		  
	      	/*config wapi */
	     	 bzero(user_info, 1024);
	         sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
					mbssid_ver.dev_name,
					mbssid_ver.ssid,
					mbssid_ver.ssid_hide,
					mbssid_ver.auth,
					mbssid_ver.psk_type,
					mbssid_ver.psk_key,
					mbssid_ver.vlan_id,
					mbssid_ver.qos,
					mbssid_ver.mac_cmd,
					mbssid_ver.max_user);
	       		//display_mssid(mbssid_ver);
              if(serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, mbssid_ver.dev_name,NULL)<1){		
	          		save_MSSID_conf1(WLAN_CONFIG, WLAN_BEGIN,WLAN_END, mbssid_ver);
                  	ret = start_wlan_scr(ADD_FORK, &mbssid_ver);		   
		           	if(ret != 0)	{
			  	        fprintf(stderr,"write_wapiMssidAdd:  fork error \n");
				        tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, mbssid_ver.dev_name,NULL);		
				        del_MSSID_conf(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, tmp);
				        return SNMP_ERR_NOCREATION_SSID;
		           	}
	                 //sleep(2);
		           	ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);

              }
          break;
	error:
	 	fprintf(stderr,"write to wapiPwlanAp: mssid  wapi-psk or vlanid  parameter  error \n");
	 	memset(&mbssid_ver,0,sizeof(struct  wlan_info_t ));
	 	return  SNMP_ERR_NOCREATION_SSID;
			break;
       case UNDO:
          	break;
        case COMMIT:
          	break;
    }
    return SNMP_ERR_NOERROR;
 
}

int
write_wapiVlanOnOff(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value,i=0,ret=0,tmp=0;
    int size;
    char temp[10];
    char user_info[1024]="";
    char ap_parameter[256];
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    struct wlan_info_t  mssid_array[MSSID_NUMBER],*wsip;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          value = * (long *) var_val;
          if (value<0 ||  value >1 ) {
              fprintf(stderr,"write to wapiPwlanAp: date error \n");
              return SNMP_ERR_WRONGLENGTH;
          }	  
	   
          break;
        case RESERVE2:

          break;
        case FREE:
          break;

        case ACTION:		  
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
            get_prop("VLAN",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
            tmp=atoi(ap_parameter);
	     value = * (long *) var_val;
            if ( value != tmp )	{
	         tmp=count_mssib(WLAN_CONFIG, WLAN_BEGIN, WLAN_END);
     	         if(tmp>0){
                    memset(mssid_array,0,sizeof(mssid_array));
                    wsip=mssid_array;
                    for(i=0;i<tmp;i++,wsip++){  
                        index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, 1, wsip);
                        del_MSSID_conf(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, 1);		
                        bzero(user_info, 1024);
                           sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
                        	wsip->dev_name,
                        	wsip->ssid,
                        	wsip->ssid_hide,
                        	wsip->auth,
                        	wsip->psk_type,
                        	wsip->psk_key,
                        	wsip->vlan_id,
                        	wsip->qos,
                        	wsip->mac_cmd,
                        	wsip->max_user);
                    
                         ret = start_wlan_scr(DEL_FORK, wsip);
#if 0
                         if(ret != 0)	{
                 	       fprintf(stderr,"write_wapiVlanOnOff:  fork error \n");
                               save_MSSID_conf1(WLAN_CONFIG, WLAN_BEGIN,WLAN_END, *wsip);
                               return SNMP_ERR_NOCREATION;
                         }
#endif
                          ret = inform_wapid(CGI_CMD_DEL_DEV, user_info,strlen(user_info)+1);
                          //display_mssid(*wsip);
#if 0
                             if (ret==-1) {
                                     fprintf(stderr,"write_wapiVlanOnOff: wapi del error \n");
                             save_MSSID_conf(WLAN_CONFIG, WLAN_BEGIN,WLAN_END, user_info);
                             return SNMP_ERR_NOCREATION;
                                 }
#endif
                     }
	
                } 	
                bzero(temp, 10);
                sprintf(temp,"%ld",*(unsigned long *) var_val);
                save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","VLAN",temp);
           }
           break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


/*
 * var_wapiMssidTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wapiPwlanAp above.
 */
unsigned char *
var_wapiMssidTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
 printf("length=%d \t exact=%d\t var_len=%d\n",*length,exact,*var_len);
#ifdef  DEBUG_PWLAN  
    char buf[200];  
    bzero(buf, 200);
    sprint_mib_oid(buf, name, *length);
    printf("read wapiMssidTable %s \n",buf);        
#endif 
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    struct  wlan_info_t *wlan_list;
    int tableSize=0,i=0,mode=0;
    static char ap_parameter[256];
	int id;
    static struct  wlan_info_t  wlantable[MSSID_NUMBER],*wlp,*wtp;
    tableSize=get_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, &wlan_list); 	
    bzero(wlantable,sizeof(wlantable));
    wlp=wlan_list;
    wtp=wlantable;
    while(wlp!=NULL){   
    	memcpy(wtp,wlp,sizeof(struct wlan_info_t));
    	wlp=wlp->next;
   		wtp++;
    }
    free_wlan_table(& wlan_list);
    wlan_list=wlantable;
    
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tableSize)
                                                == MATCH_FAILED ){
    	return NULL;
    }
	id = (name[*length - 1]<2)?1:name[*length - 1];	
	if (name[*length - 1] > tableSize)
    {       
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- no match: %lu\n",name[*length - 1]));
        return NULL;
    }
	
    for (i = 1;  i < name[*length - 1]; i++)
    {
       
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- %lu != %lu\n",i, name[*length - 1]));

	 		wlan_list++;
    }
   
    switch(vp->magic) {
    case WAPIMSSIDIFINDEX:
        ulong_ret =i;	
        return (u_char*) &ulong_ret;
    case WAPIMSSIDDEVNAME:
	 bzero(ap_parameter, 256);
        strcpy(ap_parameter,wlan_list->dev_name);
	*var_len=strlen(ap_parameter);
        return (u_char*) &ap_parameter;

    case WAPIMSSIDWLANSSID:
        *write_method = write_wapiMssidWlanSSID;
	 bzero(ap_parameter, 256);
        strcpy(ap_parameter,wlan_list->ssid);	
	*var_len=strlen(ap_parameter);
        return (u_char*) &ap_parameter;

    case WAPIMSSIDHIDESSID:
        *write_method = write_wapiMssidHideSSID;
	 bzero(ap_parameter, 256);
        strcpy(ap_parameter,wlan_list->ssid_hide);	
        ulong_ret=atoi(ap_parameter);
        return (u_char*) &ulong_ret;
    case WAPIMSSIDWAPI:
        *write_method = write_wapiMssidWAPI;
        bzero(ap_parameter, 256);
        strcpy(ap_parameter,wlan_list->auth);	
        ulong_ret = atoi(ap_parameter);	
        return (u_char*) &ulong_ret;
    case WAPIMSSIDPSKTYPE:
        *write_method = write_wapiMssidPskType;
        bzero(ap_parameter, 256);
        strcpy(ap_parameter,wlan_list->psk_type);
	 if(ap_parameter[0]=='N')
	 	ulong_ret=0;
        else 
		ulong_ret = atoi(ap_parameter)+1;	
        return (u_char*) &ulong_ret;
    case WAPIMSSIDPSK:
        *write_method = write_wapiMssidPsk;
        bzero(ap_parameter, 256);
        strcpy(ap_parameter,wlan_list->psk_key);
	*var_len=strlen(ap_parameter);
        return (u_char*) &ap_parameter;
    case WAPIMSSIDVLANID:
        *write_method = write_wapiMssidVlanID;
        bzero(ap_parameter, 256);
        strcpy(ap_parameter,wlan_list->qos);	
        ulong_ret = atoi(ap_parameter);	
        return (u_char*) &ulong_ret;
    case WAPIMSSIDQOS:
        *write_method = write_wapiMssidQos;
        bzero(ap_parameter, 256);
        strcpy(ap_parameter,wlan_list->vlan_id);	//modify by sys   change  qos & vlan_id
        ulong_ret = atoi(ap_parameter);	
        return (u_char*) &ulong_ret;
    case WAPIMSSIDMACPOLICY:
        *write_method = write_wapiMssidMacPolicy;
        bzero(ap_parameter, 256);
        strcpy(ap_parameter,wlan_list->mac_cmd);	
        ulong_ret = atoi(ap_parameter);	
        return (u_char*) &ulong_ret;
    case WAPIMSSIDMAXUSER:
        *write_method = write_wapiMssidMaxUser;
		
	 printf("dev_name:%s\n",wlan_list->dev_name);
	 printf("ssid:%s\n",wlan_list->ssid);
	 printf("ssid_hide:%s\n",wlan_list->ssid_hide);
	 printf("auth:%s\n",wlan_list->auth);
	 printf("psk_type:%s\n",wlan_list->psk_type);
	 printf("psk_key:%s\n",wlan_list->psk_key);
	 printf("qos:%s\n",wlan_list->qos);
	 printf("vlan_id:%s\n",wlan_list->vlan_id);
	 printf("mac_cmd:%s\n",wlan_list->mac_cmd);
	 printf("max_user:%s\n",wlan_list->max_user);
	 
        bzero(ap_parameter, 256);
	strcpy(ap_parameter,wlan_list->mac_cmd);	
        ulong_ret = atoi(ap_parameter);	
        return (u_char*) &ulong_ret;
		
	case WAPIMSSIDMAXTRAFFIC:
        *write_method = write_apMaxSimultTraffic;	
       	memset(ap_parameter,0,256);
	sprintf(ap_parameter,"%d",temp_apMaxSimultTraffic[id]);
        long_ret = atoi(ap_parameter);
        return (u_char*) &long_ret;

    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_wapiMssidWlanSSID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{   
    char value;
    int size;
    char ap_parameter[256];
    int ret=0,tmp=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10];
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;    
    prop_data properties[KEYS_MAX];
    int prop_count=0;
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
    
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	   if(addDelEdit==MSSID_ADD){  //add ssid
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
       		get_prop("VLAN",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
             tmp =atoi(ap_parameter);
            if(tmp==1){
		    ret=add_valn_is_same_ssid(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, var_val);
		    if(ret==-1){
                      fprintf(stderr,"write to wapiPwlanAp: ssid error for vlanid \n");
                      return SNMP_ERR_WRONGVALUE;
		    }
		    else if (ret==1){
	               memcpy(ap_parameter,var_val,var_val_len);
	               ap_parameter[var_val_len]='\0';
                   strcpy(mbssid_ver.ssid,ap_parameter);
                  }
		    else { ; }
	       }
	       else if (tmp==0){
	           memcpy(ap_parameter,var_val,var_val_len);
	           ap_parameter[var_val_len]='\0';
                  strcpy(mbssid_ver.ssid,ap_parameter);
	       }
		else  { ; }
	   }
	   else{ //edit ssid

	      ret=(int)name[name_len-1];
	      bzero(&wlan_scr_info, sizeof(struct wlan_info_t));
	      tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	      if(tmp==0){
              fprintf(stderr,"write to wapiMssidWlanSSID: not config wlan \n");
              return SNMP_ERR_NOCREATION;
	      } 
	      display_mssid(wlan_scr_info);
	      bzero(wlanName, 10);
	      strcpy(wlanName,wlan_scr_info.dev_name);

	      bzero(strTemp, 32);
          memcpy(strTemp, var_val, var_val_len);
	      strTemp[var_val_len] = '\0';
		  
	      bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	      tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	      if (tmp=0)
	  	   return SNMP_ERR_BADVALUE;	  	
	      memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
	  
	      modfiyCount=ret;
	      memset(wlan_scr_info.ssid,0,64);
	      memcpy(wlan_scr_info.ssid,strTemp,strlen(strTemp));
	      display_mssid(wlan_scr_info);
	      set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);
          sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
             ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	      if(ret != 0)	{
	  	   fprintf(stderr,"write_wapiMssidWlanSSID:  fork error \n");		
		   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		   return SNMP_ERR_NOCREATION;
	      }
	      ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);

	   }
          
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiMssidHideSSID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char ap_parameter[265];
    int ret=0,tmp=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10];
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;   

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   value = * (long *) var_val;
	   if (value<0 || value>1 ) { 
              fprintf(stderr,"write to wapiPwlanAp: date error \n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	   if(addDelEdit==MSSID_ADD){
	   	sprintf(ap_parameter,"%d",( * (long *) var_val));
	   	strcpy(mbssid_ver.ssid_hide,ap_parameter);	   
	   }
	   else{
	      ret=(int)name[name_len-1];
	      tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);	
	      if(tmp==0){
                 fprintf(stderr,"write to wapiMssidWlanSSID: not config wlan \n");
                 return SNMP_ERR_NOCREATION;
	      }
	      bzero(wlanName, 10);
	      strcpy(wlanName,wlan_scr_info.dev_name);

	      bzero(strTemp, 32);
             sprintf(strTemp,"%d",( * (long *) var_val));
			 
	      bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	      tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	      if (tmp=0)
	  	   return SNMP_ERR_BADVALUE;	  	
	      memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
	  
	      modfiyCount=ret;
	      memset(wlan_scr_info.ssid_hide,0,64);
	      memcpy(wlan_scr_info.ssid_hide,strTemp,strlen(strTemp));
	      set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);
          sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
          ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	      if(ret != 0)	{
	  	   fprintf(stderr,"write_wapiMssidHideSSID:  fork error \n");		
		   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		   return SNMP_ERR_NOCREATION;
	      }
	      ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);

	      
	   }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiMssidWAPI(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char ap_parameter[265];
    int ret=0,tmp=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10];
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;   
  
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
 	   value = * (long *) var_val;
 	   if( !(value==0 || value==7 || value==11) ){  
              fprintf(stderr,"write to wapiPwlanAp: date error \n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	   if(addDelEdit==MSSID_ADD){
	       sprintf(ap_parameter,"%d",( * (long *) var_val));
	       strcpy(mbssid_ver.auth,ap_parameter);
	   }
	   else {
	      ret=(int)name[name_len-1];
	      value = * (long *) var_val;
	      tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	      if(tmp==0){
                 fprintf(stderr,"write to wapiMssidWlanSSID: not config wlan \n");
                 return SNMP_ERR_NOCREATION;
	      }
	      bzero(wlanName, 10);
	      strcpy(wlanName,wlan_scr_info.dev_name);
		  
	      bzero(strTemp, 32);
          sprintf(strTemp,"%d",( * (long *) var_val));
		  
	      bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	      tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	      if (tmp=0)
	  	   return SNMP_ERR_BADVALUE;	  	
	      memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	            
             tmp=atoi(wlan_scr_info.auth);
	      if(value==tmp) 
		  	return SNMP_ERR_NOERROR;
		  
	      if(tmp==0) {
	          if(value=7) {
		       memset(wlan_scr_info.psk_type,0,sizeof(wlan_scr_info.psk_type));
				memset(wlan_scr_info.psk_key,0,sizeof(wlan_scr_info.psk_key));
				strcpy(wlan_scr_info.psk_type,"0");
				strcpy(wlan_scr_info.psk_key,"123456");
		   }
		   else {}
	      }
	      else if (tmp==7) {
	          if(value!=7){
		       memset(wlan_scr_info.psk_type,0,sizeof(wlan_scr_info.psk_type));
				memset(wlan_scr_info.psk_key,0,sizeof(wlan_scr_info.psk_key));
				strcpy(wlan_scr_info.psk_type,"N/A");
				strcpy(wlan_scr_info.psk_key,"N/A");
	          }
		   else {}
	      }
	      else if (tmp==11) {
	          if(value==7)  {
		       memset(wlan_scr_info.psk_type,0,sizeof(wlan_scr_info.psk_type));
				memset(wlan_scr_info.psk_key,0,sizeof(wlan_scr_info.psk_key));
				strcpy(wlan_scr_info.psk_type,"0");
				strcpy(wlan_scr_info.psk_key,"123456");
		   }
		   else {}
	      }
	      else 
		  	return SNMP_ERR_WRONGLENGTH;
	  
	      modfiyCount=ret;
	      memset(wlan_scr_info.auth,0,64);
	      memcpy(wlan_scr_info.auth,strTemp,strlen(strTemp));		  
	      set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);
           sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
             ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	      if(ret != 0)	{
	  	   fprintf(stderr,"write_wapiMssidWAPI:  fork error \n");		
		   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		   return SNMP_ERR_NOCREATION;
	      }
	      ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);
	   }
          break;
        case UNDO:           
          break;
        case COMMIT:      
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiMssidPskType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char ap_parameter[265];
    int ret=0,tmp=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10];
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;   

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   value = * (long *) var_val;
	   if (value<0 || value>2 ) {
              fprintf(stderr,"write to wapiPwlanAp: date error \n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	   if(addDelEdit==MSSID_ADD){
	       value = * (long *) var_val;		
	       if( value==0 )
	   	    strcpy(ap_parameter,"N/A");
	       else 
	   	    sprintf(ap_parameter,"%d", (value-1));
	       strcpy(mbssid_ver.psk_type,ap_parameter);
	   }
	   else{
	      ret=(int)name[name_len-1];
	      tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	      if(tmp==0){
                 fprintf(stderr,"write to wapiMssidWlanSSID: not config ath \n");
                 return SNMP_ERR_NOCREATION;
	      }
	      bzero(wlanName, 10);
	      strcpy(wlanName,wlan_scr_info.dev_name);	   
	        
	      bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	      tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	      if (tmp=0)
	  	   return SNMP_ERR_BADVALUE;	  	
	      memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
             
	      tmp=atoi(wlan_scr_info.auth);
			 
	      bzero(strTemp, 32);
	      value = * (long *) var_val;
	      if(tmp!=7){  // open or wapi
	          if(value==0){
		   	strcpy(strTemp,"N/A"); 
			goto right;
	          }
		   else {
                     goto error;
		   }
             }
	      else {  //psk
                  if(value==1 || value==2 ){
		        sprintf(strTemp,"%d", (value-1));
			 goto right;
                  }
		    else
			 goto error;
	      }
right:
          modfiyCount=ret;
	   memset(wlan_scr_info.psk_type,0,sizeof(wlan_scr_info.psk_type));
	   memcpy(wlan_scr_info.psk_type,strTemp,strlen(strTemp));
	   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);
          
              sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
          ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	   if(ret != 0)	{
	         fprintf(stderr,"write_wapiMssidPskType:  fork error \n");		
	       set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
	       return SNMP_ERR_NOCREATION;
	   }
	    ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);


	   }
error:
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiMssidPsk(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{    
    int size,i=0,value;
    char ap_parameter[265];
    int ret=0,tmp=0,var=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10];
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;   
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 16*sizeof(char)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          if(addDelEdit==MSSID_ADD){
		if(var_val_len==0){
		    strcpy(mbssid_ver.psk_key,"N/A");
		}
		else {
		    memcpy(ap_parameter,var_val,var_val_len);
	   	    ap_parameter[var_val_len]='\0';
		    tmp=atoi(mbssid_ver.psk_type);
		    if (tmp==1){
		       if (var_val_len %2!=0) {
                         fprintf(stderr,"write to wapiPwlanAp: bad length .\n");
                         return SNMP_ERR_WRONGLENGTH;
                     }
			for(i=0;i<var_val_len;i++) { //whether hex number
				 if(ap_parameter[i]>='0' && ap_parameter[i] <='9' )  continue ;
				 else if  (ap_parameter[i]>='a' && ap_parameter[i] <='f' )   continue ;
				 else if  (ap_parameter[i]>='A' && ap_parameter[i] <='F' )  continue ;
				 else {
				     fprintf(stderr,"write to write_wapiMssidPsk: auth value  not  hex number \n");
				     return SNMP_ERR_WRONGVALUE;					     
				 }
			}
		    }	  
          	    strcpy(mbssid_ver.psk_key,ap_parameter);
		}
          }
	   else{  //edit
	      ret=(int)name[name_len-1];
	      tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	      if(tmp==0){
                 fprintf(stderr,"write to wapiMssidWlanSSID: not config ath \n");
                 return SNMP_ERR_NOCREATION;
	      }
	      bzero(wlanName, 10);
	      strcpy(wlanName,wlan_scr_info.dev_name);		 
	  
	      bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	      tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	      if (tmp=0)
	  	   return SNMP_ERR_BADVALUE;	  	
	      memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
             
	       tmp=atoi(wlan_scr_info.auth);
		bzero(strTemp, 32);		
              if(tmp!=7){  // open or wapi
                  if(var_val_len==0)
                      strcpy(strTemp,"N/A");	
		    else 
		        goto error;
	       }
		else { // psk
		    memcpy(strTemp,var_val,var_val_len);
	   	    strTemp[var_val_len]='\0';
                  var=atoi(wlan_scr_info.psk_type);				  
		     if(var==0){ // ascII
			  goto right;
		     }
		     else if (var==1){ 
		         for(i=0;i<var_val_len;i++) { //whether hex number
				 if(strTemp[i]>='0' && strTemp[i] <='9' )  continue ;
				 else if  (strTemp[i]>='a' && strTemp[i] <='f' )   continue ;
				 else if  (strTemp[i]>='A' && strTemp[i] <='F' )  continue ;
				 else {
				     fprintf(stderr,"write to write_wapiMssidPsk: auth value  not  hex number \n");
				     return SNMP_ERR_WRONGVALUE;					     
				 }
			  }	
			  goto right;				 	
		     }
		     else {
		         goto error;
		     }
		}

right:		
	      modfiyCount=ret;
	      memset(wlan_scr_info.psk_key,0,64);
	      memcpy(wlan_scr_info.psk_key,strTemp,strlen(strTemp));
	      set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);
          sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
             ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	      if(ret != 0)	{
	  	   fprintf(stderr,"write_wapiMssidPsk:  fork error \n");		
		   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		   return SNMP_ERR_NOCREATION;
	      }
	      ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);
	 
	   }
error:	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:

          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wapiMssidVlanID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char ap_parameter[265];
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    int ret=0,tmp=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10];
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;   
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          value = * (long *) var_val;
	   	  if (value<0 || value>4096 ) {
              fprintf(stderr,"write to wapiPwlanAp: date error \n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          if(addDelEdit==MSSID_ADD){
            memset(ap_parameter,0,256);
            prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
       		get_prop("VLAN",ap_parameter,properties,prop_count);
            free_prop(properties,prop_count) ;
            tmp =atoi(ap_parameter);
            if(tmp==1){
		    ret=add_valn_is_same_vlanid(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ( * (long *) var_val));
		    if(ret==-1){
                      fprintf(stderr,"write to wapiPwlanAp: vlan id error \n");
                      return SNMP_ERR_WRONGVALUE;
		    }
		    else if (ret==1){
		        memset(ap_parameter,0,256);
	   	        sprintf(ap_parameter,"%d",( * (long *) var_val));
	   	        strcpy(mbssid_ver.vlan_id,ap_parameter);
                  }
		    else { ; }
	       }
	       else if (tmp==0){
        	    strcpy(mbssid_ver.vlan_id,"0");
	       }
			else  { ; }
	       
          }
	   else { //edit
#if 0
	      ret=(int)name[name_len-1];
	      tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	      if(tmp==0){
                 fprintf(stderr,"write to wapiMssidWlanSSID: not config wlan \n");
                 return SNMP_ERR_NOCREATION;
	      }
	      bzero(wlanName, 10);
	      strcpy(wlanName,wlan_scr_info.dev_name);

	      bzero(strTemp, 32);
	      sprintf(strTemp,"%d",( * (long *) var_val));
		  
	      bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	      tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	      if (tmp=0)
	  	   return SNMP_ERR_BADVALUE;	  	
	      memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
             //printf("devname=%s\n",wlan_scr_info.dev_name);
	  
	      modfiyCount=ret;
	      memset(wlan_scr_info.vlan_id,0,64);
	      memcpy(wlan_scr_info.vlan_id,strTemp,strlen(strTemp));
	      set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);
             /////////////////////////////
             sprintf(user_info, "%-15.10s%-33.32s%-10.18s%-10.8s%-10.8s%-8.6s%-8.6s%-8.6s%-8.6s%-8.6s", 
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
             ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	      if(ret != 0)	{
	  	   fprintf(stderr,"write_wapiMssidVlanID:  fork error \n");		
		   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		   return SNMP_ERR_NOCREATION;
	      }
	      ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);

	      if (ret==-1) {
                 fprintf(stderr,"write_wapiMssidVlanID: wapi creat error \n");
		   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
                 return SNMP_ERR_NOCREATION;
             }
#endif
	      /////////////////////////////
	   }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
   
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiMssidQos(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char ap_parameter[265];
    int ret=0,tmp=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10];
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;   
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   value = * (long *) var_val;
	   if (value<0 || value>1 ) {
              fprintf(stderr,"write to wapiPwlanAp: date error \n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	   if(addDelEdit==MSSID_ADD){
	   	sprintf(ap_parameter,"%d",( * (long *) var_val));
	   	strcpy(mbssid_ver.qos,ap_parameter);
	   }
	   else {
	      ret=(int)name[name_len-1];
	      tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	      if(tmp==0){
                 fprintf(stderr,"write to wapiMssidWlanSSID: not config ath\n");
                 return SNMP_ERR_NOCREATION;
	      }
	      bzero(wlanName, 10);
	      strcpy(wlanName,wlan_scr_info.dev_name);

	      bzero(strTemp, 32);
             sprintf(strTemp,"%d",( * (long *) var_val));
		  
	      bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	      tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	      if (tmp=0)
	  	   return SNMP_ERR_BADVALUE;	  	
	      memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
	  
	      modfiyCount=ret;
	      memset(wlan_scr_info.qos,0,64);
	      memcpy(wlan_scr_info.qos,strTemp,strlen(strTemp));
	      set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);

                sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
             ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	      if(ret != 0)	{
	  	   fprintf(stderr,"write_wapiMssidQos:  fork error \n");		
		   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		   return SNMP_ERR_NOCREATION;
	      }
	      ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);
	   }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiMssidMacPolicy(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char ap_parameter[265];
    int ret=0,tmp=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10];
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;   
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   value = * (long *) var_val;
	   if (value<0 || value>2) {
              fprintf(stderr,"write to wapiPwlanAp: date error \n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	   if(addDelEdit==MSSID_ADD){
	       sprintf(ap_parameter,"%d",( * (long *) var_val));
	       strcpy(mbssid_ver.mac_cmd,ap_parameter);
	   }
	   else {
	      ret=(int)name[name_len-1];
	      tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	      if(tmp==0){
                 fprintf(stderr,"write to wapiMssidWlanSSID: not config ath \n");
                 return SNMP_ERR_NOCREATION;
	      }
	      bzero(wlanName, 10);
	      strcpy(wlanName,wlan_scr_info.dev_name);

	      bzero(strTemp, 32);
             sprintf(strTemp,"%d",( * (long *) var_val));
		  
	      bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	      tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	      if (tmp=0)
	  	   return SNMP_ERR_BADVALUE;	  	
	      memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
	  
	      modfiyCount=ret;
	      memset(wlan_scr_info.mac_cmd,0,64);
	      memcpy(wlan_scr_info.mac_cmd,strTemp,strlen(strTemp));
	      set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);


                sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
             ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	      if(ret != 0)	{
	  	   fprintf(stderr,"write_wapiMssidMacPolicy:  fork error \n");		
		   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		   return SNMP_ERR_NOCREATION;
	      }
	      ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);

	   }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
     
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiMssidMaxUser(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char ap_parameter[256];
	char ap_param[256];
    int ret=0,tmp=0,existusers=0,remainUsers=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10];
    unsigned int  modfiyCount;
	prop_data properties[KEYS_MAX];
    int prop_count=0; 
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;   
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   	  value = * (long *) var_val;
	   	  if (value<1 || value>128) {
              fprintf(stderr,"write to wapiPwlanAp: date error \n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;
        case FREE:
          break;

        case ACTION:
	   if(addDelEdit==MSSID_ADD){
	   	sprintf(ap_parameter,"%d",( * (long *) var_val));
	   	strcpy(mbssid_ver.max_user,ap_parameter);
	   }
	   else{
	     ret= (int)name[name_len-1];
	     tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	     if(tmp==0){
               fprintf(stderr,"write to wapiMssidWlanSSID: not config ath\n");
               return SNMP_ERR_NOCREATION;
	     }
	     bzero(wlanName, 10);
	     strcpy(wlanName,wlan_scr_info.dev_name);
		 get_ap_access_max_users(&existusers);
		 remainUsers = (int)(existusers-atoi(wlan_scr_info.max_user));
		 bzero(ap_param, 256);
		 prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
         get_prop("AP_MAX_LIMLT_ACCESS_USERS",ap_param,properties,prop_count);
         free_prop(properties,prop_count);
		 printf("ap_param=%d\n",atoi(ap_param));
		 if((* (long *) var_val) >(atoi(ap_param)-remainUsers)){
			fprintf(stderr,"write to wapiPwlanAp: err user number,not user add\n");
            return SNMP_ERR_WRONGVALUE;
		 }else{
			bzero(strTemp, 10);
			sprintf(strTemp,"%d",(* (long *) var_val));
			printf("strTemp=%s\n",strTemp);
		 }
	      bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	      tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	      if (tmp=0)
	  	   return SNMP_ERR_BADVALUE;	  	
	      memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
	  
	      modfiyCount=ret;
	      memset(wlan_scr_info.max_user,0,64);
	      memcpy(wlan_scr_info.max_user,strTemp,strlen(strTemp));
	      set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);

          sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
						wlan_scr_info.dev_name,
						wlan_scr_info.ssid,
						wlan_scr_info.ssid_hide,
						wlan_scr_info.auth,
						wlan_scr_info.psk_type,
						wlan_scr_info.psk_key,
						wlan_scr_info.vlan_id,
						wlan_scr_info.qos,
						wlan_scr_info.mac_cmd,
						wlan_scr_info.max_user);
		 
          ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	      if(ret != 0)	{
	  	   fprintf(stderr,"write_wapiMssidMaxUser:  fork error \n");		
		   set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		   return SNMP_ERR_NOCREATION;
	      }
	     
	      ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);
	   }
	  break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


unsigned char *
var_wapiAPESSIDTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static unsigned  long  long_ret;
    static  int  int_ret;
    static unsigned  long  ulong_ret;
	prop_data properties[KEYS_MAX];
    int prop_count=0,id;
	static char ap_parameter[256];
	char indextmp[20],tmp[10];
	int mode=0;
    int tableSize=1,i =0,temp;
    struct wlan_info_t  *wlan_list ;
    static struct  wlan_info_t  wlantable[MSSID_NUMBER],*wlp,*wtp;
	
	char ifname[IFNAME_MAX],*p;
	char ifwlan[256],ifawlan[256],*ifa,*ifw;
	int j;

	memset(ifwlan,0,256);
	memset(ifawlan,0,256);
	
	
	//modify by piyp 2008-11-24
	mode=get_ap_work_mode();
	printf("mode==========%d\n\n",mode);
	
	if(mode==1){
		tableSize=get_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, &wlan_list); 
	}else if(mode==2){
		tableSize=get_wlan_table(WLAN_11ITEMP_CONFIG, WLAN_BEGIN, WLAN_END, &wlan_list); 
	}
	
    bzero(wlantable,sizeof(wlantable));
    wlp=wlan_list;
    wtp=wlantable;
    while(wlp!=NULL){   
    	memcpy(wtp,wlp,sizeof(struct wlan_info_t));
    	wlp=wlp->next;
   		wtp++;
	
    }
    free_wlan_table(& wlan_list);
    wlan_list=wlantable;

	// add by piyp 2008-11-24
	id = (name[*length - 1]<2)?1:name[*length - 1];	
	/*ljy--test start*/
	printf("%s: test. *length %d, name ", __func__, *length);
	for (j = 0; j < *length; j++)
	{
		printf("%d.", name[j]);
	}
	printf("\n");
	/*ljy--test end*/
	int ifnum=iw_enum_wlan_interface( ifname );
	p = ifname;
	ifw = ifwlan;
	ifa = ifawlan;
  	memcpy(ifwlan,p,IFNAME_LEN);
	ifw= ifw + IFNAME_LEN;
	printf("ifwlan=%s\n", ifwlan);
	p=p+IFNAME_LEN;
	memcpy(ifawlan,p,IFNAME_LEN);
	ifa= ifa + IFNAME_LEN;
	printf("ifawlan=%s\n", ifawlan);
	p=p+IFNAME_LEN;	
	if (header_simple_table(vp,name,length,exact,var_len,write_method, tableSize)
                                                == MATCH_FAILED )
    {
    	/*ljy--test start*/
		printf("%s: test 1. exact %d, *length %d, name[*length - 1] %d, vp->namelen %d.\n", __func__, exact, *length, name[*length - 1], vp->namelen);
		/*ljy--test end*/
    	return NULL;
    }
	if (name[*length - 1] > tableSize)
    {       
    	/*ljy--test start*/
		printf("%s: test 2.\n", __func__);
		/*ljy--test end*/
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- no match: %lu\n",name[*length - 1]));
        return NULL;
    }
	
    for (i = 1; i < name[*length - 1] ; wlan_list++,i++)
    {
    	memcpy(ifwlan,p,IFNAME_LEN);
		ifw= ifw + IFNAME_LEN;
		printf("ifwlan=%s\n", ifwlan);
		p=p+IFNAME_LEN;
		memcpy(ifawlan,p,IFNAME_LEN);
		ifa= ifa + IFNAME_LEN;
		printf("ifawlan=%s\n", ifawlan);
		p=p+IFNAME_LEN;	
 				 
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- %lu != %lu\n",i, name[*length - 1]));
    }
   

	/*ljy--test start*/
	printf("%s: test 3. vp->magic %d.\n", __func__, vp->magic);
	/*ljy--test end*/
    switch(vp->magic) {
    case WAPIESSIDIFINDEX:
		int_ret=i;
        return (u_char*) &int_ret;
    case WAPIDEVNAMEBG:
		bzero(ap_parameter, 256);	
        memcpy(ap_parameter,ifwlan,IFNAME_LEN);
	    printf("ifw=%s\n", ifwlan);	
		*var_len=strlen(ap_parameter);
        return (u_char*) ap_parameter;
    case APCONFIGBSSIDBG:
        memset(ap_parameter,0,256);
		long_ret=wlan_getioctl_dev_addr(ap_parameter,ifwlan);
        if( long_ret !=1 )
        	printf(" get Mac error .\n");
        *var_len = 6;
         return (u_char*) ap_parameter ;
	//modify piyp 2008-12-25
	case WAPIDEVNAMEA:
		bzero(ap_parameter, 256);
        memcpy(ap_parameter,ifawlan,IFNAME_LEN);
	 	*var_len=strlen(ap_parameter);
        return (u_char*) ap_parameter;
	case APCONFIGBSSIDA:
        memset(ap_parameter,0,256);
		long_ret=wlan_getioctl_dev_addr(ap_parameter,ifawlan);
		if( long_ret !=1 ){
        	printf(" get Mac error .\n");
        }
        *var_len = 6;
         return (u_char*) ap_parameter ;
    case APDOT11DESIREDSSID:
        *write_method = write_apdot11DesiredSSID;   
	 	*var_len=strlen(wlan_list->ssid);
	 	memset(ap_parameter,0,256);
	 	strcpy(ap_parameter,wlan_list->ssid);	
        return (u_char*) ap_parameter;
    case APMAXSIMULTUSERS:
        *write_method = write_wapiapMaxSimultUsers;    
		long_ret=atoi(wlan_list->max_user);	
        return (u_char*) &long_ret;
    case APMAXSIMULTTRAFFIC:
        *write_method = write_apMaxSimultTraffic;	
		memset(ap_parameter,0,256);
		sprintf(ap_parameter,"%d",temp_apMaxSimultTraffic[id]);
        long_ret = atoi(ap_parameter);
        return (u_char*) &long_ret;
    case APBSSIDENCRYPTION:
        *write_method = write_apBSSIDEncryption;
        long_ret=atoi(wlan_list->auth);
#if 0
	 if(temp==0)	
	 	long_ret=1;
	 else if (temp==7)
	 	long_ret=2;
	 else if (temp==11)
	 	long_ret=3;
	 else
	 	long_ret=0
#endif
        return (u_char*) &long_ret;

    default:
      ERROR_MSG("");
    }

    return NULL;
}

// add by piyp 2008-11-24
int 
get_ap_work_mode(){
	prop_data properties[KEYS_MAX];
    int prop_count=0,mode=0;
	static char ap_parameter[256];
	memset(ap_parameter,0,256);
    prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	get_prop("PRODUCT_SEC",ap_parameter,properties,prop_count);
	free_prop(properties,prop_count);
	mode=atoi(ap_parameter);
	return mode; 
}



int
write_apdot11DesiredSSID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size,ret,tmp=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10]="ath";// by sunyushuang0320
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;
    bzero(&wlan_scr_info, sizeof(wlan_scr_info));

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  ret=(int)name[name_len-1];
	  tmp=index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	  if(tmp==0){
                 fprintf(stderr,"write to wapiMssidWlanSSID: not config ath \n");// by sunyushuang0320
                 return SNMP_ERR_NOCREATION;
	      }
	  bzero(wlanName, 10);
	  strcpy(wlanName,wlan_scr_info.dev_name);
	  
	  bzero(strTemp, 32);
         memcpy(strTemp, var_val, var_val_len);
	  strTemp[var_val_len] = '\0';	 
	  
	  tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	  if (tmp=0)
	  	return SNMP_ERR_BADVALUE;	  	
	  memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
 
	  modfiyCount=ret;
	  memset(wlan_scr_info.ssid,0,64);
	  memcpy(wlan_scr_info.ssid,strTemp,strlen(strTemp));
	  set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);


         sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
         ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	  if(ret != 0)	{
	  	fprintf(stderr,"write_apdot11DesiredSSID:  fork error \n");		
		set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		return SNMP_ERR_NOCREATION;
	  }
	  ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);

	
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiapMaxSimultUsers(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size,ret,tmp=0,mode=0,remainUsers;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10]="ath";// by sunyushuang0320
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;
	struct  wlan_info_t *wlan_list;
	int ifnums,i,existusers;
	char ap_param[256];
	prop_data properties[KEYS_MAX];
    int prop_count=0;
    bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

 #if 0
         if(( (* (long *) var_val)<1) ||((* (long *) var_val)>128)) {
              fprintf(stderr,"write to wapiPwlanAp: bad value \n");
              return SNMP_ERR_WRONGVALUE;
          }

 #endif
 
          break;
        case RESERVE2:
          break;
        case FREE:
          break;
        case ACTION:
			ret=(int)name[name_len-1];
			mode = get_ap_work_mode();
			//get auth mode
			if(mode==1){
			  	tmp =  index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
				ifnums = get_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, &wlan_list);
			}else if(mode==2){
			  	tmp =  index_read_SSID(WLAN_11ITEMP_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
				ifnums = get_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, &wlan_list);
			}
			if(tmp==0){
		        fprintf(stderr,"write to wapiMssidWlanSSID: not config ath \n");// by sunyushuang0320
		        return SNMP_ERR_NOCREATION;
			}
			bzero(wlanName, 10);
			strcpy(wlanName,wlan_scr_info.dev_name);
			//get exist users  add by piyp 2009-01-13
			 get_ap_access_max_users(&existusers);
		 	remainUsers = (int)(existusers-atoi(wlan_scr_info.max_user));
		 	bzero(ap_param, 256);
		 	prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
         	get_prop("AP_MAX_LIMLT_ACCESS_USERS",ap_param,properties,prop_count);
         	free_prop(properties,prop_count);
		 	printf("ap_param=%d\n",atoi(ap_param));
		 	if((* (long *) var_val) >(atoi(ap_param)-remainUsers)){
				fprintf(stderr,"write to wapiPwlanAp: err user number,not user add\n");
            	return SNMP_ERR_WRONGVALUE;
		 	}else{
				bzero(strTemp, 10);
				sprintf(strTemp,"%d",(* (long *) var_val));
				printf("strTemp=%s\n",strTemp);
		 	}
	  		if(mode==1){
	  		 	tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	  		}else if(mode==2){
	  		 	tmp=serch_by_name(WLAN_11ITEMP_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	  		}

	  		if (tmp=0)
	  			return SNMP_ERR_BADVALUE;	  	
	  		memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
	  
	  		modfiyCount=ret;
	  		memset(wlan_scr_info.max_user,0,64);
	  		memcpy(wlan_scr_info.max_user,strTemp,strlen(strTemp));
	  		if(mode==1){
	  			set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);
	  		}else if(mode==2){
	  			set_wlan_table(WLAN_11ITEMP_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info); 
	  		}
	 
        	sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
					wlan_scr_info.dev_name,
					wlan_scr_info.ssid,
					wlan_scr_info.ssid_hide,
					wlan_scr_info.auth,
					wlan_scr_info.psk_type,
					wlan_scr_info.psk_key,
					wlan_scr_info.vlan_id,
					wlan_scr_info.qos,
					wlan_scr_info.mac_cmd,
					wlan_scr_info.max_user);
		 
         	ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	  		if(ret != 0)	{
	  			fprintf(stderr,"write_apdot11DesiredSSID:  fork error \n");	
			 	if(mode==1){
		  			set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		  		}else if(mode==2){
		  			set_wlan_table(WLAN_11ITEMP_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		 		}
		
				return SNMP_ERR_NOCREATION;
	  		}
	 		ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);

         	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apMaxSimultTraffic(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int index;
	char temp[16];
	unsigned short level = 0, policy = 0;
	//struct vap_traffic_user tc_user;

	char vap_tc_user[64];
	char * p;
    switch ( action ) {
        case RESERVE1:
          	if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          	}
          	if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          	}
	   		value = *(long *)var_val;
	   		if (value < 1 || value > 23)
	   	return SNMP_ERR_WRONGLENGTH;
          break;
        case RESERVE2:
          break;
        case FREE:
          break;
        case ACTION:	
			memset(temp,0,16);
			memset(vap_tc_user,0,64);
			p=vap_tc_user;
			index = (int)name[name_len-1];

			sprintf( temp, "%d",*(long *) var_val);
			
			level = atoi(temp);
			policy = IEEE80211_TC_POLICY_DELAY;

			memcpy(p, &level, 2);
			p += 2;
			memcpy(p, &policy, 2);			
 
			printf("vap_tc_user %2X, %2X, %2X, %2X\n", vap_tc_user[0], vap_tc_user[1], vap_tc_user[2], vap_tc_user[3]);

			set_ioctl_traffic_param(index,vap_tc_user);
			temp_apMaxSimultTraffic[index] = *(long *)var_val;
	
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
// add by piyp 2008-12-16


// add by piyp 2008-12-16
int set_ioctl_traffic_param(int index,char *tc)
{
        int socketfd;
		struct iwreq iwr;
		int mode=0,dev_num=0,i;
    	struct wlan_info_t  *wlan_list ;
		char devif_name[10];
		char tmp[5];
		static struct  wlan_info_t  wlantable[MSSID_NUMBER],*wlp,*wtp;
		
		//get ap_mode
		mode=get_ap_work_mode();
		if(mode==1){
			dev_num=get_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, &wlan_list); 
		}else if(mode==2){
			dev_num=get_wlan_table(WLAN_11ITEMP_CONFIG, WLAN_BEGIN, WLAN_END, &wlan_list); 
		}
		memset(devif_name,0,10);
		memset(tmp,0,5);
 		memset(&iwr, 0, sizeof(iwr));
		strcpy(devif_name,"ath");// by sunyushuang0320
		sprintf(tmp,"%d",(int)(index-1));
		strcat(devif_name,tmp);
		printf("devif_name=%s\n",devif_name);
	
   		bzero(wlantable,sizeof(wlantable));
    	wlp=wlan_list;
    	wtp=wlantable;
    	while(wlp!=NULL){   
    		memcpy(wtp,wlp,sizeof(struct wlan_info_t)); 
    		wlp=wlp->next;
   			wtp++;
    	}
    	free_wlan_table(& wlan_list);
    	wlan_list=wlantable;
	
		for(i=1;i<=dev_num;i++){
			printf("wlan_list->dev_name %d =%s\n",i,wlan_list->dev_name);	
 			if(strcmp(wlan_list->dev_name,devif_name)==0){	
				/* ifname为设备名， 如WLAN0, awlan20等等 */	
       			strncpy(iwr.ifr_name, wlan_list->dev_name, IFNAMSIZ); 
				printf("wlan_list->dev_name=%s\n",wlan_list->dev_name);
 			}
			wlan_list++;
		}
		
		iwr.u.data.pointer =(caddr_t) tc;
 		iwr.u.data.length = 64;
        socketfd = socket(AF_INET, SOCK_DGRAM, 0);

		if (socketfd < 0)
        {
            printf(" socket error in set_ioctl_parameter().\n");
            return -1;
        }
       	
	    if (ioctl(socketfd, IEEE80211_IOCTL_SET_TRAFFIC, &iwr) < 0)
	    {
		    printf("ioctl error setioctl_parameter().\n");
			close(socketfd);
		    return -2;
	    }
		
        close(socketfd);
        return 1;
}


int
write_apBSSIDEncryption(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value,long_ret;
    int size,ret,tmp=0;
    char user_info[1024]="";
    char strTemp[32];
    char wlanUnit[3];
    char  wlanName[10]="ath";// by sunyushuang0320
    unsigned int  modfiyCount;
    struct wlan_info_t  wlan_scr_info,old_wlan_scr_info;
    bzero(&wlan_scr_info, sizeof(wlan_scr_info));
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   value = * (long *) var_val;
	   if(! (value==0 || value==7 || value==11)  ){
              fprintf(stderr,"write to wapiPwlanAp: bad value \n");
              return SNMP_ERR_WRONGVALUE;
          }
	   	
          break;
        case RESERVE2:
          break;
        case FREE:
          break;
        case ACTION:
	  ret=(int)name[name_len-1];
	  index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ret, &wlan_scr_info);
	  bzero(wlanName, 10);
	  strcpy(wlanName,wlan_scr_info.dev_name);

	 long_ret = * (long *) var_val; 	
	 
	  sprintf(strTemp,"%d",long_ret);
	  tmp=serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, wlanName,&wlan_scr_info); 
	  if (tmp=0)
	  	return SNMP_ERR_BADVALUE;	  	
	  memcpy(&old_wlan_scr_info,&wlan_scr_info,sizeof(struct wlan_info_t));	  
	  
	  modfiyCount=ret;
	  memset(wlan_scr_info.auth,0,sizeof(wlan_scr_info.auth));
	  memcpy(wlan_scr_info.auth,strTemp,strlen(strTemp));
	  set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, wlan_scr_info);
	  sprintf(user_info, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
		 
         ret = start_wlan_scr(EDIT_FORK, &wlan_scr_info);
	  if(ret != 0)	{
	  	fprintf(stderr,"write_apdot11DesiredSSID:  fork error \n");		
		set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, modfiyCount, old_wlan_scr_info);
		return SNMP_ERR_NOCREATION;
	  }
	  ret = inform_wapid(CGI_CMD_ADD_DEV, user_info,strlen(user_info)+1);
 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
   
          break;
    }
    return SNMP_ERR_NOERROR;
}
/*
 * var_wapiApwapiConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wapiPwlanAp above.
 */
unsigned char *
var_wapiApwapiConfigTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
#ifdef  DEBUG_PWLAN  
    char buf[200];  
    bzero(buf, 200);
    sprint_mib_oid(buf, name, *length);
    printf("read wapiApwapiConfigTable %s \n",buf);        
#endif 

    /* variables we may use later */
    static long long_ret;
    static unsigned long  ulong_ret;
    static char  ap_parameter[256];
    int i=0,j=0,temp_ret=0;
    int tableSize=0;
    static char ifname[IFNAME_MAX],tempIfname[IFNAME_MAX];
    char *ip,*tq,*iq;
	prop_data properties[KEYS_MAX];
    int prop_count=0;
    struct wlan_info_t wlaninfo;
	printf("00000000000000\n\n");
    if(iw_get_wifis()==0) return  0;
	
    bzero(ifname,IFNAME_MAX);
    bzero(tempIfname,IFNAME_MAX);
   memset(&wlaninfo,0,sizeof(wlaninfo));
   
    temp_ret=iw_enum_wlan_interface( tempIfname );
    printf("temp_ret=%d\n",temp_ret);
	
    if(temp_ret!=0){
        tq=tempIfname;
        iq=ifname;
        for(j=0,tableSize=0;j<temp_ret;tq=tq+IFNAME_LEN,j++){
          if(strstr(tq,"awlan")==NULL){
	      	strcpy(iq,tq);		
		    tableSize++; 
		   printf("iq=%s \t tableSize=%d\n",iq,tableSize);
		    iq=iq+IFNAME_LEN;		
	      }
        }
	 ip=ifname;	
    }
    else{
          tableSize=1;
	   ip=NULL; 	  
    }
	
    if (header_simple_table(vp,name,length,exact,var_len,write_method,tableSize)
                                               == MATCH_FAILED )
    return NULL; 
	
	if (name[*length - 1] > tableSize)
    {
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- no match: %lu\n",i));
        return NULL;
    }
   
    for (i = 1;  i < name[*length - 1]; i++)
    {        
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- %lu != %lu\n",i, name[*length - 1]));
	 if(temp_ret!=0){
	     ip=ip+IFNAME_LEN;
	 }
    }


    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {

    case WAPICONFIGVERSION:         /* 1. 实体支持的WAPI最高版本号 */
	if(temp_ret!=0)
    	     long_ret=1;
	else							
	     long_ret=0;
        return (u_char*) &long_ret ; 
		
		
    case WAPICONTROLLEDAUTHCONTROL:  /*  2. 实体是否启用鉴别  wlan.conf  配置文件*/
	if(temp_ret!=0){
		memset(&wlaninfo,0,sizeof(wlaninfo));
		serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ip,&wlaninfo); 
        	long_ret=atoi(wlaninfo.auth); 
		long_ret= ((long_ret>>2)& 0x0000000f) ? 1 : 0;
	}
	else{
		long_ret=0;
	}
        return (u_char*) &long_ret ;

    case WAPICONTROLLEDPORTCONTROL:   /*  3.  实体端口的控制类型  wlan.conf  配置文件*/
		
	if(temp_ret!=0){
		memset(&wlaninfo,0,sizeof(wlaninfo));
		serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ip,&wlaninfo); 
        	long_ret=atoi(wlaninfo.auth); 
		long_ret=(long_ret>>2)& 0x0000000f;
		if(long_ret==0) long_ret=1;
		else long_ret=0;
	}
	else{
		long_ret=0;
	}
        return (u_char*) &long_ret ;


		
    case WAPIOPTIONIMPLEMENTED:    /*  4.  实体是否具有WAPI功能    */
	if(temp_ret!=0)
    	  	long_ret=1; 
    	 else
		long_ret=0; 	
        return (u_char*) &long_ret ;


		
    case WAPIPREAUTHENTICATIONIMPLEMENTED:    /* 5.  实体是否支持WAPI预鉴 别*/
    	  long_ret=0; 
        return (u_char*) &long_ret ;


		
    case WAPIENABLED:     /*  6.  实体上的WAPI是否已激活   */
        //*write_method = write_wapiEnabled;
    	 if(temp_ret != 0)
    	 {
		if (wapi_is_wapi_by_devname(ip) == 1)
			long_ret = 1;
		else
			long_ret = 0;
    	 }
    	 else
		long_ret=0; 	 
        return (u_char*) &long_ret ;



		
    case WAPIPREAUTHENTICATIONENABLED:     /*  7. 实体上的WAPI预鉴别是否已激活    */
    	  long_ret=0; 
        return (u_char*) &long_ret ;


		
    case WAPICONFIGUNICASTKEYSSUPPORTED:     /* 8. WAPI实体支持的单播密钥个数  */
    	 if(temp_ret != 0)
    	 {
		if (wapi_is_wapi_by_devname(ip) == 1)
			long_ret = 5;  /* wapi keys */ 
		else
			long_ret = 0;
    	 }
    	 else
		long_ret=0; 
        return (u_char*) &long_ret ;


		
    case WAPICONFIGUNICASTREKEYMETHOD:     /*  9 .   重新建立WAPI密钥USK的机制   */
        *write_method = write_wapiConfigUnicastRekeyMethod;
    	 if (temp_ret != 0)
    	  	long_ret = wapi_read_reusk_info(WAPI_REKEY_U_POLICY); 
    	 else
		long_ret=0; 
        return (u_char*) &long_ret ;


		
    case WAPICONFIGUNICASTREKEYTIME:      /*  10.  WAPI USK需要更新的秒级定时   */
        *write_method = write_wapiConfigUnicastRekeyTime;	  
	  if (temp_ret != 0)
	    	long_ret=wapi_read_reusk_info(WAPI_REKEY_U_TIME); 
	  else
	  	long_ret=0;
        return (u_char*) &long_ret ;


		
    case WAPICONFIGUNICASTREKEYPACKETS:    /*  11.  WAPI USK需要更新的分组计数   */
        *write_method = write_wapiConfigUnicastRekeyPackets;
	  if (temp_ret != 0)
	    	long_ret=wapi_read_reusk_info(WAPI_REKEY_U_PACKET); 
	  else
	  	long_ret=0;
        return (u_char*) &long_ret ;


		
    case WAPICONFIGMULTICASTCIPHER:    /*实体必须采用的组播密码套件    */
        //*write_method = write_wapiConfigMulticastCipher;
        if(temp_ret!=0){ 
      	 	memset(ap_parameter,0,256);
    	 	strcpy(ap_parameter,"00147201");
        	*var_len = strlen(ap_parameter);
        }
	else{
		memset(ap_parameter,0,256);
		*var_len =0;
	}
        return (u_char*) ap_parameter;	


		
    case WAPICONFIGMULTICASTREKEYMETHOD:     /* 重新建立WAPI密钥MSK的机制   */
        *write_method = write_wapiConfigMulticastRekeyMethod;
    	 if(temp_ret != 0)
    	  	long_ret = wapi_read_remsk_info(WAPI_REKEY_M_POLICY); 
    	 else
		long_ret = 0; 
        return (u_char*) &long_ret ;


	 
    case WAPICONFIGMULTICASTREKEYTIME:  /* WAPI MSK需要更新的秒级定时   */
        *write_method = write_wapiConfigMulticastRekeyTime;
	 if (temp_ret != 0)
	 	long_ret = wapi_read_remsk_info(WAPI_REKEY_M_TIME);
	 else
	 	long_ret = 0;
        return (u_char*) &long_ret ;

	 
    case WAPICONFIGMULTICASTREKEYPACKETS:     /*WAPI MSK需要更新的分组计数    */
        *write_method = write_wapiConfigMulticastRekeyPackets;
         if(temp_ret != 0)
    	  	long_ret = wapi_read_remsk_info(WAPI_REKEY_M_PACKET); 
    	 else
		long_ret = 0;
        return (u_char*) &long_ret ; 

		
    case WAPICONFIGMULTICASTREKEYSTRICT: /*STA离开BSS是否发信号通知密钥MSK进行更新 */
        *write_method = write_wapiConfigMulticastRekeyStrict;
	 if (temp_ret != 0)
	 {
	 	long_ret = wapi_read_int_for_key(WLAN_CONFIG, "STA_LEAVE_REKEY_M");
		if (long_ret < 0)
			long_ret = 0;
	 }
	 else
	 {
	     	  long_ret = 0;
	 }	 
        return (u_char*) &long_ret ; 

		
    case WAPICONFIGPSKVALUE:   /*将PSK模式选为WAPI的AKM套件时的PSK值   */
        //*write_method = write_wapiConfigPSKValue;
    	  long_ret=0;
        return (u_char*) &long_ret ;

		
    case WAPICONFIGPSKPASSPHRASE:   /*将PSK模式选为WAPI的AKM套件时的PSK口令字   */
        *write_method = write_wapiConfigPSKPassPhrase;
    	  long_ret=0;
        return (u_char*) &long_ret ;

		
    case WAPICONFIGCERTIFICATEUPDATECOUNT:  	/* WAPI证书鉴别握手协议的消息重传次数  */
        *write_method = write_wapiConfigCertificateUpdateCount;
    	 if(temp_ret!=0)
    	 {
	 	long_ret = wapi_read_int_for_key(WLAN_CONFIG, WAPI_REPLAY_LIMIT_CERT_STR);
		if (long_ret < 0)
			long_ret = 3;    	 
    	 }
    	 else
		long_ret=0;
        return (u_char*) &long_ret ;

		
    case WAPICONFIGMULTICASTUPDATECOUNT:	/*WAPI组播密钥握手协议的消息重传的次数   */
        *write_method = write_wapiConfigMulticastUpdateCount;
    	 if(temp_ret!=0)
    	 {
	 	long_ret = wapi_read_int_for_key(WLAN_CONFIG, WAPI_REPLAY_LIMIT_MSK_STR);
		if (long_ret < 0)
			long_ret = 3;    	 
    	 }
    	 else
		long_ret=0;
        return (u_char*) &long_ret ;
		

		
    case WAPICONFIGUNICASTUPDATECOUNT:		/* WAPI单播密钥握手协议的消息重传的次数 */
        *write_method = write_wapiConfigUnicastUpdateCount;
    	 if(temp_ret!=0)
    	 {
	 	long_ret = wapi_read_int_for_key(WLAN_CONFIG, WAPI_REPLAY_LIMIT_USK_STR);
		if (long_ret < 0)
			long_ret = 3;    	 
    	 }
    	 else
		long_ret=0;
        return (u_char*) &long_ret ;
		

		
    case WAPICONFIGMULTICASTCIPHERSIZE:		/* 组播密钥长度的位数  */
    	 if(temp_ret!=0)
    	  	long_ret=256;
    	 else
		long_ret=0;
        return (u_char*) &long_ret ;


		
    case WAPICONFIGBKLIFETIME:		/* BK的最大生存期 */
        *write_method = write_wapiConfigBKLifetime;	
		memset(ap_parameter,0,256);
        prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
		if(get_prop("BKLIFETIME",ap_parameter,properties,prop_count)==NULL){
			save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","BKLIFETIME", "31536000");
		}
	    free_prop(properties,prop_count) ;
    	if(temp_ret != 0)
    	  	long_ret = atoi(ap_parameter); //one year 31536000
    	 else
			long_ret = 0;
        return (u_char*) &long_ret ;


		
    case WAPICONFIGBKREAUTHTHRESHOLD:		/*渡过BK生存期的百分比   */
        *write_method = write_wapiConfigBKReauthThreshold;
		memset(ap_parameter,0,256);
        prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
		if(get_prop("BKREAUTHTHRESHOLD",ap_parameter,properties,prop_count)==NULL){
			save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","BKREAUTHTHRESHOLD", "100");
		}
	    free_prop(properties,prop_count) ;
		 if(temp_ret != 0)
    	  	long_ret = atoi(ap_parameter); //70%
    	 else
			long_ret = 0;   
        return (u_char*) &long_ret ;


		
    case WAPICONFIGSATIMEOUT:		/* 安全关联建立需要的最长时间  */
     // *write_method = write_wapiConfigSATimeout;
	memset(ap_parameter,0,256);
      *write_method = write_wapiConfigSATimeout;
	prop_count=load_prop(SEP_EQUAL,AC_SNMP_CONF,properties);
      get_prop("STA_TIMEOUT",ap_parameter,properties,prop_count);
       free_prop(properties,prop_count) ;	   
        ulong_ret =atoi(ap_parameter);
        return (unsigned char *) &ulong_ret;

	 
    	 if(temp_ret!=0)
    	  	long_ret=60; 
    	 else
		long_ret=0;          
        return (u_char*) &long_ret ;


		
    case WAPIAUTHENTICATIONSUITESELECTED:	/* 最后一次协商的AKM套件  */
    	 if(temp_ret!=0){		
    	 	memset(ap_parameter,0,256);
		if (wapi_is_wapi_by_devname(ip))
		{
			if (wapi_is_cert_by_devname(ip))
	    	 		strcpy(ap_parameter,"00147201");
			else
	    	 		strcpy(ap_parameter,"00147202");
		}
        	*var_len = strlen(ap_parameter);
    	 }
	else{
       	 memset(ap_parameter,0,256);
		*var_len =0;		
	}
        return (u_char*) ap_parameter;	


		
    case WAPIUNICASTCIPHERSELECTED:		/*最后一次协商的单播密码套件   */
    	 if(temp_ret!=0){		
    	 	memset(ap_parameter,0,256);
    	 	strcpy(ap_parameter,"00147201");
        	*var_len = strlen(ap_parameter);
    	 }
	else{
       	 memset(ap_parameter,0,256);
		*var_len =0;		
	}
        return (u_char*) ap_parameter;	


		
    case WAPIMULTICASTCIPHERSELECTED:	/*最后一次协商的组播密码套件   */
    	 if(temp_ret!=0){		
    	 	memset(ap_parameter,0,256);
    	 	strcpy(ap_parameter,"00147201");
        	*var_len = strlen(ap_parameter);
    	 }
	else{
       	 memset(ap_parameter,0,256);
		*var_len =0;		
	}
        return (u_char*) ap_parameter; 	


		
    case WAPIBKIDUSED: 		/*最后一次单播密钥握手过程中所使用的BKID   */
#if 0
        memset(ap_parameter,0,256);
		ap_parameter[0]='0';
		ap_parameter[1]='\0';
	    *var_len =1;	
#else
	memset(ap_parameter, 0, sizeof(ap_parameter));

	if (temp_ret != 0)
	{
		/* judge the auth mod */
		if (wapi_is_wapi_by_devname(ip) == 1)
		{
			   unsigned char time_val_a[8];
			   unsigned char time_val_b[8];
			   unsigned char str_tmp[32];
			   unsigned char bkid[2][16];
			   unsigned char bssid[6];
			   unsigned short cmd = 0;
			   unsigned char *p;
			   int ret = 0;
			   int i = 0;
			   
			   memset(bkid, 0, sizeof(bkid));
			   memset(str_tmp, 0, sizeof(str_tmp));
			   memset(time_val_a, 0, sizeof(time_val_a));
			   memset(time_val_b, 0, sizeof(time_val_b));		   

			   /* */
			   strcpy(str_tmp, ip);
			   p = time_val_a;

			   /* double cards: a, b/g */
			   for (i = 0; i < 2; i++)
			   {			   	   
				   /* get mac bssid with device name */
	        		   ret = wlan_getioctl_dev_addr(bssid, str_tmp);
				   if (ret == 1)
				   {			   	
					   /* set cmd */
					   write_word(ap_parameter, CGI_CMD_ASUE_LAST_BKID, 2);
					   /* set bssid */
					   memcpy(ap_parameter + 4, bssid, sizeof(bssid));

					   /* get bk id */
					   ret = wapi_notify_wapid(ap_parameter, 4+sizeof(bssid), sizeof(ap_parameter) - 1);

				          /* respond ...... */
					   if (ret >= (4 + WAPI_BKID_LEN + 4))
					   {
							/* get command */
							cmd = read_word(ap_parameter, 2);
							if (cmd == CGI_ASUE_LAST_BKID_RESPONSE)
							{
								memcpy(bkid[i], ap_parameter + 4, WAPI_BKID_LEN);
								memcpy(p, ap_parameter + 4 + WAPI_BKID_LEN, 4);		
							}			   	
					   }

				   }

				   /*  */
				   memset(str_tmp, 0, sizeof(str_tmp));
				   sprintf(str_tmp, "%s%s", "awlan2", ip+4);

				   p = time_val_b;
			   
			   }

			   /* get last bkid */
			   if (memcmp(time_val_a, time_val_b, 4) >= 0)
			   {
			   	memcpy(ap_parameter, bkid[0], WAPI_BKID_LEN);
			   }
			   else
			   {
			   	memcpy(ap_parameter, bkid[1], WAPI_BKID_LEN);			   
			   }
		 }
	}
	
	*var_len = WAPI_BKID_LEN;
#endif
        return (u_char*) ap_parameter;	





    case WAPIAUTHENTICATIONSUITEREQUESTED: 		/*最后一次请求的AKM套件   */
    	 if(temp_ret!=0){		
    	 	memset(ap_parameter,0,256);
		if (wapi_is_wapi_by_devname(ip))
		{
			if (wapi_is_cert_by_devname(ip))
	    	 		strcpy(ap_parameter,"00147201");
			else
	    	 		strcpy(ap_parameter,"00147202");
		}
        	*var_len = strlen(ap_parameter);
    	 }
	else{
       	 memset(ap_parameter,0,256);
		*var_len =0;		
	}
        return (u_char*) ap_parameter; 


		
    case WAPIUNICASTCIPHERREQUESTED:	/*最后一次请求的单播密码套件   */
    	 if(temp_ret!=0){		
    	 	memset(ap_parameter,0,256);
    	 	strcpy(ap_parameter,"00147201");
        	*var_len = strlen(ap_parameter);
    	 }
	else{
       	 memset(ap_parameter,0,256);
		*var_len =0;		
	}
        return (u_char*) ap_parameter;	


		
    case WAPIGROUPCIPHERREQUESTED:		/*最后一次请求的组播密码套件   */
    	 if(temp_ret!=0){		
    	 	memset(ap_parameter,0,256);
    	 	strcpy(ap_parameter,"00147201");
        	*var_len = strlen(ap_parameter);
    	 }
	else{
       	 memset(ap_parameter,0,256);
		*var_len =0;		
	}
        return (u_char*) ap_parameter;


		
    case WAPICONFIGUNICASTCIPHER:	                 /* 所支持的单播密码套件 */
    	 if(temp_ret!=0){		
    	 	memset(ap_parameter,0,256);
    	 	strcpy(ap_parameter,"00147201");
        	*var_len = strlen(ap_parameter);
    	 }
	else{
       	 memset(ap_parameter,0,256);
		*var_len =0;		
	}
        return (u_char*) ap_parameter;


		
    case WAPICONFIGUNICASTCIPHERENABLED:	/*对象激活或禁止单播密码   */
	if(temp_ret!=0){
#if 1
		if (wapi_is_wapi_by_devname(ip) == 1)
			long_ret = 1;
		else
			long_ret = 0;
#else
		memset(&wlaninfo,0,sizeof(wlaninfo));
		serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ip,&wlaninfo); 
        	long_ret=atoi(wlaninfo.auth); 
		long_ret=(long_ret>>2)& 0x0000000f;
#endif
	}
	else{
		long_ret=0;
	}
       return (u_char*) &long_ret ;


	   
    case WAPICONFIGUNICASTCIPHERSIZE:	/*单播密钥长度的位数   */
	if(temp_ret!=0)
	      long_ret=256;
	else
		long_ret=0;
        return (u_char*) &long_ret ;


		
    case WAPICONFIGAUTHENTICATIONSUITE:		/* AKM套件  */
    	 if(temp_ret!=0){		
    	 	memset(ap_parameter,0,256);
		if (wapi_is_wapi_by_devname(ip))
		{
			if (wapi_is_cert_by_devname(ip))
	    	 		strcpy(ap_parameter,"00147201");
			else
	    	 		strcpy(ap_parameter,"00147202");
		}
        	*var_len = strlen(ap_parameter);
    	 }
	else{
       	 memset(ap_parameter,0,256);
		*var_len =0;		
	}
        return (unsigned char *) ap_parameter;


		
    case WAPICONFIGAUTHENTICATIONSUITEENABLED:		/*AKM套件是处于激活还是禁止状态   */
	if(temp_ret!=0){
#if 1
		if (wapi_is_wapi_by_devname(ip) == 1)
			long_ret = 1;
		else
			long_ret = 0;
#else
		memset(&wlaninfo,0,sizeof(wlaninfo));
		serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, ip,&wlaninfo); 
        	long_ret=atoi(wlaninfo.auth); 
		long_ret=(long_ret>>2)& 0x0000000f;
#endif
	}
	else{
		long_ret=0;
	}
       return (u_char*) &long_ret ;


	   
    case WAPIIFINDEX:	/*  */
	 if(temp_ret!=0)
        	long_ret=i;
	 else
	 	long_ret=0;
        return (u_char*) &long_ret ; 


		

    case WAPIIFNMAE:	/*  */
        if(temp_ret!=0){
     	  	memset(ap_parameter,0,256);
        	strcpy(ap_parameter,ip);
	      *var_len = strlen(ap_parameter);
        }
	 else{
	 	memset(ap_parameter,0,256);
		*var_len = 0;
	 }
       return (u_char*) ap_parameter;

	   

    case WAPIPSKTYPE:	/*  */
	 if (temp_ret != 0)
	 {
	 	int ret;
        	ret = wapi_get_psktype_by_devname(ip);
		if (ret >= 0)
			long_ret = ret;
	 }
	 else
	 {
	 	long_ret = 0;
	 }
        return (u_char*) &long_ret ;  

    default:
      ERROR_MSG("");
    }

    return NULL;
}


int
write_wapiConfigBKLifetime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
	char temp[64];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  if(( (* (long *) var_val)<300) ||((* (long *) var_val)>31536000)) {
              fprintf(stderr,"write to wapiPwlanAp: bad value \n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;
        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
			memset(temp,0,64);
			sprintf( temp, "%d",*(long *) var_val);
	  		save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","BKLIFETIME",temp);
			
		       memset(temp, 0, sizeof(temp));
		       /* set cmd */
		       write_word(temp, CGI_CMD_BK_LIFE_TIME, 2);
		       /* set value */
		       write_dword(temp, *(unsigned long *) var_val, 4);

		       /* notify the wapid */
		       wapi_notify_wapid(temp, 8, sizeof(temp) - 1);		
          break;
		  
        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wapiConfigBKReauthThreshold(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char temp[64];
   
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  if(( (* (long *) var_val)<1) ||((* (long *) var_val)>100)) {
              fprintf(stderr,"write to wapiPwlanAp: bad value \n");
              return SNMP_ERR_WRONGVALUE;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
			memset(temp,0,64);
			sprintf( temp, "%d",*(long *) var_val);
	  		save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","BKREAUTHTHRESHOLD",temp);

		       memset(temp, 0, sizeof(temp));
		       /* set cmd */
		       write_word(temp, CGI_CMD_BK_LIFE_PERCENT, 2);
		       /* set value */
		       write_dword(temp, *(unsigned long *) var_val, 4);

		       /* notify the wapid */
		       wapi_notify_wapid(temp, 8, sizeof(temp) - 1);		
			
          break;
        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



/*
 * var_wapiApWirelessTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wapiPwlanAp above.
 */
unsigned char *
var_wapiApWirelessTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
#ifdef  DEBUG_PWLAN  
    char buf[200];  
    bzero(buf, 200);
    sprint_mib_oid(buf, name, *length);
    printf("read wapiApWirelessTable %s \n",buf);        
#endif 
   
    static unsigned long long_ret;
    static unsigned long ulong_ret;
	static char ap_parameter[256];
	 prop_data properties[KEYS_MAX];
    int prop_count=0;
    int i=0,tableSize;
    time_t courTimes;
    struct ifnet wifi0,wifi1,*wp;
    char wlanDate1[2048],wlanDate2[2048];
    struct agent_snmp_ap_wireless * p;
	int ups=0,downs=0;
	
    tableSize=iw_get_wifis();
    if(tableSize==0)  return 0;
    memset(wlanDate1,0,2048);
    get_ioctl_driver( "wifi0" ,wlanDate1,1);
    memset(&wifi0,0,sizeof(wifi0));
    get_one_Interface_dates("wifi0", &wifi0) ;

    memset(wlanDate2,0,2048);
    get_ioctl_driver( "wifi1" ,wlanDate2,1);
    memset(&wifi1,0,sizeof(wifi1));
    get_one_Interface_dates("wifi1", &wifi1);
	ups = get_ioctl_param_ups("wifi0");
	downs = get_ioctl_param_downs("wifi0");
		printf("wifi0ups=%d\n",ups);
		printf("wifi0downs=%d\n",downs);
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tableSize)
                                                == MATCH_FAILED )
    {
    	return NULL;
    }

  	if (name[*length - 1] > tableSize)
    {
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- no match: %lu\n",i));
        return NULL;
    }
	// midify by piyp 2008-11-22
	//暂时更改为可读写的定值，单位为秒级，以便测试，没有和
	//无线参数统计项关联
	memset(ap_parameter,0,256);
	prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	if(get_prop("SAMPLING_TIMES_A",ap_parameter,properties,prop_count)==NULL){
			save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","SAMPLING_TIMES_A", "5");
	}
	free_prop(properties,prop_count) ;

    p=(struct agent_snmp_ap_wireless *)wlanDate1;
    wp=&wifi0;
    for (i=1;i<name[*length-1];i++,wp=&wifi1,p=(struct agent_snmp_ap_wireless *)wlanDate2 )
    {
		
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- %lu != %lu\n",i, name[*length - 1]));
		memset(ap_parameter,0,256);
		prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
		if(get_prop("SAMPLING_TIMES_B",ap_parameter,properties,prop_count)==NULL){
			save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","SAMPLING_TIMES_B", "5");
		}
		free_prop(properties,prop_count) ;
		ups = get_ioctl_param_ups("wifi1");
		downs = get_ioctl_param_downs("wifi1");
		printf("wifi1ups=%d\n",ups);
		printf("wifi1downs=%d\n",downs);
    }
  
   
    switch(vp->magic) {
    case APSNRBSSIDAVERAGESIGNALSTRENGTH:
        long_ret=p->SAW.signal_strength; 
        return (u_char*) &long_ret;
    case APSNRBSSIDSIGNALPKTS:
        long_ret=p->SAW.signaling_pack; 
        return (u_char*) &long_ret;
    case APSNRBSSIDHIGHESTRXSIGNALSTRENGTH:
        long_ret=p->SAW.signal_high_strength; 
        return (u_char*) &long_ret;
    case APSNRBSSIDLOWESTRXSIGNALSTRENGTH:
        long_ret=p->SAW.signal_low_strength; 
        return (u_char*) &long_ret;
    case APSNRBSSIDSAMPLETIME:
        *write_method = write_apSnrBSSIDSampleTime;
		// midify by piyp 2008-11-22
		long_ret = atoi(ap_parameter);
        return (unsigned char*) &long_ret;
    case WAPIAPUPLINKDATETHROUGHPUT:
	long_ret=(wp->if_obytes)/1024;
        return (u_char*) &long_ret;
    case WAPIAPDOWNLINKDATETHROUGHPUT:
        long_ret=(wp->if_ibytes)/1024; 
        return (u_char*) &long_ret;
    case WAPIAPUPLINKUPDOWNTIMES:
        long_ret=ups+downs;	
        return (u_char*) &long_ret;
    case WAPIAPDOWNLINKUPDOWNTIMES:
        long_ret=ups+downs;  
		printf("long_retdowns=%d\n",downs);
        return (u_char*) &long_ret;
    case WARPTLOCTETSINQUEUE:
        long_ret=0; 
        return (u_char*) &long_ret;
    case WARPTLPACKETSINQUEUE:
        long_ret=0; 
        return (u_char*) &long_ret;
    case WARPTLAVGDATARATE:
        long_ret=0; 
        return (u_char*) &long_ret;
    case WARPTLOUTPACKETS:
        long_ret=0; 
        return (u_char*) &long_ret;
    case WARPTLINPACKETS:
        long_ret=0; 
        return (u_char*) &long_ret;
    case UPLINKSLOTTIMEEFFAVG:
        long_ret=0; 
        return (u_char*) &long_ret;
    case WARPTLPHYDATARATE:
        long_ret=((wp->if_ibytes)+(wp->if_obytes))/1024; 
        return (u_char*) &long_ret;
    case WARPTLPHYTXDISTRIBUTION:
        long_ret=0; 
        return (u_char*) &long_ret;
    case WARPTLPHYRXDISTRIBUTION:
        long_ret=0; 
        return (u_char*) &long_ret;
    case WARPTLPHYFAILEDTRANSMISSION:
        long_ret=0; 
        return (u_char*) &long_ret;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_apSnrBSSIDSampleTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char temp[30];
	 int index;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
			memset(temp,0,30); 
			sprintf(temp,"%d", *(long *) var_val);
			index = (int)name[name_len-1];
			if(index==1){	
             	save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","SAMPLING_TIMES_A", temp);
			}else{
				save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","SAMPLING_TIMES_B", temp);
			}
          break;

        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
/*
 * var_wapiWlanUserTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wapiPwlanAp above.
 */
unsigned char *
var_wapiWlanUserTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
#ifdef  DEBUG_PWLAN  
    char buf[200];  
    bzero(buf, 200);
    sprint_mib_oid(buf, name, *length);
    printf("read wapiWlanUserTable %s \n",buf);        
#endif 
    /* variables we may use later */
    static unsigned long  long_ret;
    static unsigned long  ulong_ret;
    char ifname[IFNAME_MAX],*p,*q,*t;
    int tableSize=1,i=0,ifnum=0,j,wifinum=0,m=0;
    int date[20];
    static char maclist[2048],tempmac[2048];
    struct ieee80211_stats   stats;
    struct ifnet wd,awd;
    unsigned long too_many_user = 0;  /* #0045-2 guoxd_003 20081117 add+ */

   memset(&stats,0,sizeof(struct ieee80211_stats));
    memset(&wd,0,sizeof(wd));
    memset(&awd,0,sizeof(awd));   
    memset(date,0,sizeof(date));


    wifinum=iw_get_wifis();
    printf("wifinum=%d\n",wifinum);
    if(wifinum>0) {
     	
        if((vp->magic==STATXPKTS)||(vp->magic==STATXBYTES)||(vp->magic==STARXPKTS)||(vp->magic==STARXBYTES))
          get_multi_Interface_dates( &wd, &awd);
     
        ifnum=iw_enum_wlan_interface( ifname );
       printf("var_wapiWlanUserTable ifnum=%d\n",ifnum);

        if(((vp->magic)==STATXRETRYPKTS)||((vp->magic)==STARXRETRYPKTS)||
          ((vp->magic)==STARECEIVEERRPKTS)||((vp->magic)==STATXTOTSIGNAL)||
          ((vp->magic)==STATXSIGNALPKTS)||((vp->magic)==BGUSERASSOCOUNT)||
          ((vp->magic)==AUSERASSOCOUNT)||((vp->magic)==BGUSERASSOFAILCOUNT)||
          ((vp->magic)==AUSERASSOFAILCOUNT)||((vp->magic)==BGUSERASSOREASSOCOUNT)||
          ((vp->magic)==AUSERASSOREASSOCOUNT) || ((vp->magic) == SMENFAINSUFFICIENTRESOURCE))

          /* #0045-2 guoxd_003 20081117 modify */
        {
           for(j=0,p=ifname;j<ifnum;p=p+IFNAME_LEN,j++) {
         	  printf("ifname=%s err=%d \n",p,stats.is_rx_err_pack);
	    printf("addr: %x\n", &stats);
			  
		if(1==get_ioctl_parameter( p , &stats ))
			{printf("function  return success\n");}

         	  date[0]=date[0] + stats.is_rx_repack ;
         	  date[1]=date[1] + stats.is_rx_rebytes ;
         	  date[2]=date[2] + stats.is_rx_err_pack ;
         	  date[3]=date[3] + stats.is_tx_signaling ;
         	  date[4]=date[4] + stats.is_rx_signaling ;
		   too_many_user += stats.is_rx_ap_too_many_sta;  /* #0045-2 guoxd_003 20081117 add+ */
	        printf("date0=%d date1=%d date2=%d date3=%d date4=%d date5=%d\n",date[0],date[1],date[2],date[3],date[4],date[5]);

    if( strcmp( p,"ath" ) ){	  	// 802.11b/802.11g
         	  date[5]=date[5] + stats.is_assocs;
         	  date[6]=date[6] + stats.is_reassocs;
         	  date[7]=date[7] + stats.is_rx_assoc_badwpaie;
         	  date[8]=date[8] + stats.is_rx_assoc_bss;
         	  date[9]=date[9] + stats.is_rx_assoc_capmismatch;
         	  date[10]=date[10] + stats.is_rx_assoc_norate;	
	        printf("date5=%d date6=%d date7=%d date8=%d date9=%d date10=%d\n",date[5],date[6],date[7],date[8],date[9],date[10]);

         	  }
         	  else  {       //802.11a	  
         	  date[11]=date[11] + stats.is_assocs;
         	  date[12]=date[12] + stats.is_reassocs;
         	  date[13]=date[13] + stats.is_rx_assoc_badwpaie;
         	  date[14]=date[14] + stats.is_rx_assoc_bss;
         	  date[15]=date[15] + stats.is_rx_assoc_capmismatch;
         	  date[16]=date[16] + stats.is_rx_assoc_norate;	 
         	  }
	  
            printf("date11=%d date12=%d date13=%d date14=%d date15=%d date16=%d\n",date[11],date[12],date[13],date[14],date[15],date[16]);
            }
     	
        }
    }



        if (header_simple_table(vp,name,length,exact,var_len,write_method, tableSize)
                                                    == MATCH_FAILED )
        return NULL;
    
        switch(vp->magic) {
        case STAADDRESS:
            if(wifinum>0){
              	if(wifinum>0){
              	bzero(tempmac,2048);
              	bzero(maclist,2048);
              	ulong_ret=0;
                    get_ioctl_driver( "wifi0" ,tempmac,2);
              		
                    memcpy(&ulong_ret,(tempmac+4),4);
              	t=maclist;
                    for(j=0,q=(tempmac+4+4);j<ulong_ret;q=q+10,t=t+6,j++)
              	    memcpy(t,q+4,6);
              	*var_len=ulong_ret;
              	}

              	if(wifinum>1) {
                    bzero(tempmac,2048);
              	ulong_ret=0;
                    get_ioctl_driver( "wifi1" ,tempmac,2);
                    memcpy(&ulong_ret,(tempmac+4),4);
                    for(j=0,q=(tempmac+4+4);j<ulong_ret;q=q+10,t=t+6,j++)
                        memcpy(t,q+4,6);
              
                    *var_len=*var_len + ulong_ret;
              	}
              	*var_len=*var_len * 6;
            }
	     else{
	         bzero(maclist,2048);
                *var_len=0;
	    }
            return (u_char*) maclist;    
        case STATXPKTS:
	     if(wifinum>0){
                long_ret=wd.if_opackets + awd.if_opackets;	
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
        case STATXBYTES:
	     if(wifinum>0){
                long_ret=(wd.if_obytes + awd.if_obytes)/1024 ;
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
        case STARXPKTS:
	     if(wifinum>0){
                long_ret=wd.if_ipackets + awd.if_ipackets;     
	     }
	     else {
                long_ret=0;
	     }
           return (u_char*) &long_ret;
        case STARXBYTES:
	     if(wifinum>0){
                long_ret= (wd.if_ibytes + awd.if_ibytes)/1024 ;     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
			

        case STATXRETRYPKTS:
	     if(wifinum>0){
                long_ret=date[0];     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
     
        case STARXRETRYPKTS:
	     if(wifinum>0){
                long_ret=date[1]/1024;     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;

        case STATXFRAGMENTEDPKTS:
            long_ret=0;     
            return (u_char*) &long_ret;
        case STARXFRAGMENTEDPKTS:
            long_ret=0;     
            return (u_char*) &long_ret;


        case STARECEIVEERRPKTS:
	     if(wifinum>0){
                long_ret=date[2];     
	     }
	     else {
                long_ret=0;
	     }
           return (u_char*) &long_ret;
        case STATXTOTSIGNAL:
	     if(wifinum>0){
                long_ret=date[3];     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
        case STATXSIGNALPKTS:
	     if(wifinum>0){
                long_ret=date[4];     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
			
	
	 
        case STAFRAMENONUNICASTRATE: //add
	     if(wifinum>0){
                long_ret=1000;     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
        case STAFRAMEBANDWIDTHRATE:  //add
	     if(wifinum>0){
              	if(wifinum==1)
                        long_ret=18;
              	else if(wifinum==2)     
                        long_ret=48;
              	else
              	    long_ret=0;
	     }
	     else {
                long_ret=0;
	     }
           return (u_char*) &long_ret;


        case BGUSERASSOCOUNT:
	     if(wifinum>0){
                long_ret=date[5]+date[6]+date[7]+date[8]+date[9]+date[10];     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
        case AUSERASSOCOUNT:
	     if(wifinum>0){
                long_ret=date[11]+date[12]+date[13]+date[14]+date[15]+date[16];     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
        case BGUSERASSOFAILCOUNT:
	     if(wifinum>0){
                long_ret=date[7]+date[8]+date[9]+date[10];     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
        case AUSERASSOFAILCOUNT:
	     if(wifinum>0){
                long_ret=date[13]+date[14]+date[15]+date[16];   
	     }
	     else {
                long_ret=0;
	     }
           return (u_char*) &long_ret;
        case BGUSERASSOREASSOCOUNT:
	     if(wifinum>0){
                long_ret=date[6];     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
        case AUSERASSOREASSOCOUNT:
	     if(wifinum>0){
                long_ret=date[12];     
	     }
	     else {
                long_ret=0;
	     }
            return (u_char*) &long_ret;
        case SMENFAINSUFFICIENTRESOURCE:
	     if (wifinum > 0) {
                long_ret = (unsigned long)too_many_user;     
	     }
	     else {
                long_ret = 0;
	     }
            return (u_char*) &long_ret;

	
        case INACROAMINGSUCCRATE:
            long_ret=0;     
            return (u_char*) &long_ret;
       case OUTACROAMINGSUCCRATE:
           long_ret=0;     
           return (u_char*) &long_ret;
        default:
          ERROR_MSG("");
        }
        return NULL;
}


/*
 * var_wapiApWifiInterfaceStatisticsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wapiPwlanAp above.
 */
static unsigned long  totalPkts;
static unsigned long  retryPkst;
static unsigned long  macErrPkts;
unsigned char *
var_wapiApWifiInterfaceStatisticsTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{

#ifdef  DEBUG_PWLAN  
    char buf[200];  
    bzero(buf, 200);
    sprint_mib_oid(buf, name, *length);
    printf("read wapiApWifiInterfaceStatisticsTable %s \n",buf);        
#endif 
	double  rate=0.0;
    double  rate1=0.0;
	char ftmp[20];
    /* variables we may use later */
    static unsigned long  long_ret;	
    static unsigned long  ulong_ret; 
	static unsigned long  utime_ret; 
	static double  double_ret;
    int tableSize=0;
    static char ap_parameter[256];
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    int i;
    int channel[2]={0,},*pc;
    time_t courTimes;

	time_t bgNowTimes;
	time_t aNowTimes;
    char tempmac[2048];
    struct ifnet   ifdate ;
    WAPI_STATS_ENTRY wapiDate;
    int ifnum=0,j=0;
    char ifname[IFNAME_MAX],*p;
    char wifi0name[]="wifi0";
    char wifi1name[]="wifi1";
    char wlanchannel[]="WLAN0_CHANNEL";
    char awlanchannel[]="AWLAN0_CHANNEL";
    char  *wifip,*wlanp;
    int date[10]; /* | date[0]      | date[1]        |   */
		          /* | wifi0          | wifi1            |   */
			  /*  | 802.11bg   | 802.11a       |*/
    int retryPkt=0;
    struct ieee80211_stats stats;
    bzero(date,10);
    memset(&stats,0,sizeof(stats));
    memset(&ifdate,0,sizeof(ifdate));

    tableSize=iw_get_wifis();
    if(tableSize==0) return ; //not't wifi
    
    if((vp->magic)==CHSTATSCHANNEL){
        iw_enum_channel(tableSize, channel);
    }
	
    bzero(ifname,IFNAME_MAX);
    ifnum=iw_enum_wlan_interface( ifname );
    if(((vp->magic)==CHSTATSTOTRETRYPKTS)||((vp->magic)==CHSTATSFRAMERETRYRATE)) {	 //get  CHSTATSTOTRETRYPKTS value
		
        for(j=0,p=ifname;j<ifnum;p=p+IFNAME_LEN,j++) {
          get_ioctl_parameter( p , &stats );
	      if(strstr(p,"awlan")==NULL){
                date[0]=date[0] + stats.is_rx_repack ;
				fprintf(stderr,"ath=%s is_rx_repack=%d \n" ,p,stats.is_rx_repack);
	      }// by sunyushuang0320
	      else{
                date[1]=date[1] + stats.is_rx_repack ;
		  		fprintf(stderr,"awlan=%s is_rx_repack=%d \n" ,p,stats.is_rx_repack);
	      }
        }
    }	
	
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tableSize)
                                                == MATCH_FAILED ){
    	return NULL;
    }
	
	if (name[*length - 1] > tableSize)
    {
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- no match: %lu\n",name[*length - 1]));
        return NULL;
    }
	
 
   	if(((vp->magic)==CHSTATSTOTPKTS)||((vp->magic)==CHSTATSTOTBYTES)\
   	        ||((vp->magic)==CHSTATSFRAMEERRORRATE)||((vp->magic)==CHSTATSFRAMERETRYRATE)\
   	                   ||((vp->magic)==CHSTATSTOTPHYERRPKTS)){
	   get_one_Interface_dates("wifi0", &ifdate) ;
   	}
	retryPkt=date[0];
	wifip=wifi0name;
	pc=channel;
   	if(timeCleanFlagbg){	
		time(&bgNowTimes);
		utime_ret = time_clean_zero(channelMonitoreTimebg,bgNowTimes);
	}else{
		time(&courTimes);
     	utime_ret=abs(courTimes-sysAgentTimes);
	}
    
    for (i = 1;  i < name[*length - 1]; i++)
    {
        //get_ioctl_driver( "wifi1" ,tempmac,2);   
    	if(((vp->magic)==CHSTATSTOTPKTS)||((vp->magic)==CHSTATSTOTBYTES)\
			||((vp->magic)==CHSTATSTOTPHYERRPKTS)||((vp->magic)==CHSTATSFRAMERETRYRATE)){
        	get_one_Interface_dates("wifi1", &ifdate); 
    	}
	 	retryPkt=date[1];
	 	wifip=wifi1name;
	 	pc=channel+1;
	    if(timeCleanFlaga){
       	  	time(&aNowTimes);
		  	utime_ret = time_clean_zero(channelMonitoreTimea,aNowTimes);
        }else{
			time(&courTimes);
     		utime_ret=abs(courTimes-sysAgentTimes);
		}
    }
   
   
   /* 
   * this is where we do the value assignments for the mib results.
   */

    switch(vp->magic) {
    case CHSTATSCHANNEL:
        *write_method = write_ChStatsChannel;
	  	long_ret = *pc;
        return (u_char*) &long_ret ;
    case CHSTATSNUMSTATIONS:
	 	memset(tempmac,0,2048);
	 	get_ioctl_driver( wifip ,tempmac,2); 
        memcpy(&long_ret,(tempmac+4),4);
		
        return (u_char*) &long_ret ;
    case CHSTATSTOTPKTS:
         long_ret=ifdate.if_ipackets+ifdate.if_opackets;
        return (u_char*) &long_ret ;
    case CHSTATSTOTBYTES:
		long_ret=(ifdate.if_ibytes+ifdate.if_obytes);
        return (u_char*) &long_ret ;
    case CHSTATSTOTRETRYPKTS:
        long_ret=retryPkt;
        return (u_char*) &long_ret ;
		

    case CHSTATSTOTFRAGMENTEDPKTS: //add
        long_ret=get_wifi_frame_dates(wifip);
        return (u_char*) &long_ret ;


    case CHSTATSTOTPHYERRPKTS:
        if(tableSize=0)
            long_ret=0;
        else {
       	  long_ret=(ifdate.if_ierrors+ifdate.if_oerrors);
        }
        return (u_char*) &long_ret ;
    case CHSTATSTOTMACERRPKTS:
        if(tableSize=0)
            long_ret=0;
        else 
       	  long_ret=0;
        return (u_char*) &long_ret ;
    case CHSTATSFRAMEERRORRATE:
        if(tableSize=0)
            long_ret=0;
        else {
			totalPkts=(ifdate.if_ibytes+ifdate.if_obytes);
			fprintf(stderr,"totalPkts=%d  err=%d \n",totalPkts,(ifdate.if_ierrors+ifdate.if_oerrors));
			if(totalPkts<1) totalPkts=1;
       	    double_ret=(double)((ifdate.if_ierrors+ifdate.if_oerrors)/(double)totalPkts);
			fprintf(stderr,"double_ret=%E\n",double_ret);
			long_ret=(int)(double_ret*100000000);
			fprintf(stderr,"long_ret=%d\n",long_ret);
        }
        return (u_char*) &long_ret ;

    case CHSTATSFRAMERETRYRATE:
        if(tableSize=0)
            long_ret=0;
        else {				
			totalPkts=(ifdate.if_ibytes+ifdate.if_obytes);
			fprintf(stderr,"totalPkts=%d  retryPkt=%d \n",totalPkts,retryPkt);
			if(totalPkts<1) totalPkts=1;
			double_ret=(double)(((double)retryPkt)/(double)totalPkts);
			fprintf(stderr,"double_ret=%E\n",double_ret);
			long_ret=(int)(double_ret*100000000);
			fprintf(stderr,"long_ret=%d\n",long_ret);
        }		
        return (u_char*) &long_ret ;


    case CHSTATSFRAMENONUNICASTRATE:
        if(tableSize=0)
            long_ret=0;
        else 
       	  long_ret=0;
        return (u_char*) &long_ret ;
    case CHSTATSFRAMEBANDWIDTHRATE:
        if(tableSize=0)
            long_ret=0;
        else 
       	  long_ret=0;
        return (u_char*) &long_ret ;
    case CHSTATSFRAMEFRAGMENTATIONRATE:
        if(tableSize=0)
            long_ret=0;
        else 
       	  long_ret=0;
        return (u_char*) &long_ret ;
    case CHSTATSMONITOREDTIME:
     	long_ret=utime_ret;		
        return (u_char*) &long_ret ;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int 
time_clean_zero(time_t  stime,time_t  etime ){
	unsigned long long_ret;
	long_ret = abs(etime-stime);
	return long_ret;
}
int
write_ChStatsChannel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    unsigned long  value,ret;
    int size,result,pid,countrycode;
    char msgbuff[MSG_BUFF_LEN], temp[20], conf_file[256],array[20],channel[20] ;
    char traptmp[]="changed Channel to  ";
    char trapStr[30];
    AAT aat;
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    char ap_parameter[20];
     time_t nowTimes;
    char buffer[128];
    
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		   value = * (long *) var_val;
		   if((value< 0) || (value > 165)){
			fprintf(stderr,"write to wapiPwlanAp: bad length\n");
		       return SNMP_ERR_WRONGVALUE; 
		   }
		   if((value>13) && (value < 36)){
			fprintf(stderr,"write to wapiPwlanAp: bad length\n");
		       return SNMP_ERR_WRONGVALUE; 
		   }
		   if((value>64 ) && (value <149)){
			fprintf(stderr,"write to wapiPwlanAp: bad length\n");
		       return SNMP_ERR_WRONGVALUE; 
		   }

          break;
        case RESERVE2:
          break;
        case FREE:
          break;

        case ACTION:
	   ret=(int) name[name_len-1];
	   bzero(channel, 20);
	   value = * (long *) var_val;
	   if(ret==1){
		   	if(value<0 ||value>13 ){
			     fprintf(stderr,"write to wapiPwlanAp: B/G channle value error \n");
		            return SNMP_ERR_WRONGVALUE;
		   	}
		   	strcpy(channel,"WLAN0_CHANNEL");
			timeCleanFlagbg = 1;
			time(&channelMonitoreTimebg);
	               memset(buffer,0,128);
			 system("/sbin/ifconfig ath0 down");
	               memset(buffer,0,128);
			 sprintf(buffer,"%s  %d","/usr/sbin/iwconfig   ath0 channel",value);
			 system(buffer);
			 memset(buffer,0,128);
			 system("/sbin/ifconfig ath0 up");
			
	   }else if (ret==2){
	   		timeCleanFlaga = 1;
			time(&channelMonitoreTimea);
	   		bzero(ap_parameter,20);
	   		prop_count=load_prop(SEP_EQUAL,WIRELESS_CONF,properties);
	       	get_prop("COUNTRYCODE",ap_parameter,properties,prop_count);
	       	free_prop(properties,prop_count);
	       	countrycode=atoi(ap_parameter);
			if(countrycode==156){
				switch(value){
				    case 0:   break;
				    case 149:  break;
				    case 153:  break;
	                case 157:  break;
				    case 161:  break;
				    case 165:  break;
				    default: {		     
			            fprintf(stderr,"write to wapiPwlanAp: B/G channle value error \n");
		            	return SNMP_ERR_WRONGVALUE;
				    }
			}

		}else if (countrycode==36){
				switch(value){
				    case 0:   break;
				    case 36:  break;
				    case 40:  break;
				    case 44:  break;
				    case 50:  break;
				    case 54:  break;
				    case 60:  break;
	                case 64:  break;
				    case 149:  break;
				    case 153:  break;
	                case 157:  break;
				    case 161:  break;
				    case 165:  break;
				    default: {		     
			            fprintf(stderr,"write to wapiPwlanAp: B/G channle value error \n");
		                return SNMP_ERR_WRONGVALUE;
				    }
		     }

		}else {
		    goto error;
		}
	   	strcpy(channel,"AWLAN0_CHANNEL");
	   }else{
	   		return SNMP_ERR_GENERR;
	   }
	   bzero(temp, 20);
	   bzero(trapStr, 30);
	   sprintf(temp,"%d",*(long *) var_val);
	   strcpy(trapStr,traptmp);
	   strcat(trapStr,temp);
	   bzero(ap_parameter,20);
	   prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	   get_prop("LAN_IP",ap_parameter,properties,prop_count);
	   free_prop(properties,prop_count);
	   memset(&aat,0,sizeof(aat));
	   set_alarm( & aat,ALARM_ID_CHANNEL_CHANGED,trapStr);
       send_trap_string_notification(&aat);	 
	   bzero(array, 20);
       sprintf(array,"%ld",*(unsigned long *) var_val);
	   array[var_val_len]='\0';
       save_global_conf(SEP_EQUAL,WIRELESS_CONF,"",channel,array);
error:
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:

          break;
    }
    return SNMP_ERR_NOERROR;
 
}

/*
 * var_wapiStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wapiPwlanAp above.
 */

unsigned char *
var_wapiStatsTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
   
#ifdef  DEBUG_PWLAN  
    char buf[200];  
    bzero(buf, 200);
    sprint_mib_oid(buf, name, *length);
    printf("read wapiStatsTable %s \n",buf);        
#endif 

    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    WAPI_STATS_ENTRY wapiDate;
    int ret=0;
    int i=0,j,ifnum=0;
    static char ap_parameter[256];
    int driverDate[10];
    struct ieee80211_stats stats;
    char ifname[IFNAME_MAX];
    char *ip;
	
    bzero(driverDate,10);
    memset(&stats,0,sizeof(stats));
    memset(&wapiDate,0,sizeof(WAPI_STATS_ENTRY));
    bzero(ifname,IFNAME_MAX);
    if(iw_get_wifis()==0)
    	return NULL;
    ip=ifname;
    ifnum=iw_enum_wlan_interface(ifname);
	
	
/*此部分对 < 18.1.1.6   18.1.1.7   18.1.1.8 >    赋值，结构体 struct ieee80211_stats stats; */
if ( (vp->magic==WPIREPLAYCOUNTER)||(vp->magic==WPIDECRYPTABLEERRORS)||(vp->magic==WPIMICERRORS) ) {   
    for(j=0;j<ifnum;j++,ip=ip+IFNAME_LEN){
	  	get_ioctl_parameter( ip ,&stats);
	  	driverDate[0]=driverDate[0]+stats.is_re_wpi ;
	  	driverDate[1]=driverDate[1]+stats.is_wpi_no_key_error ;
	  	driverDate[2]=driverDate[2]+stats.is_wpi_mic ;
	  }
} 


    if (header_simple_table(vp,name,length,exact,var_len,write_method, 1)
                                                == MATCH_FAILED )
    return NULL;




/*此部分对 < 18.1.1.9  --18.1.1.17  >   赋值，结构体WAPI_STATS_ENTRY wapiDate; */
    if( (vp->magic>=WAISIGNATUREERRORS)||(vp->magic<=WAIMULTICASTHANDSHAKEFAILURES) )	    
    snmp_wapi_udp(&wapiDate,NULL);//midify by piyp 2009-02-19
    
    printf(" wai_sign_errors=%d \n",wapiDate.wai_sign_errors);
    printf(" wai_hamc_errors=%d \n",wapiDate.wai_hamc_errors);
    printf(" wai_auth_res_fail=%d \n",wapiDate.wai_auth_res_fail);
    printf(" wai_discard=%d \n",wapiDate.wai_discard);
    printf(" wai_timeout=%d \n",wapiDate.wai_timeout);
    printf(" wai_format_erros=%d \n",wapiDate.wai_format_erros);
    printf(" wai_cert_handshake_fail=%d \n",wapiDate.wai_cert_handshake_fail);
    printf(" wai_unicast_handshake_fail=%d \n",wapiDate.wai_unicast_handshake_fail);
    printf(" wai_multi_handshake_fail=%d \n",wapiDate.wai_multi_handshake_fail);


    for (i = 1;  i < name[*length - 1]; i++)
    {
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- %lu != %lu\n",i, name[*length - 1]));
    }
    
    /* 
   * this is where we do the value assignments for the mib results.
   */
   	printf("%s: vp->magic %d.\n", __func__, vp->magic);
    switch(vp->magic) {
    case WAPISTATSINDEX:
        ulong_ret =i;
        return  (u_char*) &ulong_ret;
    case WAPISTATSVERSION:
        ulong_ret =1;
        return  (u_char*) &ulong_ret;
    case SELECTEDUNICASTCIPHER:
        memset(ap_parameter,0,256);
        strcpy(ap_parameter,"00147201");
        *var_len = strlen(ap_parameter);
        return (unsigned char *) ap_parameter;

		
   case WPIREPLAYCOUNTER:  
        ulong_ret =driverDate[0];		
        return  (u_char*) &ulong_ret;
   case WPIDECRYPTABLEERRORS:
        ulong_ret =driverDate[1] ;		
        return  (u_char*) &ulong_ret;
   case WPIMICERRORS:
        ulong_ret =driverDate[2] ;		
        return  (u_char*) &ulong_ret;


		
    case WAISIGNATUREERRORS:
        ulong_ret =wapiDate.wai_sign_errors;
        return  (u_char*) &ulong_ret;
    case WAIHMACERRORS:
        ulong_ret =wapiDate.wai_hamc_errors ;
        return  (u_char*) &ulong_ret;
    case WAIAUTHENTICATIONRESULTFAILURES:
        ulong_ret =wapiDate.wai_auth_res_fail ;
        return  (u_char*) &ulong_ret;
    case WAIDISCARDCOUNTERS:
        ulong_ret =wapiDate.wai_discard ;
        return  (u_char*) &ulong_ret;
    case WAITIMEOUTCOUNTERS:
        ulong_ret =wapiDate.wai_timeout ;
        return  (u_char*) &ulong_ret;
    case WAIFORMATERRORS:
        ulong_ret =wapiDate.wai_format_erros ;
        return  (u_char*) &ulong_ret;

    case WAICERTIFICATEHANDSHAKEFAILURES:
        ulong_ret =wapiDate.wai_cert_handshake_fail ;
        return  (u_char*) &ulong_ret;
    case WAIUNICASTHANDSHAKEFAILURES:
        ulong_ret =wapiDate.wai_unicast_handshake_fail ;
        return  (u_char*) &ulong_ret;
    case WAIMULTICASTHANDSHAKEFAILURES:
        ulong_ret =wapiDate.wai_multi_handshake_fail ;
        return  (u_char*) &ulong_ret;

    default:
      ERROR_MSG("wapiStatsTable:default\n");
    }
    return NULL;
}


/*  add by piyp 2009-02-19
 * var_wapiSTAPortStatusTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_wapiPwlanAp above.
 */

unsigned char *
var_wapiSTAPortStatusTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
   
#ifdef  DEBUG_PWLAN  
    char buf[200];  
    bzero(buf, 200);
    sprint_mib_oid(buf, name, *length);
    printf("read wapiStatsTable %s \n",buf);        
#endif 

    /* variables we may use later */
    static long long_ret;
    static unsigned int int_ret;
    int staCount=0;
    int i=0;
    static char sta_mac[6];
	static char ctrl_port[4];;
    char buffer[1024],tmp[4];
    char *pos;
	
	memset(buffer,0,1024);
	memset(tmp,0,4);
	memset(sta_mac,0,6);
	memset(ctrl_port,0,4);
   	if(!snmp_wapi_udp(NULL,buffer)){
		printf("error,no value");
		return NULL;
   	}

	pos = buffer;
	memcpy(tmp,pos,4);
	staCount = read_dword(tmp, 0);

	printf("staCount:%d\n",staCount);
	pos +=4;
	memcpy(sta_mac,pos,6);
	pos+=6;
	memcpy(ctrl_port,pos,2);
	printf("%d,%d,%d,%d\n",ctrl_port[0],ctrl_port[1],ctrl_port[2],ctrl_port[3]);
	int_ret = read_word(ctrl_port, 0);
	pos+=2;	
      printf("int_ret:%d\n",int_ret);

   if(staCount==0)
   {
   	    if (header_simple_table(vp,name,length,exact,var_len,write_method, 1)
                                                == MATCH_FAILED ){
    	return NULL;
    }

   }

   else

 {
    if (header_simple_table(vp,name,length,exact,var_len,write_method, staCount)
                                                == MATCH_FAILED ){
    	return NULL;
    }
    for (i = 1;  i < name[*length - 1]; i++)
    {
		memcpy(sta_mac,pos,6);
		pos+=6;
		memcpy(ctrl_port,pos,2);
		int_ret = read_word(ctrl_port, 0);
		pos+=2;
        DEBUGMSGTL(("wapi/wapiPwlanAp", "wapi -- %lu != %lu\n",i, name[*length - 1]));
    }


   	}
    
    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
   
    case WAPISTAADDRESS:
		*var_len = 6;
      return (u_char*) sta_mac ;
    case CONTROLLEDPORTSTATUS: 
		*var_len = 4;
        return  (u_char*) &int_ret;
   
    default:
      ERROR_MSG("wapiSTAPortStatusTable:default\n");
    }
    return NULL;
}


int
write_wapiSTAAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiConfigUserSeparate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size;
    int pid;
    char temp[20];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiap not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiap: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;
        case ACTION:
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_BRIDGE",temp);

          aargv[0] = WIRELESS_SCR;
          aargv[1] = NULL;

         pid =fork();

          if(pid == 0)
          {    
                sleep(2);
                execv(aargv[0],aargv);
                _exit(0);
          }
          else if(pid > 0)
          {}
          else
                return SNMP_ERR_GENERR;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

// add by piyp 2005-11-25
int
write_wapiConfigLoadBalancePolicy(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[20];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiap not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiap: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
     	   value = * (long *) var_val ;
	   if((value <0) ||(value >2) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
          break;
        case ACTION:
	      memset(temp,0,20);
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","WLAN0_LB",temp);
          system(WIRELESS_SCR);
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wapiConfigLoadBalanceGroupName(int      action,
						            u_char   *var_val,
						            u_char   var_val_type,
						            size_t   var_val_len,
						            u_char   *statP,
						            oid      *name,
						            size_t   name_len)
{
    u_long value;
    char temp[64];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiap not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 64) {
              fprintf(stderr,"write to wapiap: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
     	  
	   break;	  
        case RESERVE2:
          break;
        case FREE:
          break;
        case ACTION:
		  memset(temp,0,64);
          sprintf(temp,"%s",var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_LBGROUP",temp);
          system(WIRELESS_SCR);
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiConfigUsersloadValue(int      action,
						            u_char   *var_val,
						            u_char   var_val_type,
						            size_t   var_val_len,
						            u_char   *statP,
						            oid      *name,
						            size_t   name_len)
{
    u_long value;
    char temp[20];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiap not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiap: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
     	   value = * (long *) var_val ;
	   if((value <1) ||(value >100) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
          break;
        case ACTION:
		 	memset(temp,0,20);
          	sprintf(temp,"%ld",*(unsigned long *) var_val);
          	save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_LBUSER",temp);
          	system(WIRELESS_SCR);
         
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wapiConfigFluxloadValue(int      action,
						            u_char   *var_val,
						            u_char   var_val_type,
						            size_t   var_val_len,
						            u_char   *statP,
						            oid      *name,
						            size_t   name_len)
{
    u_long value;
    char temp[20];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiap not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiap: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
     	   value = * (long *) var_val ;
	   if((value <1) ||(value >10240) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
          break;
        case ACTION:
			memset(temp,0,20);
          	sprintf(temp,"%ld",*(unsigned long *) var_val);
          	save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_LBDATA",temp);
          	system(WIRELESS_SCR);
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapidot11QosEnabled(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size;
    int pid;
    char temp[20];
    static char * aargv[2];
    char scr_file[100];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiap not ASN_UNSIGNED\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiap: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;
        case ACTION:

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int 
write_wapiTrapIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   
    int ret=0;
    char strTemp[255];
    int index =1;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS){
              fprintf(stderr, "write to apOperLocalIPAddr not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 4){
              fprintf(stderr,"write to apOperLocalIPAddr: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

        case RESERVE2:
          break;
        case FREE:
          break;
        case ACTION:
	        sprintf(strTemp,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
			ret=var_val[3];
			if(ret==255){
				return SNMP_ERR_WRONGVALUE;
			}
			system("killall  snmpd");
			set_trap_ip("/etc/snmp/snmpd.conf",strTemp,index);
		       system("/etc/snmp/snmpd  -c  /etc/snmp/snmpd.conf  -C  &");
		          
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int 
write_wapiTrapSecondaryIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    
    char strTemp[255];
    int ret=0,index =2;
 
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS){
              fprintf(stderr, "write to apOperLocalIPAddr not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len != 4){
              fprintf(stderr,"write to apOperLocalIPAddr: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        	sprintf(strTemp,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
			ret=var_val[3];
			if(ret==255){
				return SNMP_ERR_WRONGVALUE;
			}	
        	set_trap_ip("/etc/snmp/snmpd.conf",strTemp,index);
		    system("/etc/snmp/restart_snmpd");
         		 break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int 
write_wapiRwcommunity(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     FILE *fp;
     char string[1024];
     char strTemp[256];
     char buffer[2][32];
     char *token;
     char *cnew;
     int byte_read;
     int i=0;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
	  memset(strTemp,0,256);
	  memset(buffer[0],0,32);
	  memset(buffer[1],0,32);
	  memset(string,0,1024);
	  system("killall  snmpd");
	  memcpy(strTemp, var_val, var_val_len);
         strTemp[var_val_len] = '\0';
	  token = strtok(strTemp, ":");
  		while (NULL != token)
			{
			        strcpy(buffer[i],token);   
				token = strtok(NULL,":");
				i++;
			}
		
		printf("buffer[0]:%s\n",buffer[0]);
		printf("buffer[1]:%s\n",buffer[1]);

		
		fp=fopen(SNMPD_CONF,"r+");
               byte_read=fread(string,1,sizeof(string),fp);
		 if(byte_read==0||byte_read==sizeof(string))
		     return -1;
		 string[byte_read]='\0';
		 fclose(fp);
		 cnew=str_replace(string,buffer[0],buffer[1]);
		 fp=fopen(SNMPD_CONF,"w+");
	        fwrite(cnew,byte_read,1,fp);
		fclose(fp);
		system("/usr/sbin/snmpd  -c   /etc/snmp/snmpd.conf  -C  &");


       	
          break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int 
write_wapiRocommunity(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     FILE *fp;
     char string[1024];
     char strTemp[256];
     char buffer[2][32];
     char *token;
     char *cnew;
     int byte_read;
     int i=0;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,256);
	  memset(buffer[0],0,32);
	  memset(buffer[1],0,32);
	  memset(string,0,1024);
	  system("killall  snmpd");
	  memcpy(strTemp, var_val, var_val_len);
         strTemp[var_val_len] = '\0';
	  token = strtok(strTemp, ":");
  		while (NULL != token)
			{
			        strcpy(buffer[i],token);   
				token = strtok(NULL,":");
				i++;
			}
		
		printf("buffer[0]:%s\n",buffer[0]);
		printf("buffer[1]:%s\n",buffer[1]);

		fp=fopen(SNMPD_CONF,"r+");
               byte_read=fread(string,1,sizeof(string),fp);
		 if(byte_read==0||byte_read==sizeof(string))
		     return -1;
		 string[byte_read]='\0';
		 fclose(fp);
		 cnew=str_replace(string,buffer[0],buffer[1]);
		 fp=fopen(SNMPD_CONF,"w+");
	        fwrite(cnew,byte_read,1,fp);
		fclose(fp);
		system("/usr/sbin/snmpd  -c   /etc/snmp/snmpd.conf  -C  &");

	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiConfigHostName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    char value;
    int size;
    char strTemp[256];
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    switch ( action ) {
    	
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
          	
              fprintf(stderr, "write to wapias not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32) {
          
              fprintf(stderr,"write to wapias: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
          break;

        case ACTION:
        	
          	memcpy(strTemp, var_val, var_val_len);
	  		strTemp[var_val_len] = '\0';
	  		save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","HOST_NAME",strTemp);
          break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wapiConfigWirelessModeBG(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;
    char strTemp[10];
    int pid;
    static char scr_file[256];
    static char * aargv[2];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <2)|| (value >3) )
		return SNMP_ERR_WRONGVALUE;
	   break;
        case RESERVE2:
          //size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  value = * (int *) var_val;
	  if(value==3)
	      save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_WMODE","3");
	  else if(value==2)
              save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_WMODE","2");
	  else 
	     return 0;

          strcpy(scr_file, AP_REBOOT_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          if(*(unsigned long *) var_val == 0)
          break;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
          return SNMP_ERR_GENERR;
          break;
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


 
int
write_wapiBasicManufacturer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
	char strTemp[10];

    switch ( action ) {
        case RESERVE1:
                   if (var_val_type != ASN_OCTET_STR) {
          	
              fprintf(stderr, "write to wapias not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 265) {
          
              fprintf(stderr,"write to wapias: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        	
          memcpy(strTemp, var_val, var_val_len);
	        strTemp[var_val_len] = '\0';
	        save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"","BASICMANUFACTURER",strTemp);
          
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiapSysLocation(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
	char strTemp[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
          	
              fprintf(stderr, "write to wapias not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 255) {
          
              fprintf(stderr,"write to wapias: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        	
	   memset(strTemp, 0, sizeof(strTemp));
          memcpy(strTemp, var_val, var_val_len);
	        save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"","APSYSLOCATION",strTemp);
          
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiapSysHostName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
          	
              fprintf(stderr, "write to wapias not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32) {
          
              fprintf(stderr,"write to wapias: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        	
	   memset(strTemp, 0, sizeof(strTemp));
          memcpy(strTemp, var_val, var_val_len);
	        save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"","APSYSHOSTNAME",strTemp);
          
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiapSysNEId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char strTemp[64];

    switch ( action ) {
          case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
          	
              fprintf(stderr, "write to wapias not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32) {
          
              fprintf(stderr,"write to wapias: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	   memset(strTemp, 0, sizeof(strTemp));
          memcpy(strTemp, var_val, var_val_len);
	        save_global_conf(SEP_EQUAL,AG_SNMP_CONF,"","APSYSNEID",strTemp);
          
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wapiConfigTxPower(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char value;
    int result;
    char temp[32];
	
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          
   	   value = * (long *) var_val ;
	  
	   if(value>4)
	   	return SNMP_ERR_WRONGVALUE;	
	     
	   break;
        case RESERVE2:
   
          break;

        case FREE:
            
          break;

        case ACTION:
             /* write config file .*/
              value = * (long *) var_val ;
              memset(temp,0,32);
              sprintf(temp,"%d",value);
              save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_TXPOWER",temp);
          break;

        case UNDO:
            
          break;

        case COMMIT:
             
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiConfigAutoPower(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
	char strTemp[10];

    switch ( action ) {
          case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
          	
              fprintf(stderr, "write to wapias not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >  sizeof(long)) {
          
              fprintf(stderr,"write to wapias: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  if((*(long *) var_val < 0) || (*(long *) var_val > 1))
	      	  return SNMP_ERR_WRONGVALUE;
          break;
        case RESERVE2:
          break;
        case FREE:
          break;

        case ACTION:
	  		bzero(strTemp, 10);
	  		sprintf(strTemp,"%ld",*(long *) var_val);
           	save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","WLAN0_AUTOGL",strTemp);
          	system(WIRELESS_SCR);
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wapiConfigFilterPkts(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
	char strTemp[10];

    switch ( action ) {
          case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
          	
              fprintf(stderr, "write to wapias not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >  sizeof(long)) {
          
              fprintf(stderr,"write to wapias: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  if((*(long *) var_val < 0) || (*(long *) var_val > 255))
	      	  return SNMP_ERR_WRONGVALUE;
          break;
        case RESERVE2:
          break;
        case FREE:
          break;

        case ACTION:
	  		bzero(strTemp, 10);
	  		sprintf(strTemp,"%ld",*(long *) var_val);
           	save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","FILTER",strTemp);
          	system("/usr/local/boa/htmls/script/setfilter");
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiConfigAutoAdjustInterval(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
	char strTemp[64];

    switch ( action ) {
          case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
          	
              fprintf(stderr, "write to wapias not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >  sizeof(long)) {
          
              fprintf(stderr,"write to wapias: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  if((*(long *) var_val < 120) || (*(long *) var_val > 1200))
	      	  return SNMP_ERR_WRONGVALUE;
          break;
        case RESERVE2:
          break;
        case FREE:
          break;

        case ACTION:
	  		bzero(strTemp, 64);
	  		sprintf(strTemp,"%ld",*(long *) var_val);
           	save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_AUTOGL1",strTemp);
          	system(WIRELESS_SCR);
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiConfigBeaconInterval(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int result,pid;
    char temp[20];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  if((*(long *) var_val < 20) || (*(long *) var_val > 1000))
	      return SNMP_ERR_WRONGVALUE;
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            sprintf(temp,"%ld",*(unsigned long *) var_val);
	  		save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_BEACON",temp);

	  aargv[0] = WIRELESS_SCR;
	  aargv[1] = NULL;
	  if(*(unsigned long *) var_val == 0)
		break;
	  pid =fork();
	  if(pid == 0)
	  {
		printf("pid==0\n");
 		execv(aargv[0],aargv);
		_exit(0);
	  }
	  else if(pid > 0)
	  {}
	  else
	  	return SNMP_ERR_GENERR;	

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiConfigWirelessModeA(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size;
    char msgbuff[MSG_BUFF_LEN];
    int result;
    char temp[20];
    char conf_file[256];
    static char *  aargv[]={AP_BASE_SCR,NULL};
    int pid;
    char array[20];
    char trapStr[30]="changed Channal to  ";
    AAT aat;
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    char ap_parameter[20];
     time_t nowTimes;
    
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	if((*(long *) var_val < 1) || (*(long *) var_val > 13))
	      return SNMP_ERR_WRONGVALUE;  
          break;

        case RESERVE2:
         // size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  bzero(temp, 20);
	  sprintf(temp,"%d",*(long *) var_val);
	  strcat(trapStr,temp);
	  time(&nowTimes);
	   strcat(trapStr,array) ;
	   bzero(ap_parameter,20);
	   prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	   get_prop("LAN_IP",ap_parameter,properties,prop_count);
	   free_prop(properties,prop_count);
	   memset(&aat,0,sizeof(aat));
	   set_alarm( & aat,ALARM_ID_CHANNEL_CHANGED,trapStr);
       send_trap_string_notification(&aat);
          sprintf(array,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","AWLAN0_WMODE",array);
       
          pid = fork();
          if (pid == 0)
          {   
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
             wait(NULL);
          }
          else
          {
             return SNMP_ERR_GENERR;
          }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:

          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiConfigLanIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     u_long value;
    int size;
    char ipaddr[20],maskaddr[20];
   
    static oid      objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
    size_t   objid_snmptrap_len = OID_LENGTH(objid_snmptrap);
    netsnmp_variable_list * var_list = NULL;
    
    static oid      objid_sendoid[] = { 1,3,6,1,4,1,4000,100,2,1,0 };
    char trapStr[30]="changed lanIP to  ";
    AAT aat;
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    char ap_parameter[20];
     time_t nowTimes;
    static char * const aargv[]={AP_BASE_SCR,"lan",NULL};
    int pid = 0;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	   bzero(ipaddr, 20) ;
          sprintf(ipaddr,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
          save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","LAN_IP",ipaddr);
	   bzero(maskaddr, 20) ;
	   sprintf(maskaddr,"%d.%d.%d.%d",255,255,255,0);
	   save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","LAN_MASK",maskaddr);
		  
	   time(&nowTimes);
	   strcat(trapStr,ipaddr) ;
	   bzero(ap_parameter,20);
	   prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	   get_prop("LAN_IP",ap_parameter,properties,prop_count);
	   free_prop(properties,prop_count);
	   memset(&aat,0,sizeof(aat));
	   set_alarm( &aat,ALARM_ID_IP_CHANGED,trapStr);
       send_trap_string_notification(&aat);	

	   pid = fork();
	  if (pid == 0)
          {	     
	     setsid();
	     sleep(1);
             execv(aargv[0],aargv);
             exit(0);
          }
	  else if(pid > 0)
	  {
	     wait(NULL);
	  }
          else 
	  {
	     return SNMP_ERR_GENERR;
	  }
		  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
	   
		  
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiConfigLanMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,


            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size;
    char ipaddr[20];
    static char * const aargv[]={AP_BASE_SCR,"lan",NULL};
    int pid = 0;
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  sprintf(ipaddr,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
	  save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","LAN_MASK",ipaddr);

         pid = fork();
	  if (pid == 0)
          {	     
	     setsid();
	     sleep(1);
             execv(aargv[0],aargv);
             exit(0);
          }
	  else if(pid > 0)
	  {
	     wait(NULL);
	  }
          else 
	  {
	     return SNMP_ERR_GENERR;
	  }
		  
	  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

///
int
write_wapiConfigLanGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size;
    char ipaddr[20];
    static char * const aargv[]={AP_BASE_SCR,"lan",NULL};
    int pid = 0;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        //  size  = var_val_len;
         // value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          sprintf(ipaddr,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
	  save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","LAN_GW",ipaddr);
	  pid = fork();
	  if (pid == 0)
          {
	     printf("write_asOperGateway\n");
	     setsid();
	     sleep(1);
             execv(aargv[0],aargv);
             exit(0);
          }
	  else if(pid > 0)
	  {
	     wait(NULL);
	  }
          else 
	  {
	     return SNMP_ERR_GENERR;
	  }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiNtpServerIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     u_long value;
    int size;
    char ipaddr[256];
    char server_cmd[256]="";
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  bzero(ipaddr, 256);
	  sprintf(ipaddr,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
	  save_global_conf(SEP_EQUAL,NTP_CONF,"","NTPIP",ipaddr);
	  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_wapiConfigDtimPeriod(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size,result;
    char temp[30];
    int pid;
    static char scr_file[256];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	  if((*(unsigned long *) var_val < 256) || (*(unsigned long *) var_val > 2346))
		  return SNMP_ERR_WRONGVALUE;
          break;

        case RESERVE2:
        //  size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_FRAG",temp);
		  
          strcpy(scr_file, WIRELESS_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
              return SNMP_ERR_GENERR;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiConfigfactoryDefault(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          
	value = * (long *) var_val;
	if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;		  
        break;
        case RESERVE2:
         //  size  = var_val_len;
         // value = * (long *) var_val;
          break;
        case FREE:
	break;
        case ACTION:
			system("/sbin/sysreboot");
     
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_wapiConfigReboot(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
    
    static oid      objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
    size_t   objid_snmptrap_len = OID_LENGTH(objid_snmptrap);
    netsnmp_variable_list * var_list = NULL;
    
    static oid      objid_sendoid[] = { 1,3,6,1,4,1,31656,2,3,4,0,2,11,0 };
    char trapStr[]="reboot.";
    AAT aat;
    prop_data properties[KEYS_MAX];
    int prop_count=0;
    char ap_parameter[20];
     time_t nowTimes;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  	  
        case RESERVE2:
         //  size  = var_val_len;
         // value = * (long *) var_val;
          break;
        case FREE:
          break;
        case ACTION:

 	   time(&nowTimes);	  
	   bzero(ap_parameter,20);
	   prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	   get_prop("LAN_IP",ap_parameter,properties,prop_count);
	   free_prop(properties,prop_count);
	   memset(&aat,0,sizeof(aat));
	   set_alarm( &aat,ALARM_ID_WARM_START,trapStr);
       send_trap_string_notification(&aat);
	   
      strcpy(scr_file, AP_REBOOT_SCR);
	  aargv[0] = scr_file;
	  aargv[1] = NULL;
	  if(*(unsigned long *) var_val == 0)
	  break;
	  pid =fork();
	  if(pid == 0)
	  {
	     sleep(2);
	     execv(aargv[0],aargv);
	     _exit(0);
	  }
	  else if(pid > 0)
	  {
	  }
	  else
	  return SNMP_ERR_GENERR;	

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:

          break;
    }
    return SNMP_ERR_NOERROR;
    
}

int
write_alarmEliminateTimes(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiConfigRtsThreshold(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size;
    int result;
    char temp[100];
    int pid;
    static char scr_file[256];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	  if((*(unsigned long *) var_val < 0) || (*(unsigned long *) var_val > 2347))
	      return SNMP_ERR_WRONGVALUE;
          break;

        case RESERVE2:
        //  size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_RTS",temp);
		  
          strcpy(scr_file, WIRELESS_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
              return SNMP_ERR_GENERR;
		  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
	
}


void  register_callback()
{
    AAT aat;
    memset(&aat,0,sizeof(aat));
    time_t nowTimes;
    time(&nowTimes);
   	set_alarm( &aat,ALARM_ID_KEEP_ALIVE_TRAP,"inspected  trap  channels");	
   	send_trap_string_notification(& aat) ;
}


static oid    Tnotification_alarmID[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,1};
static oid    Tnotification_alarmName[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,2} ;
static oid    Tnotification_alarmLevel[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,3} ;
static oid    Tnotification_alarmType[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,4} ;
static oid    Tnotification_alarmReasonId[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,5};
static oid    Tnotification_alarmReason[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,6};
static oid    Tnotification_alarmCreatTimes[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,7};
static oid    Tnotification_alarmState[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,8} ;
static oid    Tnotification_alarmHeading[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,9} ;
static oid    Tnotification_alarmContent[]={1,3,6,1,4,1,31656,2,3,4,0,8,3,1,10};



void set_alarm1( AAT * aat,int id , char *name, 
  			 int levelId, int typeId,
			 int reasonId, char *reason, 
  			 time_t ctime, int   state, 
			 char *head,  char *content)
{
    aat->alarmID=id ;
    strcpy(aat->alarmName,name ); 
	
	if(levelId<=5){
		aat->alaLevel.alarmlevelId=levelId; 
    	strcpy(aat->alaLevel.alarmlevelName,alarmLevelName[aat->alaLevel.alarmlevelId]);
	}
	
	if(typeId<=5){
		aat->alaType.alarmTypeId=typeId; 
    	strcpy(aat->alaType.alarmTypeName,alarmTypeName[aat->alaType.alarmTypeId]); 
	}
    aat->alarmReasonId=reasonId;
	strcpy(aat->alarmReason,reason);
    aat->alarmCreatTimes=ctime;
    aat->alarmState=state;
    strcpy(aat->alarmHeading, head );
    strcpy(aat->alarmContent, content ); 
}

void set_alarm( AAT *aat,int id,char *message){

    time_t nowTimes;

	switch(id) {
    case ALARM_ID_WARM_START:
		time(&nowTimes);
		set_alarm1(aat,id,"WarmStart",1,1,98,"Ap Device ReStart",\
			                   nowTimes,1,"WarmStart",message);
      	break;
    case ALARM_ID_IP_CHANGED:
		time(&nowTimes);
		set_alarm1(aat,id,"IpChanged",2,3,10,"IP address changed",\
			                   nowTimes,1,"IpChanged",message);
      	break;

    case ALARM_ID_CHANNEL_CHANGED:
		time(&nowTimes);
		set_alarm1( aat,id,"ChannelChanged",1,2,9,"Channel Changed",\
			                   nowTimes,1,"ChannelChanged",message);
       	break;

	case ALARM_ID_KEEP_ALIVE_TRAP:
		time(&nowTimes);
		set_alarm1( aat,id,"heartbeat",3,1,7,"Heart Beat",\
			                   nowTimes,1,"KeepAliveTrap",message);
    	break;
	
	case ALARM_ID_REMOT_UPGRADE:
		break;
	case ALARM_ID_WLAN_RF_A:
    	time(&nowTimes);
		set_alarm1( aat,id,"ApARF",3,2,27,"Changed ARF",\
			                   nowTimes,1,"ApARF",message);
		break;
	case ALARM_ID_WLAN_RF_B:
		time(&nowTimes);
		set_alarm1( aat,id,"ApBRF",3,2,28,"Changed BRF",\
			                   nowTimes,1,"ApBRF",message);
     	break;  
	case ALARM_ID_WIFI0_USER_NUM:
		time(&nowTimes);
		set_alarm1( aat,id,"chStatsNumStations",3,1,29,"Wifi0 User Num",\
			                   nowTimes,1,"chStatsNumStations",message);
		break; 
	case ALARM_ID_WIFI1_USER_NUM:
		time(&nowTimes);
		set_alarm1( aat,id,"chStatsNumStations",3,1,30,"Wifi1 User Num",\
			                   nowTimes,1,"chStatsNumStations",message);
		break; 

	case ALARM_ID_FUT:	
		time(&nowTimes);
    	set_alarm1(aat,id,"ForbiddenUserInroad",2,2,31,"NusafecertUser ForbiddenInroad",\
				          nowTimes,1,"ForbiddenUserInroad",message);            
         			
    	break;
	case ALARM_ID_PA:
		time(&nowTimes);
    	set_alarm1(aat,id,"PlaybackAttack",2,2,32,"STA Playback Attack",\
				              nowTimes,1,"PlaybackAttack",message);            
            		
    	break;
	case ALARM_ID_JA:
		time(&nowTimes);
    	set_alarm1(aat,id,"JuggleAttack",2,2,33,"wapialarmJuggleAttack",\
				                    nowTimes,1,"wapialarmJuggleAttack",message);            
           		
    	break;
	case ALARM_ID_NTP:
		time(&nowTimes);
    	set_alarm1(aat,id,"TimeSyncFailed",3,4,34,"Ntp Time Sync Failed",\
				                 nowTimes,1,"TimeSyncFailed",message);            
           		
    		break;
	case ALARM_ID_CHANNEL_DISTURB:
	 	time(&nowTimes);
        set_alarm1(aat,id,"alarm_channel", 3, 2, 35, "alarmChannelDisturb",\
		  	                   nowTimes, 1, "alarmChannelDisturb", message);            
         	
    	break;
	
	case ALARM_ID_SECURITY_GRADE_DEBASE_ATTACK:
		time(&nowTimes);
    	set_alarm1(aat,id,"securityGradeDebaseAttack",3,1,36,"securityGradeDebaseAttack",\
				               nowTimes,1,"securityGradeDebaseAttack",message);            
           		
    	break;
	case ALARM_ID_MAC_CHANGED_DIRECTIONAL_ATTACK:
		time(&nowTimes);
    	set_alarm1(aat,id,"macChanagedDirectionalAttack",3,1,37,"macChanagedDirectionalAttack",\
				               nowTimes,1,"macChanagedDirectionalAttack",message);            
            		
    	break;
	case ALARM_ID_SUPPLY_CHANNEL_TOO_LOWER:
		time(&nowTimes);
    	set_alarm1(aat,id,"supplyChannelTooLower",5,5,38,"supply Channel Too Lower",\
				              nowTimes,1,"supplyChannelTooLower",message);   		
    	break;
	case ALARM_ID_AP_NOT_ADD_NEW_STA:
		time(&nowTimes);
    	set_alarm1(aat,id,"apNotAddNewSta",4,5,39,"ap Not Add New Sta",\
				                   nowTimes,1,"apNotAddNewSta",message);            
           		
    	break;
	case ALARM_ID_RADIUS_SERVER_NOT_CONNECT_AUTH:
		time(&nowTimes);
    	set_alarm1(aat,id,"radiusServerNotConnectAuth",3,1,40,"radiusServer Not Connect Auth",\
				         nowTimes,1,"radiusServerNotConnectAuth",message);            
           		
    	break;
	case ALARM_ID_RADIUS_SERVER_NOT_CONNECT_ACCOUNT:
		time(&nowTimes);
    	set_alarm1(aat,id,"radiusServerNotConnectAccount",3,2,41,"radiusServer Not Connect Account",\
				          nowTimes,1,"radiusServerNotConnectAccount",message);            
           		
    	break;
	case ALARM_ID_FLASH_WRITEERROR:
		time(&nowTimes);
		set_alarm1(aat,id,"FlashWriteError",1,4,42,"Flash Write Error",\
			                   nowTimes,1,"FlashWriteError",message);
        break;
	case ALARM_ID_FIND_UNSAFE_AP:
		time(&nowTimes);
    	set_alarm1(aat,id,"findNuSafeAp",4,2,43,"find NuSafe Ap",\
				                    nowTimes,1,"findNuSafeAp",message);            
            		
    	break;
	case ALARM_ID_CHANNEL_DISTURB_DEVICE:
		time(&nowTimes);
    	set_alarm1(aat,id,"disturbDevice",2,2,44,"Channel by Device disturb",\
				                    nowTimes,1,"disturbDevice",message);            
            		
    	break;
	case ALARM_ID_CHANNEL_DISTURB_STA:
		time(&nowTimes);
    	set_alarm1(aat,id,"disturbStation",3,2,45,"Channel by Station disturb",\
				                    nowTimes,1,"disturbStation",message);            
            		
    	break;
	case ALARM_ID_CHANNEL_DISTURB_AP:
		time(&nowTimes);
    	set_alarm1(aat,id,"disturbAp",1,2,46,"Channel by Ap disturb",\
				                    nowTimes,1,"disturbAp",message);            
            		
    	break;
    default:
      ERROR_MSG("");
    }
	
}



int send_trap_string_notification(AAT * aat)
{
    int ret=0;
    int tmp=0;
    static oid      objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };  
    size_t   objid_snmptrap_len = OID_LENGTH(objid_snmptrap);
    netsnmp_variable_list * var_list = NULL;
    char temp[256];

#if 0  //modify  by sunyushuang0418
    static oid    	notification_oid98[] ={ 1,3,6,1,4,1,4000,100,2,11,0}; //reboot
    static oid 		notification_oid3[] ={ 1,3,6,1,4,1,4000,100,2,1,0};//lanip
    static oid 		notification_oid9[] ={ 1,3,6,1,4,1,4000,100,17,1,1,1,0}; //channal
    static oid 		notification_oid26[] ={ 1,3,6,1,4,1,4000,100,6,2,0 }; //upgrade
    static oid 		notification_oid27[] ={ 1,3,6,1,4,1,4000,100,2,59,0 }; //ARF  
    static oid 		notification_oid28[] ={ 1,3,6,1,4,1,4000,100,2,60,0 }; //BRF  
    static oid 		notification_oid29[] ={ 1,3,6,1,4,1,4000,100,17,1,1,2,1 }; //A channal users trap
    static oid 		notification_oid30[] ={ 1,3,6,1,4,1,4000,100,17,1,1,2,2 }; //B channal users trap
    static oid 		notification_oid31[] ={ 1,3,6,1,4,1,4000,100,8,4 }; //wapialarmForbiddenUserInroad
    static oid 		notification_oid32[] ={ 1,3,6,1,4,1,4000,100,8,5 }; //wapialarmPlaybackAttack
    static oid 		notification_oid33[] ={ 1,3,6,1,4,1,4000,100,8,6 }; //wapialarmJuggleAttack
    static oid 		notification_oid34[] ={ 1,3,6,1,4,1,4000,100,8,7 }; //wapialarmJuggleAttack
    static oid 		notification_oid35[] ={ 1,3,6,1,4,1,4000,100,8,8 }; //alarmChannelDisturb  /* #0045-2 guoxd_003 20081117 add+ */
    static oid 		notification_oid36[] ={ 1,3,6,1,4,1,4000,100,8,9 }; //securityGradeDebaseAttack  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid37[] ={ 1,3,6,1,4,1,4000,100,8,10 }; //macChanagedDirectionalAttack  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid38[] ={ 1,3,6,1,4,1,4000,100,8,11 }; //supplyChanneltoolower  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid39[] ={ 1,3,6,1,4,1,4000,100,8,12 }; //apnotaddnewSta  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid40[] ={ 1,3,6,1,4,1,4000,100,8,13 }; //radiusServerNotConnectAuth  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid41[] ={ 1,3,6,1,4,1,4000,100,8,14 }; //radiusServerNotConnectAccount  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid42[] ={ 1,3,6,1,4,1,4000,100,8,15 }; //flashwritefail  /* #0045-2 piyp 20081205 add+ */
	static oid 		notification_oid43[] ={ 1,3,6,1,4,1,4000,100,8,16 }; //findNuSafeAp  /* #0045-2 piyp 20090113 add+ */
	static oid 		notification_oid44[] ={ 1,3,6,1,4,1,4000,100,8,17 }; //disturbDevice  /* #0045-2 piyp 20090113 add+ */
	static oid 		notification_oid45[] ={ 1,3,6,1,4,1,4000,100,8,18 }; //disturbStation  /* #0045-2 piyp 20090113 add+ */
	static oid 		notification_oid46[] ={ 1,3,6,1,4,1,4000,100,8,19 }; //disturbAp  /* #0045-2 piyp 20090113 add+ */

#endif


    static oid    	notification_oid98[] ={ 1,3,6,1,4,1,31656,2,3,4,0,2,11,0}; //reboot
    static oid 		notification_oid3[] ={ 1,3,6,1,4,1,31656,2,3,4,0,2,1,0};//lanip
    static oid 		notification_oid9[] ={ 1,3,6,1,4,1,31656,2,3,4,0,17,1,1,1,0}; //channal
    static oid 		notification_oid26[] ={ 1,3,6,1,4,1,31656,2,3,4,0,6,2,0 }; //upgrade
    static oid 		notification_oid27[] ={ 1,3,6,1,4,1,31656,2,3,4,0,2,59,0 }; //ARF  
    static oid 		notification_oid28[] ={ 1,3,6,1,4,1,31656,2,3,4,0,2,60,0 }; //BRF  
    static oid 		notification_oid29[] ={ 1,3,6,1,4,1,31656,2,3,4,0,17,1,1,2,1 }; //A channal users trap
    static oid 		notification_oid30[] ={ 1,3,6,1,4,1,31656,2,3,4,0,17,1,1,2,2 }; //B channal users trap
    static oid 		notification_oid31[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,4 }; //wapialarmForbiddenUserInroad
    static oid 		notification_oid32[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,5 }; //wapialarmPlaybackAttack
    static oid 		notification_oid33[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,6 }; //wapialarmJuggleAttack
    static oid 		notification_oid34[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,7 }; //wapialarmJuggleAttack
    static oid 		notification_oid35[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,8 }; //alarmChannelDisturb  /* #0045-2 guoxd_003 20081117 add+ */
    static oid 		notification_oid36[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,9 }; //securityGradeDebaseAttack  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid37[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,10 }; //macChanagedDirectionalAttack  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid38[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,11 }; //supplyChanneltoolower  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid39[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,12 }; //apnotaddnewSta  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid40[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,13 }; //radiusServerNotConnectAuth  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid41[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,14 }; //radiusServerNotConnectAccount  /* #0045-2 piyp 20081124 add+ */
	static oid 		notification_oid42[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,15 }; //flashwritefail  /* #0045-2 piyp 20081205 add+ */
	static oid 		notification_oid43[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,16 }; //findNuSafeAp  /* #0045-2 piyp 20090113 add+ */
	static oid 		notification_oid44[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,17 }; //disturbDevice  /* #0045-2 piyp 20090113 add+ */
	static oid 		notification_oid45[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,18 }; //disturbStation  /* #0045-2 piyp 20090113 add+ */
	static oid 		notification_oid46[] ={ 1,3,6,1,4,1,31656,2,3,4,0,8,19 }; //disturbAp  /* #0045-2 piyp 20090113 add+ */






	if (aat->alarmID==ALARM_ID_KEEP_ALIVE_TRAP){
           snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              sizeof(objid_snmptrap) / sizeof(oid),
                              ASN_OBJECT_ID, 
			      (u_char *) notification_oid,
                              sizeof(notification_oid) );			
	}

 	else if(aat->alarmID==ALARM_ID_WARM_START) {//reboot
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                                                             sizeof(objid_snmptrap) / sizeof(oid),
                                                             ASN_OBJECT_ID, 
			                                        (u_char *) notification_oid98,
                                                             sizeof(notification_oid98) );
 	}
 	else if(aat->alarmID==ALARM_ID_IP_CHANGED) {//lanip
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid3,
                              				     sizeof(notification_oid3) );
 	}
  	else if (aat->alarmID==ALARM_ID_CHANNEL_CHANGED) {//channal
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid9,
                              				     sizeof(notification_oid9) );
 	}
	else if (aat->alarmID==ALARM_ID_WLAN_RF_A) {//ARF
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid27,
                              				     sizeof(notification_oid27) );
 	}
	else if (aat->alarmID==ALARM_ID_WLAN_RF_B) {//BRF
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid28,
                              				     sizeof(notification_oid28) );
 	}
 	else if (aat->alarmID==ALARM_ID_WIFI0_USER_NUM) {// A channal users 		
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid29,
                              				     sizeof(notification_oid29) );
 	}
 	else if (aat->alarmID==ALARM_ID_WIFI1_USER_NUM) {// B channal users 
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid30,
                              				     sizeof(notification_oid30) );
 	}
	else if (aat->alarmID==ALARM_ID_FUT) {//  wapialarmForbiddenUserInroad
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid31,
                              				     sizeof(notification_oid31) );
 	}
	else if (aat->alarmID==ALARM_ID_PA) {//  wapialarmPlaybackAttack
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid32,
                              				     sizeof(notification_oid32) );
 	}

	
	else if (aat->alarmID==ALARM_ID_JA) {//  wapialarmJuggleAttack
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid33,
                              				     sizeof(notification_oid33) );
 	}

	

	
    else if (aat->alarmID==ALARM_ID_NTP) {// wapialarmJNtp
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid34,
                              				     sizeof(notification_oid34) );
 	}
	else if (aat->alarmID==ALARM_ID_REMOT_UPGRADE) {//upgrade
	    tmp=atoi(aat->alarmContent);
	    if(tmp<1 || tmp>6)
	        return ;
	    else
	        notification_oid26[10]=tmp;	  
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid26,
                              				     sizeof(notification_oid26) );
#if 0		
           snmp_varlist_add_variable(&var_list,Tnotification_alarmContent,
                              sizeof(Tnotification_alarmContent) / sizeof(oid),
                              ASN_OCTET_STR,
                              (u_char *) (aat->alarmHeading),
                              strlen(aat->alarmHeading));
	    goto  upgrape;
#endif	
 	}
     else if (aat->alarmID == ALARM_ID_CHANNEL_DISTURB) {/* alarmChannelDisturb */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid35,
                              				     sizeof(notification_oid35) );
 	}
    else if (aat->alarmID == ALARM_ID_SECURITY_GRADE_DEBASE_ATTACK) {/* securityGradeDebaseAttack */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid36,
                              				     sizeof(notification_oid36) );
 	}
    else if (aat->alarmID == ALARM_ID_MAC_CHANGED_DIRECTIONAL_ATTACK) {/* macChanagedDirectionalAttack */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid37,
                              				     sizeof(notification_oid37) );
 	}
	else if (aat->alarmID == ALARM_ID_SUPPLY_CHANNEL_TOO_LOWER) {/* supplyChannelToolower */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid38,
                              				     sizeof(notification_oid38) );
 	}
    else if (aat->alarmID == ALARM_ID_AP_NOT_ADD_NEW_STA) {/* apnotaddnewsta */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid39,
                              				     sizeof(notification_oid39) );
    }
	else if (aat->alarmID == ALARM_ID_RADIUS_SERVER_NOT_CONNECT_AUTH) {/* radiusServerNotConnectAuth */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid40,
                              				     sizeof(notification_oid40) );
 	}
    else if (aat->alarmID == ALARM_ID_RADIUS_SERVER_NOT_CONNECT_ACCOUNT) {/* radiusServerNotConnectAccount */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid41,
                              				     sizeof(notification_oid41) );
 	}
	else if (aat->alarmID == ALARM_ID_FLASH_WRITEERROR) {/* flashwritefail */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid42,
                              				     sizeof(notification_oid42) );
 	}
	else if (aat->alarmID == ALARM_ID_FIND_UNSAFE_AP) {/* findNuSafeAp */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid43,
                              				     sizeof(notification_oid43) );
 	}
	else if (aat->alarmID == ALARM_ID_CHANNEL_DISTURB_DEVICE) {/* disturbDevice */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid44,
                              				     sizeof(notification_oid44) );
 	}
	else if (aat->alarmID == ALARM_ID_CHANNEL_DISTURB_STA) {/* disturbStation */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid45,
                              				     sizeof(notification_oid45) );
 	}
	else if (aat->alarmID == ALARM_ID_CHANNEL_DISTURB_AP) {/* disturbAp */
    	    snmp_varlist_add_variable(&var_list, objid_snmptrap,
                              				     sizeof(objid_snmptrap) / sizeof(oid),
                              				     ASN_OBJECT_ID, 
			      					     (u_char *) notification_oid46,
                              				     sizeof(notification_oid46) );
 	}
	else {
		return -1 ;
	}
    memset(temp,0,256);
    sprintf(temp,"%d",aat->alarmID);
    snmp_varlist_add_variable(&var_list, Tnotification_alarmID,
                              sizeof(Tnotification_alarmID) / sizeof(oid),
                              ASN_OCTET_STR,
                              (u_char *) temp,
                              strlen(temp));
/* name */
    snmp_varlist_add_variable(&var_list, Tnotification_alarmName,
                              sizeof(Tnotification_alarmName) / sizeof(oid),
                              ASN_OCTET_STR,
                              (u_char *) (aat->alarmName),
                              strlen(aat->alarmName));

    
    //level 
    memset(temp, 0, sizeof(temp));
    sprintf(temp, "%d", aat->alaLevel.alarmlevelId);
    snmp_varlist_add_variable(&var_list, Tnotification_alarmLevel,
                              sizeof(Tnotification_alarmLevel) / sizeof(oid),
                              ASN_OCTET_STR,
                              (u_char *) temp,
                              strlen(temp));
    //tpye 
    memset(temp, 0, sizeof(temp));
    sprintf(temp, "%d", aat->alaType.alarmTypeId);
    snmp_varlist_add_variable(&var_list, Tnotification_alarmType,
                              sizeof(Tnotification_alarmType) / sizeof(oid),
                              ASN_OCTET_STR,
                              (u_char *) temp,
                              strlen(temp));

#if 0	
	//modify by piyp 2008-12-20
	 /* level */
    snmp_varlist_add_variable(&var_list, Tnotification_alarmLevel,
                              sizeof(Tnotification_alarmLevel) / sizeof(oid),
                              ASN_OCTET_STR,
                              (u_char *) (alarmLevelName[aat->alaLevel.alarmlevelId]),
                              strlen(alarmLevelName[aat->alaLevel.alarmlevelId]));
    /* tpye */
    snmp_varlist_add_variable(&var_list, Tnotification_alarmType,
                              sizeof(Tnotification_alarmType) / sizeof(oid),
                              ASN_OCTET_STR,
                              (u_char *) (alarmTypeName[aat->alaType.alarmTypeId]),
                              strlen(alarmTypeName[aat->alaType.alarmTypeId]));

#endif

	 /* reasonId */
    snmp_varlist_add_variable(&var_list,Tnotification_alarmReasonId,
                              sizeof(Tnotification_alarmReasonId) / sizeof(oid),
                              ASN_INTEGER,
                              (u_char *) &(aat->alarmReasonId),
                              sizeof(aat->alarmReasonId));
    /* reason */
    snmp_varlist_add_variable(&var_list,Tnotification_alarmReason,
                              sizeof(Tnotification_alarmReason) / sizeof(oid),
                              ASN_INTEGER,
                              (u_char *) &(aat->alarmReason),
                              sizeof(aat->alarmReason));
    /* cTimes*/
    snmp_varlist_add_variable(&var_list, Tnotification_alarmCreatTimes,
                              sizeof(Tnotification_alarmCreatTimes) / sizeof(oid),
                              ASN_INTEGER,
                              (u_char *) &(aat->alarmCreatTimes),
                              sizeof(aat->alarmCreatTimes));
#if 0
    /* eTimes */
    snmp_varlist_add_variable(&var_list, Tnotification_alarmEliminateTimes,
                              sizeof(Tnotification_alarmEliminateTimes) / sizeof(oid),
                              ASN_INTEGER,
                              (u_char *) &(aat->alarmEliminateTimes),
                              sizeof(aat->alarmEliminateTimes));
#endif
    /* state */
    snmp_varlist_add_variable(&var_list, Tnotification_alarmState,
                              sizeof(Tnotification_alarmState) / sizeof(oid),
                              ASN_INTEGER,
                              (u_char *) &(aat->alarmState),
                              sizeof(aat->alarmState));
    /* head */
    snmp_varlist_add_variable(&var_list,Tnotification_alarmHeading,
                              sizeof(Tnotification_alarmHeading) / sizeof(oid),
                              ASN_OCTET_STR,
                              (u_char *) (aat->alarmHeading),
                              strlen(aat->alarmHeading));
//#endif
     snmp_varlist_add_variable(&var_list,Tnotification_alarmContent,
                              sizeof(Tnotification_alarmContent) / sizeof(oid),
                              ASN_OCTET_STR,
                              (u_char *) (aat->alarmContent),
                              strlen(aat->alarmContent));
upgrape:
    DEBUGMSGTL(("example_notification", "sending the trap\n"));
    send_v2trap(var_list);

    //other trap sended, so restart 0 trap!
    if( aat->alarmID!=0 ){
		if( alarmFlag != 0 ){
    	     		snmp_alarm_unregister(alarmId);	             
	     		alarmId=snmp_alarm_register(alarmTimes,  //10  /* seconds */
                        SA_REPEAT,      /* repeat (every 30 seconds). */
                        register_callback,      /* our callback */
                        NULL );    /* no callback data needed */
    		}
    }

    /* free the created notification variable list  */
    DEBUGMSGTL(("example_notification", "cleaning up\n"));
    snmp_free_varbind(var_list);
    var_list=NULL;
}

//add by piyp 2008-12-03
int get_trap_ip(char *filename,char *ip)
{
        FILE* fidIn=NULL;
        char line[255];
        char strTemp1[255];
        char strTemp2[255];
        char strTemp3[255];
        char strTemp4[255];
        char key[255];
		char *p;

		p=ip;
        strcpy(key,"trap2sink");
		
        if ((fidIn=fopen(filename,"r"))==NULL)
                return -1;
		
        while(!feof(fidIn))
        {
			if( fgets(line,255,fidIn)!=NULL){
                if (strstr(line,key)!=0)
                {
                     sscanf(line,"%s %s %s %s",strTemp1,strTemp2,
                                        strTemp3,strTemp4);
					 printf("strTemp2 = %s\n",strTemp2);
					 memcpy(p,strTemp2,20);
					 p += 20;
                }
			}
        }
		printf("ip = %s\n",ip);
        fclose(fidIn);
       
        return 1;
}

int set_trap_ip(char *filename,char *ip, int index)
{
        FILE* fidIn=NULL;
        FILE* fidOut=NULL;
		FILE* fid=NULL;
        char line[255],line1[255];
        char strTemp1[128];
        char strTemp2[128];
        char strTemp3[128];
        char strTemp4[128];
        char key[128];
        char strTemp[255]; 
		char tmpfile[512];

		memset( line1, '\0', 255 );
		strcpy(key,"trap2sink");
		int count=1;
        if ((fidIn=fopen(filename,"r"))==NULL)
                return -1;

		strcpy(tmpfile,filename);	
		strcat(tmpfile,".snmp");

        if ((fidOut=fopen(tmpfile,"w"))==NULL) 
		{
			fclose(fidIn);
			return -1;
		}

		while(!feof(fidIn))
		{
			memset( line, '\0', 255 );
			
			if(fgets(line,255,fidIn)!=NULL){
    			if (strstr(line,key)==0 && strstr(line,"")!=0)
				{	
					fprintf(fidOut,"%s",line);
					
				}
				else {			
					if(index==count){
						sscanf(line,"%s %s %s %s",strTemp1,strTemp2,
										   strTemp3,strTemp4);
						strcpy(strTemp, strTemp1);
   						strcat(strTemp, " ");
						strcat(strTemp, ip);
						strcat(strTemp, " ");
						strcat(strTemp, strTemp3);
						strcat(strTemp, " ");
						strcat(strTemp, strTemp4);
						strcat(strTemp, "\n");	
						fprintf(fidOut,"%s",strTemp);
					}else if(strstr(line,"")!=0){
						sprintf(line1,"%s",line);
						fprintf(fidOut,"%s",line1);
					}
					count++;
				}	
			}
   		}
		
		fclose(fidIn);
		fclose(fidOut);
		unlink(filename);
		rename(tmpfile,filename);
		return 0;
}
int
write_wapiApSoftDebug(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    struct alarmTable  at;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
         // size  = var_val_len;
         // value = * (long *) var_val;
          break;
        case FREE:
          break;
        case ACTION:
         value = * (long *) var_val;
	  wapiApSoftDebug=value;
          printf("wapiapsoftdebug=%d\n",value); 
	  if(value==1){
        write_share_memory(DEAMON_PATH,sizeof(AAT),&at);
	  }
	  else if (value ==2){
 	    write_share_memory(DEAMON_PATH,sizeof(AAT),&at);
	  }
	  else if  (value == 3){
		write_share_memory(DEAMON_PATH,sizeof(AAT),&at);
	  }
	  else {
		write_share_memory(DEAMON_PATH,sizeof(AAT),&at);
	  }
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
/*********************************************************/
/* get mac addr*/
int wlan_getioctl_dev_addr(char *dev_mac,char *ifname)
{
        struct ifreq ifr;  /* Socket stuff */
        int fd;
        int ioctl_type=SIOCGIFHWADDR;
        if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) > -1)
        {
                strcpy(ifr.ifr_name, ifname);
                ifr.ifr_hwaddr.sa_family = AF_INET;

                if (ioctl(fd, ioctl_type, &ifr) == 0)
                {
                    memcpy(dev_mac, ifr.ifr_hwaddr.sa_data, 6);

                    *(dev_mac+6) = '\0';
			close(fd);
			return 1 ;
                }
                else{
		      close(fd);
                    return -1;
                }
        }
	else {
	    close(fd);
           return -1;
	}
}
	
/* get AP Association parameter */

int getioctl_ap_assoc_parameter(struct wapiapUserAsso *iua , 
				char * ifname )
{
	int c, len;
        struct ifreq ifr;
	int ret ;
        
        struct ieee80211_stats stats;

	ret = socket(AF_INET, SOCK_DGRAM, 0);
	if (ret < 0)
	{
	    printf(" socket error in getioctl_ap_assoc_parameter().\n");
	    return -1;
	}
	strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));

	ifr.ifr_data = (caddr_t) &stats;
	if (ioctl(ret, SIOCG80211STATS, &ifr) < 0)
	{
	    printf("ioctl error getioctl_ap_assoc_parameter().\n");
	    close(ret);
	    return -2;
	}

	iua->failCount=(stats.is_rx_assoc_bss)+(stats.is_rx_assoc_notauth)+
			(stats.is_rx_assoc_capmismatch)+(stats.is_rx_assoc_norate)+
			(stats.is_rx_assoc_badwpaie) ;
	close(ret);
	return 1;
}
int interface_wlan_scan(char * name)
{
    FILE *devin;
    int i,flag;
    char line[256];
    char *p,*q;
    flag=0;
    q=name;
    if (!(devin = fopen("/proc/net/wireless", "r"))) {       
        printf("cannot open /proc/net/wireless \n");
        return 0;
    }
    else{
        fgets(line, sizeof(line), devin);
        fgets(line, sizeof(line), devin);
	while (fgets(line, sizeof(line), devin)) {
 	    p=strstr(line, "ath");  // by sunyushuang0320
	    if(p!=NULL)
	    {
	        while(*p!=':')
	        { *q=*p; q++;p++;}
	        *q=':';
	        q++;	
		flag++;
            }	
	}
	 fclose(devin);
	return flag ;
   }		
}
struct wapiapUserAsso * get_ap_assoc(int *num)
{
	int ret,tmp,i;
        struct wapiapUserAsso *head,*pt,*pi;
	char ifname[10]; 
	char indexname[128];
	char *pe,*ps;
        ret=interface_wlan_scan(indexname);
	*num=ret;
	printf("interface=%s\n",indexname);
	if(ret==0){
	   printf("not ath interface. \n");// by sunyushuang0321
	   return NULL ;
        }
	head=(struct wapiapUserAsso *)malloc(sizeof(struct wapiapUserAsso));
	pt=head;
	pe=indexname;
	ps=indexname;
        for(i=0;i<ret;i++) {
	    ps=strchr(pe,':');
	    if(ps==NULL) 
		return 0;
	    memcpy(ifname,pe,(ps-pe));    
	    ifname[ps-pe]='\0';
            printf("ifname=%s\n",ifname);
	    ps=ps+1;
	    pe=ps;
	    
            tmp=getioctl_ap_assoc_parameter( pt , ifname );
	    if(tmp==1){
	        pt->ifindex=i;	
		strcpy(pt->ifname,ifname);
	    }
	    else {
		printf(" return error at  getioctl_ap_assoc_parameter().\n");
	    	return NULL;		
	    }
	    printf("\tindex=%d\n",pt->ifindex);
	    printf("\tassoCount=%d\n",pt->assoCount);
	    printf("\tfailCount=%d\n",pt->failCount);
	    printf("\treassoCount=%d\n",pt->reassoCount);
	    pi=(struct wapiapUserAsso *)malloc(sizeof(struct wapiapUserAsso));  
	    pt->next=pi;
	    pt=pt->next;
        }
	pt->next=NULL;
	return (head);

}
int  free_ap_assoc(struct wapiapUserAsso * head)
{
  struct wapiapUserAsso * pt;
  while(head) {
  pt=head;
  head=head->next;
  free(pt);	
  }
  if(!head) return 1;
  else return 0;
}

void  *read_share_memory(const unsigned char *shm_param, 
			 const size_t size, 
			 AAT * aat )
{
        int shm_id,i;
        key_t key;
        AAT *p_map;
        key = ftok(shm_param,1);
        if(key == -1)
                perror("ftok error");
        shm_id = shmget(key,size,IPC_CREAT|0777);
        if(shm_id == -1)
        {
                perror("shmget error");
                return;
        }
        p_map = (AAT*)shmat(shm_id,NULL,0);
        if(p_map == (void *)-1)
        {
          perror("shmat error:");
          return 0;
        }
	memcpy(aat,p_map,size);
        if(shmdt(p_map) == -1)

                perror(" detach error ");
}


void * write_share_memory(const unsigned char *shm_param, 
			  const size_t size,
			  AAT * aat )
{
        int shm_id,i;
        key_t key;
        char temp;
        AAT *p_map;

        if (shm_param == NULL)
                return NULL;

        key = ftok(shm_param,1);
        if(key==-1)
        {
                perror("ftok error");
                return 0;
        }
        shm_id=shmget(key,size,IPC_CREAT|0777);
        if(shm_id==-1)
        {
                perror("shmget error");
                return 0;
        }
        p_map=(AAT*)shmat(shm_id,NULL,0);
        if(p_map == (void *)-1)
        {
          perror("shmat error:");
          return 0;
        }
	memcpy(p_map,aat,size);

        if(shmdt(p_map)==-1)
           perror(" detach error ");
}



/*****************************************************/

int write_wapiConfigWapiState(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    unsigned char temp[32];
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   /* #0045-2 guoxd_002 20081109 add start */	  
   	   value = * (unsigned long *) var_val ;
	   if((value != 0) && (value != 1))
		return SNMP_ERR_WRONGVALUE;
	   /* #0045-2 guoxd_002 20081109 add end */	  
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   /* #0045-2 guoxd_002 20081109 modify start */
  	   value = * (unsigned long *) var_val ;
	   memset(temp, 0, sizeof(temp));
	   if (value == 1)
	   {
	   	value = 1;	/* WAPI */
		system("killall wapid && /usr/sbin/wapid");
	   }
	   else
	   {
	   	value = 2;	/* 802.11i */   
		system("killall wapid");
	   }
          sprintf(temp,"%ld", value);
	   /* value 1, wapid; 2, 802.11i */
          save_global_conf(SEP_EQUAL, AP_BASE_CONF, "", "PRODUCT_SEC", temp);

	   /* reboot the system */
	  // system("/sbin/reboot");		  
	   /* #0045-2 guoxd_002 20081109 modify end */
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int write_wapiConfigMultiModeAccessState(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	 
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiConfigMultiModeAccessState=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int write_wapiConfigBandwidthQos(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0) ||(value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiConfigBandwidthQos=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int write_wapiConfigUsersQos(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiConfigUsersQos=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
int write_wapiBSSIDMaxUser(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[10];
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0) ||(value >32) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_MAXSTA",temp);

          strcpy(scr_file, AP_REBOOT_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
          return SNMP_ERR_GENERR;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiApUserThresholdCfg(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[10];
    int size,pid;
    static char scr_file[256];
    static char * aargv[2];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >128) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,WIRELESS_CONF,"","WLAN0_MAXSTA",temp);

          strcpy(scr_file, AP_REBOOT_SCR);
          aargv[0] = scr_file;
          aargv[1] = NULL;
          pid =fork();
          if(pid == 0)
          {
             sleep(2);
             execv(aargv[0],aargv);
             _exit(0);
          }
          else if(pid > 0)
          {
          }
          else
          return SNMP_ERR_GENERR;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiESSIDMaxUser(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >128) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiESSIDMaxUser=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



int write_wapiServerURL(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    u_long i;
   static  char 	ap_parameter[256];
   static  char 	upgradefile[256],*up;
        switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 256) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:        
	   memcpy(ap_parameter,var_val,var_val_len);
	   ap_parameter[var_val_len]='\0' ;     

	   up=NULL;
	   up=strstr(ap_parameter,"ftp://");
	   if(up==NULL) {
		fprintf(stderr,"write to wapiServerURL: upgrade file error: ( ftp:// )\n");
		return SNMP_ERR_WRONGVALUE;
	   }
#if 0
          if(up!=ap_parameter){
		var_val_len=var_val_len-(up-ap_parameter);
              memcpy(ap_parameter,up,var_val_len);
	       var_val_len=var_val_len-(up-ap_parameter);
		ap_parameter[var_val_len]='\0' ; 
	   }
#endif

	   up=NULL;
	   up=strchr(ap_parameter,'@');
	   if(up==NULL) {
		fprintf(stderr,"write to wapiServerURL: upgrade file error:( @ )\n");
		return SNMP_ERR_WRONGVALUE;
	   }
#if 0	   
          up=ap_parameter+var_val_len;
	   while(*up!='\"'){
	   	ap_parameter[var_val_len]='\0';
	       var_val_len--;
	   }
#endif	   
	   up=ap_parameter+var_val_len;
	   while(1){
	   	
	   	if(*up=='@'){
			fprintf(stderr,"write to wapiServerURL: upgrade file error: ( @ / ) \n");
			return SNMP_ERR_WRONGVALUE;
	       }	
		if(*up=='/') { 
			up ++; 
			break;
		}
		up--;
	   }   
	   strcpy(upgradefile,up);
	   save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","URL", ap_parameter); 
	   save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","UPGRADE_NAME", upgradefile); 
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


#if  UPGRADE_SELECT_FLAG

int write_wapiStartUpgrade(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    u_long value,ret;
    char temp[256];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   value = * (long *) var_val ;
	   if(( value <0)||(value>1) )
		return SNMP_ERR_WRONGVALUE;
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:

	   bzero(temp, 10);
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","START_UPGRADE",temp);
        break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;

}

#endif

#ifndef   UPGRADE_SELECT_FLAG

int write_wapiStartUpgrade(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    u_long value,ret;
    char temp[256];
    static char *  aargv[3];
    char *trapStr[]={"","1","2","3","4","5","6"};
    AAT aat;
    prop_data properties[KEYS_MAX];
    int prop_count=0,pid1,pid2,sockfd;
    char ap_parameter[20],message[30],upgradefile[256],tempstr[256],*up;
     time_t nowTimes;
    struct sockaddr_in sin;
    int  sinlen;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   value = * (long *) var_val ;
	   if(( value != 1) )
		return SNMP_ERR_WRONGVALUE;
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:

	   bzero(temp, 10);
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","START_UPGRADE",temp);
	   printf("START_UPGRADE=%d    %s \n",*(unsigned long *) var_val,temp);
	   
	   bzero(ap_parameter,20);
	   bzero(upgradefile, 256);
	   bzero(tempstr, 256);
	   prop_count=load_prop(SEP_EQUAL,AP_BASE_CONF,properties);
	   get_prop("LAN_IP",ap_parameter,properties,prop_count);
	   get_prop("URL",tempstr,properties,prop_count);
	   free_prop(properties,prop_count);	
	   up=strstr(tempstr,"WAPI-AP");
	   if(up==NULL) {
		fprintf(stderr,"write to wapiPwlanAp: geting upgrade file error \n");
		return SNMP_ERR_WRONGVALUE;
	   }
	   strcpy(upgradefile,up);
	   printf("ungradefie name %s \n",upgradefile);
	   aargv[0]=AP_UPGRADE_SCR;
	   aargv[1]=upgradefile;
	   aargv[2]=NULL;

          /*****************************************************************************/
	   printf("\n********pid2************\n");
  	   pid2=fork();
  	   if(pid2==0){
	   	ret=open_socket_upgrade(&sockfd);
	   	if( ret!=1 ){
          		save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","START_UPGRADE","0");
			fprintf(stderr,"write to wapiPwlanAp: upgrade fail for opening socket \n");
			close(sockfd);
              	return SNMP_ERR_WRONGVALUE;
	   	}

	   	while(1){
              	sinlen=sizeof(sin);
			bzero(message, 30);
			recvfrom(sockfd,message,30,0,(struct sockaddr *)&sin,&sinlen);

			ret=analyze_AP_mess(message);
			if(ret<0)  {
				fprintf(stderr,"write to wapiPwlanAp: upgrade fail \n");
				close(sockfd);
              		return SNMP_ERR_WRONGVALUE;
			}
             		printf("\n upgrade message serial number  %d  \n",ret);
	      			memset(&aat,0,sizeof(aat));
             		time(&nowTimes);
					set_alarm1( & aat,ALARM_ID_REMOT_UPGRADE,ap_parameter,3,1,26,"upgrade ap",nowTimes,1,"upgrade ap",trapStr[ret]);           
             		send_trap_string_notification(&aat);

	       	if(ret==UPGRADE_ERR_GETFILE){
				fprintf(stderr,"write to wapiPwlanAp: upgrade fail  for geting  file \n");          				
			}	
	       	if (ret==UPGRADE_ERR_FILE){
				fprintf(stderr,"write to wapiPwlanAp: upgrade fail  for  file error \n");
				close(sockfd);
				_exit(0);             			
			}

	       	if (ret==UPGRADE_ERR_FAIL) {
				fprintf(stderr,"write to wapiPwlanAp: upgrade fail  for upgrade fail \n");
				close(sockfd);
				_exit(0);			
			}			
			if (ret==UPGRADE_FINISHED_REBOOT){
				save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","START_UPGRADE","0");
				_exit(0);	
				
			}
	   	}
	   
	  }	   
	  else if (pid2>0){	   	
	  }
	  else {
		return SNMP_ERR_GENERR;
	  }

         /**********************************************************************/
          printf("\n********pid1************\n");
          pid1 = fork();
          if (pid1 == 0)
          {   
             printf("\n begin  fork pid 1 \n");
             execv(aargv[0],aargv);
	      printf("\n end fork pid 1 \n");
             _exit(0);
          }
          else if(pid1 > 0)
          {
             //wait(NULL);
          }
          else
          {
             return SNMP_ERR_GENERR;
          }
		  

        break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;

}
#endif

int write_wapiapConfigBSSIDNum(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >128) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  		  
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiapConfigBSSIDNum=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiEAPAuthenSupport(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    unsigned char temp[32];
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (unsigned long *) var_val ;
	   if((value != 0) && (value != 1))  /* #0045-2 guoxd_002 20081109 modify */
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   /* #0045-2 guoxd_002 20081109 modify start */
	   memset(temp, 0, sizeof(temp));
   	   value = * (unsigned long *) var_val ;
	   if (value == 1)
	   {
	   	value = 2;	/* 802.11i */
	   }
	   else
	   {
	   	value = 1;	/* WAPI */   
	   }
          sprintf(temp,"%ld", value);
	   /* value 1, wapi; 2, 802.11i */
          save_global_conf(SEP_EQUAL, AP_BASE_CONF, "", "PRODUCT_SEC", temp);

	   /* reboot the system */
	   system("/sbin/reboot");		  
	   /* #0045-2 guoxd_002 20081109 modify end */
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiApWorkMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiApWorkMode=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiapTxRates(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0) ||(value >54) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiapTxRates=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiapBSSIDEncryption(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >1) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiapBSSIDEncryption=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiapDot11aAntennaGain(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0) ||(value >27) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiapDot11aAntennaGain=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiapDot11gAntennaGain(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if((value <0)|| (value >27) )
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiapDot11gAntennaGain=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiconRadiusServerPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiconRadiusServerPort=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



int write_wapiconDNSServer(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 20) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
         sprintf(temp_wapiconDNSServer,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapidot11QosTrafficClass(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapidot11QosTrafficClass=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

///////3
int write_wapidot11AuthenticationAlgorithm(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   static long  long_ret;
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
       long_ret = *((long *) var_val);
       if ((long_ret < 1) || (long_ret > 3)) 
	   	{
            fprintf(stderr, "write to AuthenticationAlgorithm:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
			if(long_ret==1)
				{
				 system("/usr/sbin/wapiset wlan ath0 set mode open && killall wapid && /usr/sbin/wapid -c /user/sbin/wlan.conf  &");
				}
			else if(long_ret == 2)
				{
				 system("/usr/sbin/wapiset wlan ath0 set mode psk  && killall wapid && /usr/sbin/wapid -c /user/sbin/wlan.conf  &");
				}
			else if(long_ret == 3)
				{
					system("/usr/sbin/wapiset wlan ath0 set mode cert  && killall wapid && /usr/sbin/wapid -c /user/sbin/wlan.conf  &");
				}

		  
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiConfigAuthenticationSuiteEnabled(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiConfigAuthenticationSuiteEnabled=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_wapiConfigUnicastCipherSize(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
             temp_wapiConfigUnicastCipherSize=* (long *) var_val;
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}




int write_WapiAsCert(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    u_long value,ret=0;    
    
    char strTemp[1024],*sp,*ep,*tp;   
    switch ( action ) {
        case RESERVE1:

          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 1024) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:  
	      bzero(asCert, 1024);
	      bzero(strTemp, 1024);
             memcpy(asCert, var_val, var_val_len);	          
	      asCert[var_val_len] = '\0';   
	     sp= strstr(asCert,"-----BEGIN CERTIFICATE-----");	     
	     ep=strstr(asCert,"-----END CERTIFICATE-----");
	     if((sp==NULL)||(ep==NULL)){		 	
			fprintf(stderr,"write to wapiPwlanAp: sp=null or ep= null \n");
			return SNMP_ERR_WRONGVALUE;
	     	}
	     tp=strTemp;	 
	     ret=strlen("-----BEGIN ASU CERTIFICATE-----");
	     memcpy(tp,"-----BEGIN ASU CERTIFICATE-----",ret);
	     tp=tp+ret;
		 
	     ret=strlen("-----BEGIN CERTIFICATE-----");
	     memcpy(tp, (sp+ret), (ep-sp-ret));
	     tp=tp+(ep-sp-ret);
	     ret=strlen("-----END ASU CERTIFICATE-----");
	     memcpy(tp, "-----END ASU CERTIFICATE-----", ret);
		 
	     tp=tp+ret;
	     *tp='\0';	 
	     bzero(asCert, 1024);
	     memcpy(asCert,strTemp,sizeof(strTemp));	     
	     asCert[tp-asCert]='\0';
            printf(" \n /******* changed  cer******/ \n%s\n",asCert);
		 
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

int write_WapiUserCert(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     u_long value,ret=0;       
    char strTemp[1024],*sp,*ep,*tp;  
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 1024) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:  
		bzero(userCert, 1024);
		bzero(strTemp, 1024);
             memcpy(userCert, var_val, var_val_len);
	      userCert[var_val_len-1] = '\0';	      

	     sp= strstr(userCert,"-----BEGIN CERTIFICATE-----");
	     ep=strstr(userCert,"-----END CERTIFICATE-----");
	     if((sp==NULL)||(ep==NULL))
		 	return SNMP_ERR_WRONGVALUE;
	     tp=strTemp;
		 
	     ret=strlen("-----BEGIN USER CERTIFICATE-----");
	     memcpy(tp,"-----BEGIN USER CERTIFICATE-----",ret);
	     tp=tp+ret;
		 
	     ret=strlen("-----BEGIN CERTIFICATE-----");
	     memcpy(tp, (sp+ret), (ep-sp-ret));
	     tp=tp+(ep-sp-ret);

	     ret=strlen("-----END USER CERTIFICATE-----");
	     memcpy(tp, "-----END USER CERTIFICATE-----", ret);		 
	     tp=tp+ret;

	     ret=strlen("-----END CERTIFICATE-----");
	     *tp=0x0d; tp++;
	     *tp=0x0a; tp++; 
	     *tp=0x0d; tp++;
	     memcpy(tp,ep+ret,(var_val_len-(ep+ret-userCert)));

	     tp=tp+(var_val_len-(ep+ret-userCert));
	     *tp='\0';
		 
	     bzero(userCert, 1024);
	     ret=strlen(strTemp);
	     memcpy(userCert,strTemp,ret);
	     userCert[ret]='\0';
	     printf("write userCert:\n%s\n",userCert);

	     
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}

//heyanhua modify 2010-5-3
int write_WapiInstallCert(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value,ret=0;
    char buffer[2000];    
	char cmd[256];

    char cert_path[]="/jffs/user.cer";
    	/*UDP 通信相关变量*/
	struct _packet_reset_srv send_to_WAI;
	struct _packet_reset_srv recv_from_WAI;
	struct srv_info WAI_srv;
	const char *loop_ip = "127.0.0.1";
	char  units[3]="\x0d\n";
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	    value=* (long *) var_val;
/*	    if(value!=1){

		fprintf(stderr,"write to wapiPwlanAp: bad over value \n");
              return SNMP_ERR_WRONGVALUE;
	   }
	   */
	   if((strlen(userCert)==0)||(strlen(asCert)==0)){
		fprintf(stderr,"write to wapiPwlanAp: userCert[]=NULL  or  asCert[]=NULL \n");
              return SNMP_ERR_WRONGVALUE;
	   }
          break;
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
			if(value==0){
				system("rm /jffs/user.cer");
				}
			else if(value==1){
				memset(cmd,0,256);
				sprintf(cmd,"%s %s %s %s %s %s","cert_unite","/jffs/",asCert,"/jffs/",userCert,"/jffs/user.cer");
				system(cmd);
				}
			break;
	/*      bzero(buffer, 2000);
 	      
	      strcat(buffer,units);
	      strcat(buffer, asCert);
	      strcat(buffer,units);	
	      strcat(buffer,units);	
	      strcat(buffer,userCert);
	      strcat(buffer,units);	
  	
		memset(&WAI_srv, 0, sizeof(struct srv_info));	
		memset(&send_to_WAI, 0, sizeof(struct _packet_reset_srv));
		memset(&recv_from_WAI, 0, sizeof(struct _packet_reset_srv));
		*/

		/*整合证书内容*/
	//	memcpy(send_to_WAI.data,buffer,strlen(buffer));
		
	//	save_certificate("/tmp/u.cer", buffer, strlen(buffer));
		/*send cert_data to WAI and check cert is Ap's Cert or no*/
	/*	WAI_srv.port = WAI_WEB_PORT;
		ret = init_srv_info(&WAI_srv, loop_ip);

		if(ret == 0)
		{
			fprintf(stderr, "  init_srv_info  \n");
			goto up_error;
		}
		//goto reload;
		send_to_WAI.head.ver = htons(VERSIONNOW);
		send_to_WAI.head.cmd = htons(CHECK_CERT);
		send_to_WAI.head.reserve = htons(1);

		send_to_WAI.head.data_len = strlen(buffer);
		ret = send_wapi_info(&WAI_srv, &send_to_WAI);
		if(ret != 0)
		{
			fprintf(stderr, "  send_wapi_info \n");
			close(WAI_srv.fd);
			goto up_error;
		}
		ret = recv_wapi_info(&WAI_srv, &recv_from_WAI);
		if(ret != 0)
		{
			fprintf(stderr, "  recv_wapi_info \n");
			close(WAI_srv.fd);
			goto up_error;
		}

		ret = WAI_msg_handle(&recv_from_WAI);		
		if(ret != 0)
		{
			fprintf(stderr, "  WAI_msg_handle \n");
			close(WAI_srv.fd);
			goto up_error;
		}
		*/
		/**保存AP证书*/
	/*	ret = save_certificate(cert_path, buffer, strlen(buffer));
		if(ret!= 0)
		{
			if(ret == 1)
			{
				fprintf(stderr, "  save_certificate 1 \n");
			}
			else if(ret == 2)
			{
				fprintf(stderr, "  save_certificate 2 \n");
			}
				
			close(WAI_srv.fd);
			goto up_error;
		}
		save_global_conf(SEP_EQUAL,WLAN_CONF,"", "CERT_STATUS", "1");
		save_global_conf(SEP_EQUAL,WLAN_CONF,"", "CERT_INDEX","1");
		save_global_conf(SEP_EQUAL,WLAN_CONF,"", "CERT_NAME",cert_path);
		
		
		usleep(200);
		ret = send_ap_reload_msg(&WAI_srv);
		if(ret != 0)
		{
			fprintf(stderr, "  send_ap_reload_msg \n");
			close(WAI_srv.fd);
			goto up_error;
		}
		close(WAI_srv.fd);
		WapiInstallCertFlag=1;
		break;

	    
up_error:		
	    fprintf(stderr,"write to wapiPwlanAp: install cert fail \n");
	    save_global_conf(SEP_EQUAL,WLAN_CONF,"", "CERT_STATUS", "0");
	    save_global_conf(SEP_EQUAL,WLAN_CONF,"", "CERT_INDEX","0");
            return SNMP_ERR_NOCREATION;
			*/

        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int iw_enum_wlan_interface( char ifnameList[] )
{
  char		buff[1024];
  FILE *	fh;
  struct ifconf ifc;
  struct ifreq *ifr;
  int		i;
  int count=0;
  char *ip,*q;
  char  name[IFNAMSIZ + 1];
  int  skfd;
  ip=ifnameList;

  if((skfd = iw_sockets_open()) < 0)
    {
      perror("socket");
      exit(-1);
    }

#ifndef IW_RESTRIC_ENUM
  /* Check if /proc/net/wireless is available */
  fh = fopen(PROC_NET_DEV, "r");
#else
  /* Check if /proc/net/wireless is available */
  fh = fopen(PROC_NET_WIRELESS, "r");
#endif

  if(fh != NULL)
    {
      /* Success : use data from /proc/net/wireless */

      /* Eat 2 lines of header */
      fgets(buff, sizeof(buff), fh);
      fgets(buff, sizeof(buff), fh);

      /* Read each device line */
      while(fgets(buff, sizeof(buff), fh))
	{
	  char *s;

	  /* Extract interface name */
	  s = iw_get_ifname(name, (int)sizeof(name), buff);
	  if(!s)
	    /* Failed to parse, complain and continue */
#ifndef IW_RESTRIC_ENUM
	    fprintf(stderr, "Cannot parse " PROC_NET_DEV "\n");
#else
	    fprintf(stderr, "Cannot parse " PROC_NET_WIRELESS "\n");
#endif
	  else {
	       q=strstr(name,"ath");	  //by sunyushuang0319
              if(q!=NULL) {
                  strcpy(ip,name);
                  ip=ip+IFNAME_LEN;
		  count++;
              }
	  }
	    /* Got it, print info about this interface */
	    //(*fn)(skfd, name, args, count);
	}

      fclose(fh);
    }
  else
    {
      /* Get list of configured devices using "traditional" way */
      ifc.ifc_len = sizeof(buff);
      ifc.ifc_buf = buff;
      if(ioctl(skfd, SIOCGIFCONF, &ifc) < 0)
	{
	  fprintf(stderr, "SIOCGIFCONF: %s\n", strerror(errno));
	  close(skfd);
	  return;
	}
      ifr = ifc.ifc_req;

      /* Print them */
      for(i = ifc.ifc_len / sizeof(struct ifreq); --i >= 0; ifr++){
          q=strstr(ifr->ifr_name,"ath"); //by sunyushuang0319
          if(q!=NULL) {
             strcpy(ip,name);
             ip=ip+IFNAME_LEN;
	     count++;
          }
      //	(*fn)(skfd, ifr->ifr_name, args, count);
      }	
    }
    close(skfd);
    return count;
}

int 
iw_get_txPower(char *ifname){

	int skfd;
	int dbm;
	int mwatt;
	struct iwreq wrq;
	
	if((skfd = iw_sockets_open()) < 0)
	{
		return 0;
	}
	if(ifname ==NULL)
	{
		return 0;
	}
	
	/* Get current Transmit Power */
	if(iw_get_ext(skfd, ifname, SIOCGIWTXPOW, &wrq) >= 0)
	{
	    /* Disabled ? */
	 	if(wrq.u.txpower.disabled){
				printf(":off\n\n");
	 	}else{
		  /* Fixed ? */
		  if(wrq.u.txpower.fixed){
		    printf("=");
		  }
		  else{
		   printf(":");
		  }
		  if(wrq.u.txpower.flags & IW_TXPOW_MWATT)
		  {
		      dbm = iw_mwatt2dbm(wrq.u.txpower.value);
		      mwatt = wrq.u.txpower.value;
		  }
		  else{
		      dbm = wrq.u.txpower.value;
		      mwatt = iw_dbm2mwatt(wrq.u.txpower.value);
		  }
		  printf("%d dBm  \t(%d mW)\n\n", dbm, mwatt);
		}
	 }

	return dbm;
}


int iw_get_wifis()
{
  char		buff[1024];
  FILE *	fh;
  struct ifconf ifc;
  struct ifreq *ifr;
  int		i;
  char *q;
  int count=0;
  char  name[IFNAMSIZ + 1];
  int skfd;
  if((skfd = iw_sockets_open()) < 0)
    {
      perror("socket");
      exit(-1);
    }
  /* Check if /proc/net/wireless is available */
  fh = fopen(PROC_NET_DEV, "r");
  if(fh != NULL)
    {
      /* Success : use data from /proc/net/wireless */

      /* Eat 2 lines of header */
      fgets(buff, sizeof(buff), fh);
      fgets(buff, sizeof(buff), fh);

      /* Read each device line */
      while(fgets(buff, sizeof(buff), fh))
	{
	  char *s;

	  /* Extract interface name */
	  s = iw_get_ifname(name, sizeof(name), buff);

	  if(!s)
	    /* Failed to parse, complain and continue */
	    fprintf(stderr, "Cannot parse " PROC_NET_DEV "\n");
	  else{
              q=strstr(name,"wifi");
              if(q!=NULL) {
                  count++;
              }
	  }
      }

      fclose(fh);
    }
  else
    {
      /* Get list of configured devices using "traditional" way */
      ifc.ifc_len = sizeof(buff);
      ifc.ifc_buf = buff;
      if(ioctl(skfd, SIOCGIFCONF, &ifc) < 0)
	{
	  fprintf(stderr, "SIOCGIFCONF: %s\n", strerror(errno));
	  close(skfd);
	  return;
	}
      ifr = ifc.ifc_req;

      /* Print them */
      for(i = ifc.ifc_len / sizeof(struct ifreq); --i >= 0; ifr++) {
          q=strstr(name,"wifi");
          if(q!=NULL) {
              count++;
          }	
      }
    }
    close(skfd);
	/*ljy--test start*/
  	printf("%s: count 0x%x.\n", __func__, count);
 	 /*ljy--test end*/
    return count;
}

// add by piyp 2008-12-05
int 
get_ioctl_param_ups( char * ifname)
{
    int counts=0;
	struct ifreq ifr;
	int ret ;
	struct ath_stats as;
	
	memset(&as,0,sizeof(as));
	ret = socket(AF_INET, SOCK_DGRAM, 0);
	if (ret < 0)
	{
		printf(" socket error.\n");
		return -1;
	}
	 
	// ----------- wifi0 ------------
	strcpy(ifr.ifr_name, ifname);
	ifr.ifr_data = (caddr_t) &as;

	if (ioctl(ret, SIOCGATHSTATS, &ifr) >0)
	{
	  printf("ioctl error.\n");
	  close(ret);
	  return -2;
	}
	counts = as.ast_up_times;	
	close(ret);
	return counts;
}

int 
get_ioctl_param_downs( char * ifname)
{
    int counts=0;
	struct ifreq ifr;
	int ret ;
	struct ath_stats as;
	
	memset(&as,0,sizeof(as));
	ret = socket(AF_INET, SOCK_DGRAM, 0);
	if (ret < 0)
	{
		printf(" socket error.\n");
		return -1;
	}
	 
	// ----------- wifi0 ------------
	strcpy(ifr.ifr_name, ifname);
	ifr.ifr_data = (caddr_t) &as;

	if (ioctl(ret, SIOCGATHSTATS, &ifr) >0)
	{
	  printf("ioctl error.\n");
	  close(ret);
	  return -2;
	}
	counts = as.ast_down_times;	
	printf("wifi0countsdowns=%d\n",counts);
	close(ret);
	return counts;
}




int get_ioctl_parameter( char * ifname , struct ieee80211_stats *s)
{
        int c, len;
        struct ifreq ifr;
        int ret ;
  
       // static struct ieee80211_stats stats;
       struct ieee80211_stats stats;
	printf("line:%d, addr: %x\n",__LINE__, s);
		ret = socket(AF_INET, SOCK_DGRAM, 0);
        if (ret < 0)
        {
            printf(" socket error in getioctl_parameter().\n");
            return -1;
        }
		printf("line:%d, addr: %x\n",__LINE__, s);

        strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));

		ifr.ifr_data = (caddr_t) &stats;
	
	printf("line:%d, addr: %x\n",__LINE__, s);
        if (ioctl(ret, SIOCG80211STATS, &ifr) < 0)
        {
            printf("ioctl error getioctl_parameter().\n");
	     close(ret);
            return -2;
        }
	printf("line:%d, addr: %x\n",__LINE__, s);


        //printstats(&stats);

      printf("is_rx_badversion:%d\n",stats.is_rx_badversion);
      printf("is_rx_tooshort:%d\n",stats.is_rx_tooshort);
      printf("is_rx_auth_try:%d\n",stats.is_rx_auth_try);
      printf("is_rx_auth_ok:%d\n",stats.is_rx_auth_ok);
      printf("is_rx_assoc_try:%d\n",stats.is_rx_assoc_try);
      printf("is_rx_ap_too_many_sta:%d\n",stats.is_rx_ap_too_many_sta);


	


      printf("s:0x%x,&stats:0x%x sizeof:%d\r\n", s , &stats, sizeof(struct ieee80211_stats) );

	memcpy(s,&stats,sizeof(struct ieee80211_stats));
	
#if 0          
	s->is_assocs=stats.is_assocs;
	s->is_crypto_attachfail=stats.is_crypto_attachfail;
	s->is_crypto_badcipher=stats.is_crypto_badcipher;
	s->is_crypto_ccmp=stats.is_crypto_ccmp;
	s->is_crypto_delkey=stats.is_crypto_delkey;
	s->is_crypto_enmicfail=stats.is_crypto_enmicfail;
#endif
	
        close(ret);
        return 1;
}


int get_ioctl_driver( char * ifname ,char *wlanDate,int type)
{
        int c, len;
        struct ifreq ifr;
        int ret ;
        // type==1) 
        struct agent_snmp_ap_wireless   driverDate1;
	memset(&driverDate1,0,sizeof(struct agent_snmp_ap_wireless));
	driverDate1.packetType=0x001;
	driverDate1.dateLen=sizeof(struct snmp_ap_wireless); 
        // type==2)
        struct agent_snmp_ap_wireless_1  driverDate2;
	memset(&driverDate2,0,sizeof(struct agent_snmp_ap_wireless_1));
        driverDate2.packetType=0x002;
        driverDate2.dateLen=sizeof(struct snmp_ap_wireless_1);
	    	
//printf("****************************1\n");
        ret = socket(AF_INET, SOCK_DGRAM, 0);
        if (ret < 0)
        {
            printf(" socket error in get_ioctl_driver().\n");
            return -1;
        }
        strncpy(ifr.ifr_name, ifname, sizeof (ifr.ifr_name));
	if(type==1)
           ifr.ifr_data = (caddr_t) &driverDate1;
	else if (type==2)
	   ifr.ifr_data = (caddr_t) &driverDate2;
	else{
	    close(ret);
           return -1;
	}
        if (ioctl(ret, SIOCSNMPDAGENT, &ifr) >0)
        {
            printf("ioctl error in get_ioctl_driver().\n");
	     close(ret);
            return -2;
        }
        close(ret);
	if (type==1)
	    memcpy(wlanDate,(char *)(&driverDate1),sizeof(struct agent_snmp_ap_wireless));
	else if (type ==2) {
            memcpy(wlanDate,(char *)(&driverDate2),sizeof(struct agent_snmp_ap_wireless_1));
	}
	else 
	    return -1;
        return 1;
	
}


//typedef struct _head_info HEAD_INFO;
int 
snmp_wapi_udp(WAPI_STATS_ENTRY *wapiDate,char *staData)
{
   
    int wapid_fd = 0;    
    struct sockaddr_in wapid_addr; 
    HEAD_INFO headInfo;    
    char send_to_buf[1024] ={0,};
    char recv_from_buf[2048]={0,};
    
    int sendlen = 0;
    int send_buf_len =0;
    int readlen = 0;
    int offset = 0;
    unsigned char str_len = 0;
    int error=0;
        
    bzero(&(wapid_addr), sizeof(struct sockaddr_in));
    memset(&headInfo, 0, sizeof(headInfo));   
    memset(send_to_buf, 0, 1024); 
    memset(recv_from_buf, 0, 2048);  
	if(wapiDate!=NULL){
		headInfo.ver = 0x0001;
	    headInfo.cmd = 0x0312;
	    headInfo.reserve = 0;
	    headInfo.data_len = 0;
	}
	if(staData!=NULL){//add by piyp 2009-02-19
		headInfo.ver = 0x0001;
	    headInfo.cmd = 0x0314;
	    headInfo.reserve = 0;
	    headInfo.data_len = 0;
	}

	
	offset = 0;	
	write_word(send_to_buf,(headInfo.ver),0);
	offset += 2;
	write_word(send_to_buf + offset,(headInfo.cmd),0);

	offset += 2;
	write_word(send_to_buf + offset,(headInfo.reserve),0);
	
	write_word(send_to_buf + offset,(headInfo.data_len),0);
	send_buf_len = offset;


	
    if(get_as_info(&wapid_addr,"127.0.0.1", 9003))
    {
        error=-1;
        goto wapid_error;
    }
    if((wapid_fd = open_as_socket()) < 0)
    {
        error=-2;
        goto wapid_error;
    }



    //printf("**********sendto*********\n");
    sendlen = sendto(wapid_fd, send_to_buf, send_buf_len,0,
  		      (struct sockaddr *)&wapid_addr,sizeof(struct sockaddr_in));



    if (sendlen != send_buf_len)
    {
        error=-3;
	      goto wapid_error;
    }


	
    /*printf("fd_timed_read()\n");*/
    bzero(recv_from_buf,2048);
   printf("**********fd_timed_read*********\n");
    readlen =fd_timed_read(wapid_fd,recv_from_buf,sizeof(recv_from_buf),RECETIMEOUT);
 
    if((readlen < 0) || (readlen > sizeof(recv_from_buf)))
    {
        error=-4;
        goto wapid_error;
    }

	
    memset(&headInfo, 0, sizeof(headInfo));
    offset = 0;
    memcpy(&(headInfo.ver), recv_from_buf, 2);
    offset += 2;
    memcpy((char *)(&(headInfo.cmd)), recv_from_buf+offset, 2);
    offset += 2;
    memcpy((char *)(&(headInfo.reserve)), recv_from_buf+offset, 2);
    offset += 2;
    memcpy((char *)(&(headInfo.data_len)), recv_from_buf+offset, 2);    
    offset += 2;

    
    if((int)headInfo.ver != 0x0001)
    {
        error=-5;
        goto wapid_error;
    }


    if((int)headInfo.cmd != 0x0313 && (int)headInfo.cmd != 0x0315)
    {
        error=-6;
        goto wapid_error;
    }
	
	if((int)headInfo.cmd == 0x0313){
		memcpy(wapiDate, recv_from_buf+8,sizeof(WAPI_STATS_ENTRY));
	}



	if((int)headInfo.cmd == 0x0315){//add by piyp 2009-02-19
		memcpy(staData, recv_from_buf+8,headInfo.data_len);
	}

    close(wapid_fd);
    return 1;
wapid_error:
    close(wapid_fd); 
    printf("snmp_wapi_udp() error=%d \n",error);
    return -1;
}

int
get_one_Interface_dates(char *ifname, struct ifnet   *ifdate)
{
    int ret=5;
    char            line[256], ifname_buf[64],  *ptr;
    struct ifreq    ifrq;
    struct ifnet  **ifnetaddr_ptr;
    FILE           *devin;
    int             i, fd;
    int temp=100;
    int flag=0;
    unsigned long   rec_pkt, rec_oct, rec_err, rec_drop;
    unsigned long   snd_pkt, snd_oct, snd_err, snd_drop, coll;
    const char     *scan_line_2_2 =
        "%lu %lu %lu %lu %*lu %*lu %*lu %*lu %lu %lu %lu %lu %*lu %lu";
    const char     *scan_line_2_0 =
        "%lu %lu %*lu %*lu %*lu %lu %lu %*lu %*lu %lu";
    const char     *scan_line_to_use;

    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        DEBUGMSGTL(("snmpd",
                    "socket open failure in Interface_Scan_Init\n"));
        return; /** exit (1); **/
    }
    /*
     * at least linux v1.3.53 says EMFILE without reason... 
     */
    if (!(devin = fopen("/proc/net/dev", "r"))) {
        close(fd);
        snmp_log(LOG_ERR, "cannot open /proc/net/dev - continuing...\n");
        return; /** exit (1); **/
    }

    fgets(line, sizeof(line), devin);
    fgets(line, sizeof(line), devin);
    if (strstr(line, "compressed")) {
        scan_line_to_use = scan_line_2_2;
        DEBUGMSGTL(("mibII/interfaces",
                    "using linux 2.2 kernel /proc/net/dev\n"));
    } else {
        scan_line_to_use = scan_line_2_0;
        DEBUGMSGTL(("mibII/interfaces",
                    "using linux 2.0 kernel /proc/net/dev\n"));
    }

    while (fgets(line, sizeof(line), devin)) {
	struct ifnet   *nnew;
        char           *stats, *ifstart = line;
        char *cp=NULL;

        if (line[strlen(line) - 1] == '\n')
            line[strlen(line) - 1] = '\0';

        while (*ifstart && *ifstart == ' ')
            ifstart++;

        if (!*ifstart || ((stats = strrchr(ifstart, ':')) == NULL)) {
            snmp_log(LOG_ERR,
                     "/proc/net/dev data format error, line ==|%s|", line);
            continue;
        }
        if ((scan_line_to_use == scan_line_2_2) && ((stats - line) < 6)) {
            snmp_log(LOG_ERR,
                     "/proc/net/dev data format error, line ==|%s|", line);
        }
				
        *stats   = 0;
        strncpy(ifname_buf, ifstart, sizeof(ifname_buf));
        ifname_buf[ sizeof(ifname_buf)-1 ] = 0;
        *stats++ = ':';
        while (*stats == ' ')
            stats++;

        if ((scan_line_to_use == scan_line_2_2 &&
             sscanf(stats, scan_line_to_use, &rec_oct, &rec_pkt, &rec_err,
                    &rec_drop, &snd_oct, &snd_pkt, &snd_err, &snd_drop,
                    &coll) != 9) || (scan_line_to_use == scan_line_2_0
                                     && sscanf(stats, scan_line_to_use,
                                               &rec_pkt, &rec_err,
                                               &snd_pkt, &snd_err,
                                               &coll) != 5)) {
            if ((scan_line_to_use == scan_line_2_2)
                && !strstr(line, "No statistics available"))
                snmp_log(LOG_ERR,
                         "/proc/net/dev data format error, line ==|%s|",
                         line);
            continue;
        }
        /* find ifname */
        if(strcmp(ifname_buf,ifname))
	   continue;
	flag++;
					 
    //    nnew = (struct ifnet *) calloc(1, sizeof(struct ifnet));
    //    if (nnew == NULL)
    //        break;              /* alloc error */

        /*
         * chain in: 
         */
     //   *ifnetaddr_ptr = nnew;
     //   ifnetaddr_ptr = &nnew->if_next;
        /*
         * linux previous to 1.3.~13 may miss transmitted loopback pkts: 
         */
	nnew=ifdate;
        if (!strcmp(ifname_buf, "lo") && rec_pkt > 0 && !snd_pkt)
            snd_pkt = rec_pkt;

        nnew->if_ipackets = rec_pkt & 0xffffffff;
        nnew->if_ierrors = rec_err;
        nnew->if_opackets = snd_pkt & 0xffffffff;
        nnew->if_oerrors = snd_err;
        nnew->if_collisions = coll;
        if (scan_line_to_use == scan_line_2_2) {
            nnew->if_ibytes = rec_oct & 0xffffffff;
            nnew->if_obytes = snd_oct & 0xffffffff;
            nnew->if_iqdrops = rec_drop;
            nnew->if_snd.ifq_drops = snd_drop;
        } else {
            nnew->if_ibytes = (rec_pkt * 308) & 0xffffffff;
            nnew->if_obytes = (snd_pkt * 308) & 0xffffffff;
        }
         
	break;
    }                           /* while (fgets ... */
 	   
    fclose(devin);
    close(fd);
    return flag;
}

int
get_wifi_frame_dates(char *ifname)
{
    int ret=5;
    char            line[256], ifname_buf[64],  *ptr;
    struct ifreq    ifrq;
    struct ifnet  **ifnetaddr_ptr;
    FILE           *devin;
    int             i, fd;
    int temp=100;
    int flag=0;
    int frameDate=0;
//
    unsigned long   rec_pkt, rec_oct, rec_err, rec_drop,rec_frame;
    unsigned long   snd_pkt, snd_oct, snd_err, snd_drop, coll;
    const char     *scan_line_2_2 =
        "%lu %lu %lu %lu %*lu %lu %*lu %*lu %lu %lu %lu %lu %*lu %lu";
    const char     *scan_line_2_0 =
        "%lu %lu %*lu %*lu %*lu %lu %lu %*lu %*lu %lu";
    const char     *scan_line_to_use;

    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        DEBUGMSGTL(("snmpd",
                    "socket open failure in Interface_Scan_Init\n"));
        return; /** exit (1); **/
    }
    /*
     * at least linux v1.3.53 says EMFILE without reason... 
     */
    if (!(devin = fopen("/proc/net/dev", "r"))) {
        close(fd);
        snmp_log(LOG_ERR, "cannot open /proc/net/dev - continuing...\n");
        return; /** exit (1); **/
    }

    fgets(line, sizeof(line), devin);
    fgets(line, sizeof(line), devin);
    if (strstr(line, "compressed")) {
        scan_line_to_use = scan_line_2_2;
        DEBUGMSGTL(("mibII/interfaces",
                    "using linux 2.2 kernel /proc/net/dev\n"));
    } else {
        scan_line_to_use = scan_line_2_0;
        DEBUGMSGTL(("mibII/interfaces",
                    "using linux 2.0 kernel /proc/net/dev\n"));
    }

    while (fgets(line, sizeof(line), devin)) {
	struct ifnet   *nnew;
        char           *stats, *ifstart = line;
        char *cp=NULL;

        if (line[strlen(line) - 1] == '\n')
            line[strlen(line) - 1] = '\0';

        while (*ifstart && *ifstart == ' ')
            ifstart++;

        if (!*ifstart || ((stats = strrchr(ifstart, ':')) == NULL)) {
            snmp_log(LOG_ERR,
                     "/proc/net/dev data format error, line ==|%s|", line);
            continue;
        }
        if ((scan_line_to_use == scan_line_2_2) && ((stats - line) < 6)) {
            snmp_log(LOG_ERR,
                     "/proc/net/dev data format error, line ==|%s|", line);
        }
				
        *stats   = 0;
        strncpy(ifname_buf, ifstart, sizeof(ifname_buf));
        ifname_buf[ sizeof(ifname_buf)-1 ] = 0;
        *stats++ = ':';
        while (*stats == ' ')
            stats++;

        if ((scan_line_to_use == scan_line_2_2 &&
             sscanf(stats, scan_line_to_use, &rec_oct, &rec_pkt, &rec_err,
                    &rec_drop,&rec_frame,&snd_oct, &snd_pkt, &snd_err, &snd_drop,
                    &coll) != 10) || (scan_line_to_use == scan_line_2_0
                                     && sscanf(stats, scan_line_to_use,
                                               &rec_pkt, &rec_err,
                                               &snd_pkt, &snd_err,
                                               &coll) != 5)) {
            if ((scan_line_to_use == scan_line_2_2)
                && !strstr(line, "No statistics available"))
                snmp_log(LOG_ERR,
                         "/proc/net/dev data format error, line ==|%s|",
                         line);
            continue;
        }
        /* find ifname */	
        if(strcmp(ifname_buf,ifname))
	   continue;
	flag++;

	frameDate=rec_frame;
    }                           /* while (fgets ... */
 	   
    fclose(devin);
    close(fd);
    return frameDate;
}

int
get_multi_Interface_dates( struct ifnet *wlandate,struct ifnet *awlandate)
{
    int ret=5;
    char            line[256], ifname_buf[64],  *ptr;
    struct ifreq    ifrq;
    struct ifnet  **ifnetaddr_ptr;
    FILE           *devin;
    int             i, fd;
    int temp=100;
    int wlanflag=0,awlanflag=0;
//
    unsigned long   rec_pkt, rec_oct, rec_err, rec_drop;
    unsigned long   snd_pkt, snd_oct, snd_err, snd_drop, coll;
    const char     *scan_line_2_2 =
        "%lu %lu %lu %lu %*lu %*lu %*lu %*lu %lu %lu %lu %lu %*lu %lu";
    const char     *scan_line_2_0 =
        "%lu %lu %*lu %*lu %*lu %lu %lu %*lu %*lu %lu";
    const char     *scan_line_to_use;

    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        DEBUGMSGTL(("snmpd",
                    "socket open failure in Interface_Scan_Init\n"));
        return; /** exit (1); **/
    }
    /*
     * at least linux v1.3.53 says EMFILE without reason... 
     */
    if (!(devin = fopen("/proc/net/dev", "r"))) {
        close(fd);
        snmp_log(LOG_ERR, "cannot open /proc/net/dev - continuing...\n");
        return; /** exit (1); **/
    }

    fgets(line, sizeof(line), devin);
    fgets(line, sizeof(line), devin);
    if (strstr(line, "compressed")) {
        scan_line_to_use = scan_line_2_2;
        DEBUGMSGTL(("mibII/interfaces",
                    "using linux 2.2 kernel /proc/net/dev\n"));
    } else {
        scan_line_to_use = scan_line_2_0;
        DEBUGMSGTL(("mibII/interfaces",
                    "using linux 2.0 kernel /proc/net/dev\n"));
    }

    while (fgets(line, sizeof(line), devin)) {
	struct ifnet   *nnew;
        char           *stats, *ifstart = line;
        char *cp=NULL;

        if (line[strlen(line) - 1] == '\n')
            line[strlen(line) - 1] = '\0';

        while (*ifstart && *ifstart == ' ')
            ifstart++;

        if (!*ifstart || ((stats = strrchr(ifstart, ':')) == NULL)) {
            snmp_log(LOG_ERR,
                     "/proc/net/dev data format error, line ==|%s|", line);
            continue;
        }
        if ((scan_line_to_use == scan_line_2_2) && ((stats - line) < 6)) {
            snmp_log(LOG_ERR,
                     "/proc/net/dev data format error, line ==|%s|", line);
        }
				
        *stats   = 0;
        strncpy(ifname_buf, ifstart, sizeof(ifname_buf));
        ifname_buf[ sizeof(ifname_buf)-1 ] = 0;
        *stats++ = ':';
        while (*stats == ' ')
            stats++;

        if ((scan_line_to_use == scan_line_2_2 &&
             sscanf(stats, scan_line_to_use, &rec_oct, &rec_pkt, &rec_err,
                    &rec_drop, &snd_oct, &snd_pkt, &snd_err, &snd_drop,
                    &coll) != 9) || (scan_line_to_use == scan_line_2_0
                                     && sscanf(stats, scan_line_to_use,
                                               &rec_pkt, &rec_err,
                                               &snd_pkt, &snd_err,
                                               &coll) != 5)) {
            if ((scan_line_to_use == scan_line_2_2)
                && !strstr(line, "No statistics available"))
                snmp_log(LOG_ERR,
                         "/proc/net/dev data format error, line ==|%s|",
                         line);
            continue;
        }
        /* find ifname */
        cp=strstr(line,"ath");// by sunyushuang0321
	if(cp==NULL)
	    continue;
	printf("ifname=%s\n",ifname_buf);

	if(!(strstr(ifname_buf,"ath")==NULL)){
	    awlanflag++;              // by sunyushuang0420
	    nnew=awlandate;
	}
	else {
            wlanflag++;
            nnew=wlandate;
	}
        /*
         * linux previous to 1.3.~13 may miss transmitted loopback pkts: 
         */
        if (!strcmp(ifname_buf, "lo") && rec_pkt > 0 && !snd_pkt)
            snd_pkt = rec_pkt;

        nnew->if_ipackets = nnew->if_ipackets + (rec_pkt & 0xffffffff);
        nnew->if_ierrors = nnew->if_ierrors + (rec_err);

        nnew->if_opackets = nnew->if_opackets + (snd_pkt & 0xffffffff);

        nnew->if_oerrors = nnew->if_oerrors + (snd_err);
        nnew->if_collisions = nnew->if_collisions + (coll);
        if (scan_line_to_use == scan_line_2_2) {
            nnew->if_ibytes =nnew->if_ibytes + (rec_oct & 0xffffffff);
            nnew->if_obytes = nnew->if_obytes + (snd_oct & 0xffffffff);
            nnew->if_iqdrops =nnew->if_iqdrops + (rec_drop);
            nnew->if_snd.ifq_drops = nnew->if_snd.ifq_drops +(snd_drop);
        } else {
            nnew->if_ibytes = nnew->if_ibytes + ((rec_pkt * 308) & 0xffffffff);
            nnew->if_obytes = nnew->if_obytes + ((snd_pkt * 308) & 0xffffffff);
        }
         
	printf("nnew->if_opackets=%d\n",nnew->if_opackets);
    }      /* while (fgets ... */
 	   
   printf("awlandate->if_opackets=%d\n",awlandate->if_opackets);
  printf("wlannum=%d \t awlannum=%d\n",wlanflag,awlanflag);
    fclose(devin);
    close(fd);
    awlanflag=((awlanflag & 0x0000ffff)<<16) & 0xffff000 ;	
    wlanflag= wlanflag & 0x0000ffff ;
    awlanflag=awlanflag | wlanflag ;
    return  awlanflag ; 
}

int  read_port_state(char *file_name, 
		   const char *be_key, 
		   const char *end_key)
{
	char line[255];
	FILE *fid;
	int i = 0;
	int found_b = -1;
	int found_e = -1;
	int count=0;
	int flag=0;
	int tmp=0;

	struct wlan_info_t wlan_info_item;
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}

	while (!feof(fid))
	{
   	    fscanf(fid, "%[^\n]\n", line);
	    if(strcmp(line, be_key) == 0)
	    {
	        found_b = 0;
		continue;
            }
	    if(strcmp(line, end_key) == 0)
	    {
		found_e = 0;
		break;
	    }
	    if((found_b == 0) && (found_e != 0) )
	    {
	      count++;
		memset(&wlan_info_item, 0, sizeof(struct wlan_info_t));

		sscanf(line,"%s%s%s%s%s%s%s%s%s%s",
		wlan_info_item.dev_name, 
		wlan_info_item.ssid, 
		wlan_info_item.ssid_hide, 
		wlan_info_item.auth, 
		wlan_info_item.psk_type,
		wlan_info_item.psk_key,
		wlan_info_item.vlan_id,
		wlan_info_item.qos,
		wlan_info_item.mac_cmd,
		wlan_info_item.max_user
		);
		tmp=atoi(wlan_info_item.auth) >> 2;

		flag=flag|tmp;
	    }
	}
	fclose(fid);
	if(flag==0)
	    return 0;
	else
	    return 1;
}

int  serch_by_name(char *file_name, 
		   const char *be_key, 
		   const char *end_key, 
		   const char *dev_name,
		   struct wlan_info_t *wlan_info)
{
	char line[255];
	FILE *fid;
	int i = 0;
	int found_b = -1;
	int found_e = -1;
	int count=0;
	int flag=0;

	struct wlan_info_t wlan_info_item;
	if((fid = fopen(file_name, "r")) == NULL)
	{
		/*ljy--test start*/
		printf("%s: test.\n", __func__);
		/*ljy--test end*/
		printf("Open read config file error!\n");
		return -1;
	}

	while (!feof(fid))
	{
   	    fscanf(fid, "%[^\n]\n", line);
	    if(strcmp(line, be_key) == 0)
	    {
	        found_b = 0;
		continue;
            }
	    if(strcmp(line, end_key) == 0)
	    {
		found_e = 0;
		break;
	    }
	    if((found_b == 0) && (found_e != 0) )
	    {
	      count++;
		memset(&wlan_info_item, 0, sizeof(struct wlan_info_t));

		sscanf(line,"%s%s%s%s%s%s%s%s%s%s",
		wlan_info_item.dev_name, 
		wlan_info_item.ssid, 
		wlan_info_item.ssid_hide, 
		wlan_info_item.auth, 
		wlan_info_item.psk_type,
		wlan_info_item.psk_key,
		wlan_info_item.vlan_id,
		wlan_info_item.qos,
		wlan_info_item.mac_cmd,
		wlan_info_item.max_user
		);

		if(strncmp(wlan_info_item.dev_name, dev_name, strlen(dev_name)) == 0){
		    if(wlan_info!=NULL) {
		        strcpy(wlan_info->dev_name , wlan_info_item.dev_name );
		        strcpy(wlan_info->ssid , wlan_info_item.ssid );
		        strcpy(wlan_info->ssid_hide , wlan_info_item.ssid_hide );
		        strcpy(wlan_info->auth , wlan_info_item.auth );
		        strcpy(wlan_info->psk_type , wlan_info_item.psk_type );
		        strcpy(wlan_info->psk_key , wlan_info_item.psk_key );
		        strcpy(wlan_info->vlan_id , wlan_info_item.vlan_id );
		        strcpy(wlan_info->qos , wlan_info_item.qos );
		        strcpy(wlan_info->mac_cmd, wlan_info_item.mac_cmd);
		        strcpy(wlan_info->max_user, wlan_info_item.max_user);
		    }
		    flag=1;
		    break;
		}
	    }
	}
	fclose(fid);
	if(flag==1)
	    return count;
	else
	    return flag;
}


static int
get_info(int			skfd,
	 char *			ifname,
	 struct wireless_info *	info)
{
  struct iwreq		wrq;

  memset((char *) info, 0, sizeof(struct wireless_info));

  /* Get wireless name */
  if(iw_get_ext(skfd, ifname, SIOCGIWNAME, &wrq) < 0)
    {
      /* If no wireless name : no wireless extensions */
      /* But let's check if the interface exists at all */
      struct ifreq ifr;

      strcpy(ifr.ifr_name, ifname);
      if(ioctl(skfd, SIOCGIFFLAGS, &ifr) < 0)
	return(-ENODEV);
      else
	return(-ENOTSUP);
    }
  else
    {
      strncpy(info->name, wrq.u.name, IFNAMSIZ);
      info->name[IFNAMSIZ] = '\0';
    }

  /* Get ranges */
  if(iw_get_range_info(skfd, ifname, &(info->range)) >= 0)
    info->has_range = 1;

  /* Get network ID */
  if(iw_get_ext(skfd, ifname, SIOCGIWNWID, &wrq) >= 0)
    {
      info->has_nwid = 1;
      memcpy(&(info->nwid), &(wrq.u.nwid), sizeof(iwparam));
    }

  /* Get frequency / channel */
  if(iw_get_ext(skfd, ifname, SIOCGIWFREQ, &wrq) >= 0)
    {
      info->has_freq = 1;
      info->freq = iw_freq2float(&(wrq.u.freq));
    }

  /* Get sensitivity */
  if(iw_get_ext(skfd, ifname, SIOCGIWSENS, &wrq) >= 0)
    {
      info->has_sens = 1;
      memcpy(&(info->sens), &(wrq.u.sens), sizeof(iwparam));
    }

  /* Get encryption information */
  wrq.u.data.pointer = (caddr_t) info->key;
  wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
  wrq.u.data.flags = 0;
  if(iw_get_ext(skfd, ifname, SIOCGIWENCODE, &wrq) >= 0)
    {
      info->has_key = 1;
      info->key_size = wrq.u.data.length;
      info->key_flags = wrq.u.data.flags;
    }

  /* Get ESSID */
  wrq.u.essid.pointer = (caddr_t) info->essid;
  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
  wrq.u.essid.flags = 0;
  if(iw_get_ext(skfd, ifname, SIOCGIWESSID, &wrq) >= 0)
    {
      info->has_essid = 1;
      info->essid_on = wrq.u.data.flags;
    }

  /* Get AP address */
  if(iw_get_ext(skfd, ifname, SIOCGIWAP, &wrq) >= 0)
    {
      info->has_ap_addr = 1;
      memcpy(&(info->ap_addr), &(wrq.u.ap_addr), sizeof (sockaddr));
    }

  /* Get NickName */
  wrq.u.essid.pointer = (caddr_t) info->nickname;
  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
  wrq.u.essid.flags = 0;
  if(iw_get_ext(skfd, ifname, SIOCGIWNICKN, &wrq) >= 0)
    if(wrq.u.data.length > 1)
      info->has_nickname = 1;

  /* Get bit rate */
  if(iw_get_ext(skfd, ifname, SIOCGIWRATE, &wrq) >= 0)
    {
      info->has_bitrate = 1;
      memcpy(&(info->bitrate), &(wrq.u.bitrate), sizeof(iwparam));
    }

  /* Get RTS threshold */
  if(iw_get_ext(skfd, ifname, SIOCGIWRTS, &wrq) >= 0)
    {
      info->has_rts = 1;
      memcpy(&(info->rts), &(wrq.u.rts), sizeof(iwparam));
    }

  /* Get fragmentation threshold */
  if(iw_get_ext(skfd, ifname, SIOCGIWFRAG, &wrq) >= 0)
    {
      info->has_frag = 1;
      memcpy(&(info->frag), &(wrq.u.frag), sizeof(iwparam));
    }

  /* Get operation mode */
  if(iw_get_ext(skfd, ifname, SIOCGIWMODE, &wrq) >= 0)
    {
      info->mode = wrq.u.mode;
      if((info->mode < IW_NUM_OPER_MODE) && (info->mode >= 0))
	info->has_mode = 1;
    }

  /* Get Power Management settings */
  wrq.u.power.flags = 0;
  if(iw_get_ext(skfd, ifname, SIOCGIWPOWER, &wrq) >= 0)
    {
      info->has_power = 1;
      memcpy(&(info->power), &(wrq.u.power), sizeof(iwparam));
    }

#if WIRELESS_EXT > 9
  /* Get Transmit Power */
  if(iw_get_ext(skfd, ifname, SIOCGIWTXPOW, &wrq) >= 0)
    {
      info->has_txpower = 1;
      memcpy(&(info->txpower), &(wrq.u.txpower), sizeof(iwparam));
    }
#endif

#if WIRELESS_EXT > 10
  /* Get retry limit/lifetime */
  if(iw_get_ext(skfd, ifname, SIOCGIWRETRY, &wrq) >= 0)
    {
      info->has_retry = 1;
      memcpy(&(info->retry), &(wrq.u.retry), sizeof(iwparam));
    }
#endif	/* WIRELESS_EXT > 10 */

  /* Get stats */
  if(iw_get_stats(skfd, ifname, &(info->stats)) >= 0)
    {
      info->has_stats = 1;
    }

  return(0);
}


int  read_essid_name(char ifname[],char essidName[])
{
  int skfd,temp=0;
  struct wireless_info   info;
  char ifnameList[IFNAME_MAX];
  temp=iw_enum_wlan_interface( ifnameList );
  if(temp>0) {
      skfd=iw_sockets_open();
      get_info(skfd, ifname, &info);
      //display_info(&info, "wlan0");
      /* Close the socket. */
      strcpy(essidName,info.essid);
	  printf("ifname=%s /t essid=%s \n",ifname,info.essid);
      close(skfd);
      return 1;
  }
  return 0;
}


int
write_WapiAsIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    int size;
    char ipaddr[20];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  sprintf(ipaddr,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
	  save_global_conf(SEP_EQUAL,WLAN_CONFIG,"","ASU_IP",ipaddr);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int free_wlan_list(struct wlan_info_t  **wlan_list)
{
	struct wlan_info_t *p,*t;
	p=*wlan_list;
	t=p ;
	while(p!=NULL){		
		p=p->next;
		free(t);
		t=p;
	}	
}

void  free_wlan_table(struct wlan_info_t  **wlan_list)
{
	int i;
	struct wlan_info_t  *wsp,*wep;
	wsp=*wlan_list;
	while(wsp!=NULL){
	wep=wsp;
	wsp=wsp->next;
	free(wep);
	}
		

}
int  get_wlan_table(char *file_name, char *be_key,char *end_key, struct wlan_info_t  **wlan_list)
{
	char line[255];
	FILE *fid;
	int i = 0;
	int j = 0;
	int found_b = -1;
	int found_e = -1;
	int if_index = 0;
	int index = 0;
	int count=0;
	
	struct wlan_info_t  *wp,*tp;	
	*wlan_list=NULL;
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}
	while (!feof(fid))
	{
		
		fscanf(fid, "%[^\n]\n", line);
		if(strcmp(line, be_key) == 0)
		 {
		   found_b = 0;
		   continue;
		 }
		if(strcmp(line, end_key) == 0)
		{
			found_e = 0;
		}
		if((found_b == 0) && (found_e != 0) )
		{
		       count++;
			wp=(struct wlan_info_t  *)malloc(sizeof(struct wlan_info_t ));	              
			memset(wp,0, sizeof(struct wlan_info_t));
			
			sscanf( 
			line,"%s%s%s%s%s%s%s%s%s%s",
			wp->dev_name, 
			wp->ssid, 
			wp->ssid_hide, 
			wp->auth, 
			wp->psk_type,
			wp->psk_key,
			wp->vlan_id,
			wp->qos,
			wp->mac_cmd,
			wp->max_user			
			);
			wp->next=NULL;
				
			if((*wlan_list)!=NULL){	
				tp=*wlan_list;
				while((tp->next)!=NULL){	
					tp=tp->next;
				}
				tp->next=wp;	
	
			}
			else {
				(*wlan_list)=wp;				
			}
		
		}
	}		
	fclose(fid);
	return count;
}

int set_wlan_table(char *file_name, char *be_key,char *end_key, unsigned int  modfiyCount, struct wlan_info_t  wlan_scr_info)
{
	char line[255];
	FILE *fid, *fidw;
	char tmp_file[255]= "";
	int found = -1;
	int i = 0;
	int del_rec = 0;
	int count=0;
	char buf[1024]="";
 
	    sprintf(buf, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-66.64s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
			
	strcpy(tmp_file, file_name);
	strcat(tmp_file,".snmp");
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}
	if((fidw = fopen(tmp_file, "w")) == NULL)
	{
		printf("Open write config file error!\n");
		return -1;
	}
	
	while (!feof(fid))
	{
		fgets(line, 255, fid);
		if(feof(fid)) break;
		if (strchr(line, '\n'))  *(strchr(line, '\n')) = '\0';

		if(strcmp(line, be_key) == 0)
		 {
			found = 0;
			fprintf(fidw, "%s\n", line);
			continue;
		 }
	#if 0	
		if(strcmp(line, end_key) == 0)
		 {
			break;
		 }	
		else
	#endif		
		if((found == 0) && (strcmp(line, end_key) != 0))
		{
			count++;
			if(count!=modfiyCount)
			{
				fprintf(fidw, "%s\n", line);
			}
			else
			{
				if(buf != NULL) fprintf(fidw, "%s\n", buf);
			}
			i++;
		}
		else
		{
			fprintf(fidw, "%s\n", line);
		}
	
	}
	fclose(fid);
	fclose(fidw);
	unlink(file_name);
	rename(tmp_file, file_name);
	return 0;
}

int start_wlan_scr(int operation, struct  wlan_info_t *wlan_scr_info)
{
      static  char *  ADD_EDIT_DEL[5] = { "add", "edit", "del", "", NULL};
	int  pid = -1;
	char * aargv[]={WLAN_SCRIPT,"","","","", "","","","",NULL};    
	static char * const aargv_qos[]={WLAN_SCRIPT,NULL};

	if((operation <ADD_FORK) || (operation >DEL_FORK))
	{
		printf(" operation(%d) is wrong  \n", operation);
		return -1;
	}
	
	switch (operation)
	{
		case ADD_FORK:
		case EDIT_FORK:
		case DEL_FORK:
		{		
			aargv[1] = ADD_EDIT_DEL[operation];
			aargv[2] = wlan_scr_info->dev_name;
			aargv[3] = wlan_scr_info->ssid;
			aargv[4] = wlan_scr_info->ssid_hide;
			aargv[5] = wlan_scr_info->vlan_id;
			aargv[6] = wlan_scr_info->qos;
			aargv[7] = wlan_scr_info->mac_cmd;      //要加一个aargv[8].已加！
			aargv[8] = wlan_scr_info->max_user; 
			break;	
		}
	#if 0	
		{
			aargv[1] = ADD_EDIT_DEL[operation];
			aargv[2] = wlan_scr_info->dev_name;
			aargv[3] = wlan_scr_info->ssid;
			aargv[4] = wlan_scr_info->ssid_hide;
			aargv[5] = wlan_scr_info->vlan_id;
			aargv[6] = wlan_scr_info->qos;
			aargv[7] = wlan_scr_info->mac_cmd;      //要加一个aargv[8].已加！
			aargv[8] = wlan_scr_info->max_user; 
			//printf("aargv = %s %s %s", aargv[0],aargv[1],aargv[2]);
			break;	
		}
	#endif
		default:
			return 0;
	}	
	
	pid = fork();

	if(pid < 0)
	{
		printf("system error fork\n");
		return -1;
	}
	else if(pid  == 0)
	{
		execv(aargv[0],aargv);
		_exit(0);
	}
	else
	{
		int ret = 0;
		ret =wait(NULL);
	}
	return 0;
}


#if 0
int start_wlan_scr(int operation, struct  wlan_info_t *wlan_scr_info)
{
	int  pid = -1;
	static  char *  ADD_EDIT_DEL[5] = { "add", "edit", "del", "", NULL};
	char * aargv[]={WLAN_SCRIPT,"","","","", "","","",NULL};
	static char * const aargv_qos[]={WLAN_SCRIPT,NULL};

	//printf("<br>operation = %d, ADD_EDIT_DEL[%d] = %s</br>\n",operation,operation,  ADD_EDIT_DEL[operation]);
	if((operation <ADD_FORK) || (operation >DEL_FORK))
	{
		printf(" operation(%d) is wrong  \n", operation);
		return -1;
	}
	
	switch (operation)
	{
		case ADD_FORK:
		case EDIT_FORK:
		{		
			aargv[1] = ADD_EDIT_DEL[operation];
			aargv[2] = wlan_scr_info->dev_name;
			aargv[3] = wlan_scr_info->ssid;
			aargv[4] = wlan_scr_info->ssid_hide;
			aargv[5] = wlan_scr_info->vlan_id;
			aargv[6] = wlan_scr_info->qos;
			aargv[7] = wlan_scr_info->mac_cmd;
			printf("\n edit aargv = %s, %s, %s, %s, %s, %s, %s, %s\n", 
			aargv[0],aargv[1],aargv[2],aargv[3],aargv[4],aargv[5],aargv[6],aargv[7]);
			break;	
		}
		case DEL_FORK:
		{
			aargv[1] = ADD_EDIT_DEL[operation];
			aargv[2] = wlan_scr_info->dev_name;
			printf("\naargv = %s %s %s", aargv[0],aargv[1],aargv[2]);
			break;	
		}
		default:
			return 0;
	}	
	
	pid = fork();

	if(pid < 0)
	{
		printf("system error fork\n");
		return -1;
	}
	else if(pid  == 0)
	{
		execv(aargv[0],aargv);
		printf("%s %s :not found\n", aargv[0], aargv[1]);
		_exit(0);
	}
	else
	{
		int ret = 0;
		ret =wait(NULL);
	}
	return 0;
}
#endif
int  inform_wapid(int cmd,char *send_buf, int len)
{
       struct srv_info WAI_srv;
	struct _packet_reset_srv packet_reset_srv;
	struct _packet_reset_srv recv_from_srv;
	const char  *loop_ip = "127.0.0.1";
	int ret;
	/*infrom wapid to act*/
	if(cmd < CGI_CMD_ADD_DEV) {		
		return -1;
	}
	memset(&WAI_srv, 0, sizeof(struct srv_info));
	memset(&packet_reset_srv, 0, sizeof(struct _packet_reset_srv));
	memset(&recv_from_srv, 0, sizeof(struct _packet_reset_srv));
	WAI_srv.port = WAI_WEB_PORT;
	ret = init_srv_info(&WAI_srv, loop_ip);
	if(ret == 0)
	{    //printf("************1\n");
		goto err_exit;
	}
	packet_reset_srv.head.ver = htons(VERSIONNOW);
	packet_reset_srv.head.cmd = htons(cmd);
	memcpy(packet_reset_srv.data, send_buf, len) ;
	packet_reset_srv.head.data_len = len;
	ret = send_wapi_info(&WAI_srv, &packet_reset_srv);
	if(ret != 0)
	{//printf("************2\n");
		goto err_exit;
	}
	ret = recv_wapi_info(&WAI_srv, &recv_from_srv);
	if(ret != 0)
	{//printf("************3\n");
		goto err_exit;
	}
	ntoh_data(&recv_from_srv);
	if(recv_from_srv.head.ver != VERSIONNOW)
	{//printf("************4\n");
		goto err_exit;
	}
	if(recv_from_srv.data[0]==0)
	{//printf//("************5");
		close(WAI_srv.fd);
		return 0;
	}
 err_exit:
	close(WAI_srv.fd);
	return -1;
}

int 
sock_snmp_recv_cgi() {

	struct sockaddr_in s_addr;	
	socklen_t addr_len;		
	int len,channel=0;	
	char buff[128];	
	AAT aat;
	char message[128];
	char trapid[10];
	char trapchannel[100];
	char *pr;
	addr_len=sizeof(s_addr);   
	bzero(buff, 128);
	len=recvfrom(cgiSocketFD,buff,sizeof(buff)-1,0,(struct sockaddr *)&addr_len,&addr_len);

	if(len<0){			
		perror("recvfrom\n");			
		exit(errno);		
	}		
	pr = buff;
	if(buff!=NULL){
		memset(&aat,0,sizeof(aat));
		memset(message,0,128);
		memset(trapid,0,10);

		memcpy(trapid,buff,2);
		int id=atoi(trapid);
		pr+=2;
		//channel is chanaged ,and time is chanaged
		timeCleanFlagbg = 1;
		time(&channelMonitoreTimebg);
	
		strcpy(message,"current channel changed to ");
		strcat(message,pr);
		set_alarm(&aat,id,message);
		send_trap_string_notification(&aat);

	}
	return len;
}


 int  open_socket_upgrade(int *sockid,int portid)
{
	 int sockfd, ret;
 	struct sockaddr_in saddr;
	char message[1024];
 
	 sockfd = socket(AF_INET, SOCK_DGRAM, 0);
     //perror("socket error");
 	if (sockfd == -1) {
  		return -1;
 	}
 
 	bzero(&saddr, sizeof(struct sockaddr_in));
 	saddr.sin_family = AF_INET;
	// saddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	saddr.sin_addr.s_addr = inet_addr("0.0.0.0");
 	saddr.sin_port = htons(portid);
 
	ret = bind(sockfd, (struct sockaddr*) &saddr, sizeof(struct sockaddr_in));
    //perror("bind error");
    if (ret == -1) {
  		close(sockfd);
  		sockfd = -1;
		return -1;
  	}
	*sockid=sockfd;
	return 1;

}

int analyze_AP_mess(char message[])
{
    int temp=0;
	unsigned short ret=0;
	struct _packet_reset_srv recv_from_srv;
	memset(&recv_from_srv,0,sizeof(recv_from_srv));
	memcpy(&recv_from_srv,message,1024);
	ntoh_data(&recv_from_srv);

	ret=recv_from_srv.head.ver;
	if(ret != VERSIONNOW)
	{
		return -1;
	}

	ret = recv_from_srv.head.cmd;
    printf("cmd=%2x\n", ret );


	if ( ret <= 0x0217 ){  //zpz-2008.6.6: fix bug: "ret < 0x0217" to "ret <= 0x0217"
    	    temp = recv_from_srv.data[0];       	
   	    if(temp <= 0) {
    		return -1;       	
	    }    
    	    if(temp >= 7){    
    		return -1;    
    	    }    

    	    return temp;
	}
	else if( ret < 0x023F ){  /* #0045-2 guoxd_003 20081117 modify */
	    if(ret==0x0218)  return ALARM_ID_NTP;           /* 时间同步失败 */
		if(ret==0x0220)  return ALARM_ID_FUT;       /* 非法证书用户侵入网络 */
		if(ret==0x0221)  return ALARM_ID_PA;        /* 客户端重放攻击 */
		if(ret==0x0222)  return ALARM_ID_JA;       /* 篡改攻击 */
		if(ret==0x0226)  return ALARM_ID_FIND_UNSAFE_AP;/* #0045-2 piyp 20081208 add+ */
		if (ret == 0x0227) return ALARM_ID_CHANNEL_DISTURB;  /* #0045-2 guoxd_003 20081117 add+ */
		if (ret == 0x0228) return ALARM_ID_CHANNEL_DISTURB_DEVICE;  /* #0045-2 piyp 20090113 add+ 设备*/
		if (ret == 0x0229) return ALARM_ID_CHANNEL_DISTURB_STA;  /* #0045-2 piyp 20090113 add+ 客户端*/
		if (ret == 0x022A) return ALARM_ID_CHANNEL_DISTURB_AP;  /* #0045-2 piyp 20090113 add+ AP*/
		if (ret == 0x0231) return ALARM_ID_CHANNEL_CHANGED;  /* #0045-2 piyp 20090104 add+ */
		if (ret == 0x0223) return ALARM_ID_SECURITY_GRADE_DEBASE_ATTACK;  /* #0045-2 piyp 20081124 add+ */
		if (ret == 0x0224) return ALARM_ID_MAC_CHANGED_DIRECTIONAL_ATTACK;  /* #0045-2 piyp 20081124 add+ */
		if (ret == 0x022B) return ALARM_ID_SUPPLY_CHANNEL_TOO_LOWER;  /* #0045-2 piyp 20081124 add+ */
		if (ret == 0x022C) return ALARM_ID_AP_NOT_ADD_NEW_STA;  /* #0045-2 piyp 20081124 add+ */
		if (ret == 0x022D) return ALARM_ID_RADIUS_SERVER_NOT_CONNECT_AUTH;  /* #0045-2 piyp 20081124 add+ */
		if (ret == 0x022E) return ALARM_ID_RADIUS_SERVER_NOT_CONNECT_ACCOUNT;  /* #0045-2 piyp 20081124 add+ */
		

	}
	else {
	    return -1;
	}
}

int  get_mac_form_apmess(char message[],char macstr[])
{
	int temp=0;
	unsigned short ret=0;
	struct _packet_reset_srv recv_from_srv;
	memset(&recv_from_srv,0,sizeof(recv_from_srv));
	memcpy(&recv_from_srv,message,1024);
	ntoh_data(&recv_from_srv);
	ret=recv_from_srv.head.ver;
	if(ret != VERSIONNOW)
	{
		return -1;
	}
	ret=recv_from_srv.head.cmd;

	if( (ret < 0x0212) ||(ret > 0x022c) )
	{
		return -1;
	}
	sprintf(macstr,"%02x:%02x:%02x:%02x:%02x:%02x",recv_from_srv.data[0],recv_from_srv.data[1],
		                                      recv_from_srv.data[2],recv_from_srv.data[3],
		                                      recv_from_srv.data[4],recv_from_srv.data[5]);
	//macstr[0]=recv_from_srv.data[0];
	//macstr[1]=recv_from_srv.data[1];
	//macstr[2]=recv_from_srv.data[2];
	//macstr[3]=recv_from_srv.data[3];
	//macstr[4]=recv_from_srv.data[4];
	//macstr[5]=recv_from_srv.data[5];
	return 1;
}
int display_message(char message[],int dislen)
{
	int i;
	printf("\n");
	for(i=0;i<dislen;i++){
		printf("%2x  ",message[i]);
		if((i%16)==0)printf("\n");
	}
	return 1;
}

int read_upgrade_info()
{

       ///printf("******************read_upgrade_info*************************\n");

	char *trapStr[]={"","1","2","3","4","5","6"};
       AAT aat;
       prop_data properties[KEYS_MAX];
       int prop_count=0,pid1,pid2,sockfd;
       char ap_parameter[32],message[32];
       time_t nowTimes;
       struct sockaddr_in sin;
       int  sinlen,ret;
       char macstr[30];
       sinlen=sizeof(sin);
	bzero(message, 30);
	recvfrom(upgradSocketFD,message,32,0,(struct sockaddr *)&sin,&sinlen);
	ret=analyze_AP_mess(message);	

	if(ret<=MIN_ALARM_UPD)  {	
            return SNMP_ERR_WRONGVALUE;
	}

    else if (ret< 7){
        memset(&aat,0,sizeof(aat));
    	bzero(ap_parameter, 32);
        time(&nowTimes);
		set_alarm1( & aat,ALARM_ID_REMOT_UPGRADE,ap_parameter,3,1,26,"upgrade ap",nowTimes,1,"upgrade ap",trapStr[ret]);
           
        send_trap_string_notification(&aat);
        
        if(ret==UPGRADE_ERR_GETFILE){		
    		return -1;
    	}	
        if (ret==UPGRADE_ERR_FILE){

    		save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","START_UPGRADE","0");
    		return -1;             			
    	}
        if (ret==UPGRADE_ERR_FAIL) {
    		save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","START_UPGRADE","0");		
    		return -1;  			
    	}			
    	if (ret==UPGRADE_FINISHED_REBOOT){
    		save_global_conf(SEP_EQUAL,AP_BASE_CONF,"","START_UPGRADE","0");	
    		return 1;  
    	}
    }
	else if (ret < MAX_ALARM_UDP){
		memset(&aat,0,sizeof(aat));
        bzero(ap_parameter, 32);
        time(&nowTimes);

	 	/* #0045-2 guoxd_003 20081117 add start */
	 	if (ret == ALARM_ID_CHANNEL_DISTURB){
		    u8 tmp_buff[64];
		    u8 channel_num = *(message + 8);  /* get disturb channel number */
			  	      
		    memset(tmp_buff, 0, sizeof(tmp_buff));
		    sprintf(tmp_buff, "Channel by Disturb Changed to %d", channel_num);

		      /* send trap to server */
			set_alarm(&aat, ALARM_ID_CHANNEL_DISTURB, tmp_buff);
	        send_trap_string_notification(&aat);		
	    	return 1;
	 	}
	 	if(ret==ALARM_ID_CHANNEL_CHANGED){
		 	u8 tmp_buff[64];
		    u8 channel_num = *(message + 8);  /* get disturb channel number */	  	      
		    memset(tmp_buff, 0, sizeof(tmp_buff));
		    sprintf(tmp_buff, "Channel Changed to %d", channel_num);
		    printf("###guoxd debug tmp_buff = %s\n", tmp_buff);
			set_alarm(&aat, ALARM_ID_CHANNEL_CHANGED, tmp_buff);
	        send_trap_string_notification(&aat);		
	    	return 1;
    	}
		if(ret==ALARM_ID_CHANNEL_DISTURB_DEVICE){
		 	u8 tmp_buff[64];
		    u8 channel_num = *(message + 8);  /* get disturb channel number */	  	      
		    memset(tmp_buff, 0, sizeof(tmp_buff));
		    sprintf(tmp_buff, "Channel Changed to %d for disturb by device", channel_num);
			set_alarm(&aat, ALARM_ID_CHANNEL_DISTURB_DEVICE, tmp_buff);
	        send_trap_string_notification(&aat);		
	    	return 1;
    	}
		if(ret==ALARM_ID_CHANNEL_DISTURB_STA){
		 	u8 tmp_buff[64];
		    u8 channel_num = *(message + 8);  /* get disturb channel number */	  	      
		    memset(tmp_buff, 0, sizeof(tmp_buff));
		    sprintf(tmp_buff, "Channel Changed to %d for disturb by station", channel_num);
			set_alarm(&aat, ALARM_ID_CHANNEL_DISTURB_STA, tmp_buff);
	        send_trap_string_notification(&aat);		
	    	return 1;
    	}
		if(ret==ALARM_ID_CHANNEL_DISTURB_AP){
		 	u8 tmp_buff[64];
		    u8 channel_num = *(message + 8);  /* get disturb channel number */	  	      
		    memset(tmp_buff, 0, sizeof(tmp_buff));
		    sprintf(tmp_buff, "Channel Changed to %d for disturb by ap", channel_num);
			set_alarm(&aat, ALARM_ID_CHANNEL_DISTURB_AP, tmp_buff);
	        send_trap_string_notification(&aat);		
	    	return 1;
    	}
	 /* #0045-2 guoxd_003 20081117 add end */
	 
		bzero(macstr, 30);
		get_mac_form_apmess(message,macstr);
        if(ret==ALARM_ID_FUT){		
			set_alarm(&aat, ALARM_ID_FUT, macstr);          
            send_trap_string_notification(&aat);		
    		return 1;
    	}
		if(ret==ALARM_ID_PA){
			fprintf(stderr,"alarm trap PA  \n");
			set_alarm(&aat, ALARM_ID_PA, macstr);           
            send_trap_string_notification(&aat);		
    		return 1;
    	}
		if(ret==ALARM_ID_JA){
			set_alarm(&aat, ALARM_ID_JA, macstr);          
            send_trap_string_notification(&aat);		
    		return 1;
    	}
		if(ret==ALARM_ID_NTP){
			set_alarm(&aat, ALARM_ID_NTP, macstr);          
            send_trap_string_notification(&aat);		
    		return 1;
    	}
		/*************************************************/
		 /* #0045-2 piyp 20081124 add */
		if(ret==ALARM_ID_SECURITY_GRADE_DEBASE_ATTACK){
				set_alarm(&aat, ALARM_ID_SECURITY_GRADE_DEBASE_ATTACK, macstr);           
	            send_trap_string_notification(&aat);		
	    		return 1;
	    }

		if(ret==ALARM_ID_MAC_CHANGED_DIRECTIONAL_ATTACK){
				set_alarm(&aat, ALARM_ID_MAC_CHANGED_DIRECTIONAL_ATTACK, macstr);           
	            send_trap_string_notification(&aat);		
	    		return 1;
	    }
		if(ret==ALARM_ID_SUPPLY_CHANNEL_TOO_LOWER){
				set_alarm(&aat, ALARM_ID_SUPPLY_CHANNEL_TOO_LOWER, macstr);         
	            send_trap_string_notification(&aat);		
	    		return 1;
	    }
		if(ret==ALARM_ID_AP_NOT_ADD_NEW_STA){
				set_alarm(&aat, ALARM_ID_AP_NOT_ADD_NEW_STA, macstr);          
	            send_trap_string_notification(&aat);		
	    		return 1;
	    }
		if(ret==ALARM_ID_RADIUS_SERVER_NOT_CONNECT_AUTH){
				set_alarm(&aat, ALARM_ID_RADIUS_SERVER_NOT_CONNECT_AUTH, "3");           
	            send_trap_string_notification(&aat);		
	    		return 1;
	    }
		if(ret==ALARM_ID_RADIUS_SERVER_NOT_CONNECT_ACCOUNT){
				set_alarm(&aat, ALARM_ID_RADIUS_SERVER_NOT_CONNECT_ACCOUNT, "3");           
	            send_trap_string_notification(&aat);		
	    		return 1;
	    }
		if(ret==ALARM_ID_FIND_UNSAFE_AP){
				set_alarm(&aat, ALARM_ID_FIND_UNSAFE_AP, macstr);           
	            send_trap_string_notification(&aat);		
	    		return 1;
	    }

	
	/***********************************************/
		}
		else {
        	return -1;
		}
}


int save_MSSID_conf1(char *file_name, char *be_key,char *end_key, struct wlan_info_t  wlan_scr_info)
{
	char line[255];
	FILE *fid, *fidw;
	char tmp_file[255]= "";
	int found = -1;
	int i = 0;
	int del_rec = 0;
	int count=0;
	char buf[1024]=""; 
	    sprintf(buf, "%-17.16s%-33.32s%-4.2s%-8.4s%-4.4s%-17.16s%-8.6s%-4.2s%-4.2s%-8.6s",
			wlan_scr_info.dev_name,
			wlan_scr_info.ssid,
			wlan_scr_info.ssid_hide,
			wlan_scr_info.auth,
			wlan_scr_info.psk_type,
			wlan_scr_info.psk_key,
			wlan_scr_info.vlan_id,
			wlan_scr_info.qos,
			wlan_scr_info.mac_cmd,
			wlan_scr_info.max_user);
			
	strcpy(tmp_file, file_name);
	strcat(tmp_file,".snmp");
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}
	if((fidw = fopen(tmp_file, "w")) == NULL)
	{
		printf("Open write config file error!\n");
		return -1;
	}
	
	while (!feof(fid))
	{
		fgets(line, 255, fid);
		if(feof(fid)) break;
		if (strchr(line, '\n'))  *(strchr(line, '\n')) = '\0';

		if(strcmp(line, be_key) == 0)
		 {
			found = 0;
			fprintf(fidw, "%s\n", line);
			continue;
		 }
		if((found == 0) && (strcmp(line, end_key) == 0))
		{
			fprintf(fidw, "%s\n", buf);
			fprintf(fidw, "%s\n", line);
		}
		else
		{
			fprintf(fidw, "%s\n", line);
		}
	
	}
	fclose(fid);
	fclose(fidw);
	unlink(file_name);
	rename(tmp_file, file_name);
	return 0;
}
int  save_MSSID_conf(char *file_name, const char *be_key, const char *end_key, char *value)
{
	char line[255];
	FILE *fid, *fidw;
	char tmp_file[255]= "";
	int found = -1;
	int i = 0;
	int del_rec = 0;
	strcpy(tmp_file, file_name);
	strcat(tmp_file,".snmp");
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}
	if((fidw = fopen(tmp_file, "w")) == NULL)
	{
		printf("Open write config file error!\n");
		return -1;
	}
	
	while (!feof(fid))
	{
		fgets(line, 255, fid);
		if(feof(fid)) break;
		if (strchr(line, '\n'))  *(strchr(line, '\n')) = '\0';
		if(strcmp(line, be_key) == 0)
		 {
			found = 0;
			fprintf(fidw, "%s\n", line);
			continue;
		 }
	#if 0	
		if(strcmp(line, end_key) == 0)
		 {
			break;
		 }	
		else
	#endif
		if((found == 0) && (strcmp(line, end_key) == 0))
		{
			fprintf(fidw, "%s\n", value);
			fprintf(fidw, "%s\n", line);
		}
		else
		{
			fprintf(fidw, "%s\n", line);
		}
	
	}
	fclose(fid);
	fclose(fidw);
	unlink(file_name);
	rename(tmp_file, file_name);
	return 0;
}

int  find_mssid_wlan(char *file_name, const char *be_key, const char *end_key, char *dev_name)
{
	char line[255];
	FILE *fid;
	int found = -1;
	int i = 0;
	int del_rec = 0;
	struct wlan_info_t wlan_info_item;
	
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}
	
	while (!feof(fid))
	{
		fgets(line, 255, fid);
		if(feof(fid)) break;
		if (strchr(line, '\n'))  *(strchr(line, '\n')) = '\0';

		if(strcmp(line, be_key) == 0)
		 {
			found = 0;
			continue;
		 }
		if(strcmp(line, end_key) == 0)
		 {
			break;
		 }	

		memset(&wlan_info_item, 0, sizeof(struct wlan_info_t));

		sscanf(line,"%s%s%s%s%s%s%s%s",
		wlan_info_item.dev_name, 
		wlan_info_item.ssid, 
		wlan_info_item.ssid_hide, 
		wlan_info_item.auth, 
		wlan_info_item.psk_type,
		wlan_info_item.psk_key,
		wlan_info_item.vlan_id,
		wlan_info_item.qos);
		if(strncmp(wlan_info_item.dev_name, dev_name, strlen(dev_name)) == 0){
			fclose(fid);
			return 1;
		}
	}
	fclose(fid);
	return 0;
}


int  find_mssid_count(char *file_name, const char *be_key, const char *end_key, char *dev_name,int  *findFlag)
{
	char line[255];
	FILE *fid;
	int i = 0;
	int found_b = -1;
	int found_e = -1;
	int count=0;

	struct wlan_info_t wlan_info_item;
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}

	while (!feof(fid))
	{	    
   	    fscanf(fid, "%[^\n]\n", line);
	    if(strcmp(line, be_key) == 0)
	    {
	        found_b = 0;
		continue;
            }
	    if(strcmp(line, end_key) == 0)
	    {
		found_e = 0;
		break;
	    }
	    if((found_b == 0) && (found_e != 0) )
	    {	
	      count++;
		memset(&wlan_info_item, 0, sizeof(struct wlan_info_t));

		sscanf(line,"%s%s%s%s%s%s%s%s%s%s",
		wlan_info_item.dev_name, 
		wlan_info_item.ssid, 
		wlan_info_item.ssid_hide, 
		wlan_info_item.auth, 
		wlan_info_item.psk_type,
		wlan_info_item.psk_key,
		wlan_info_item.vlan_id,
		wlan_info_item.qos,
		wlan_info_item.mac_cmd,
		wlan_info_item.max_user
		);

		if(strncmp(wlan_info_item.dev_name, dev_name, strlen(dev_name)) == 0){
			*findFlag=1;
			fclose(fid);
			return count;
		}
	    }
	}
	fclose(fid);
	return count;
}
int init_wlanname_table( char devName[])
{
	int i=0;
	struct mssid_wlan_table mwt[MSSID_NUMBER] ;
	struct mssid_wlan_table *mp;
	mp=mwt;
	bzero(mwt, sizeof(mwt));
	for(i=0;i<MSSID_NUMBER;i++,mp++){
		sprintf(mp->wlan,"ath%d",i);// by sunyushuang0321
		mp->flag= find_mssid_wlan(WLAN_CONFIG, WLAN_BEGIN, WLAN_END,mp->wlan); 	
		printf("\t %d %d  %s \n",i,mp->flag,mp->wlan);
	}
	
	mp=mwt;
	for(i=0;i<MSSID_NUMBER;i++,mp++){
		printf("\n\t %d %d  %s \n",i,mp->flag,mp->wlan);
		if(mp->flag==0){
			strcpy(devName,mp->wlan);
			return 1;
		}
	}
	return -1;

}

int add_valn_to_mssid(char *file_name,   const char *be_key,  const char *end_key,int vlanid,struct wlan_info_t  wlanInfo) 
{
	char line[255];
	FILE *fid;
	int i = 0,ret=0;
	int found_b = -1;
	int found_e = -1;
	int flag=-1;
    if ((vlanid < 0)||(vlanid > 4096)){
		printf("vlanid=%d\n",vlanid);
	   	return flag;
    }
	if(strlen(wlanInfo.ssid)==0){
		printf("wlanInfo.ssid=%s\n",wlanInfo.ssid);
		printf("wlanInfo.ssid_len=%d\n",strlen(wlanInfo.ssid));
       	return flag;
	}
	struct wlan_info_t wlan_info_item;
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}

	while (!feof(fid))
	{	    
   	    fscanf(fid, "%[^\n]\n", line);
	    if(strcmp(line, be_key) == 0)
	    {
	        found_b = 0;
		continue;
            }
	    if(strcmp(line, end_key) == 0)
	    {
		found_e = 0;
		break;
	    }
	    if((found_b == 0) && (found_e != 0) )
	    {	
		memset(&wlan_info_item, 0, sizeof(struct wlan_info_t));

		sscanf(line,"%s%s%s%s%s%s%s%s%s%s",
		wlan_info_item.dev_name, 
		wlan_info_item.ssid, 
		wlan_info_item.ssid_hide, 
		wlan_info_item.auth, 
		wlan_info_item.psk_type,
		wlan_info_item.psk_key,
		wlan_info_item.vlan_id,
		wlan_info_item.qos,
		wlan_info_item.mac_cmd,
		wlan_info_item.max_user
		);              
		
		if(strcmp(wlan_info_item.ssid, wlanInfo.ssid)==0){
			fclose(fid);
			return flag;
		}
		ret=atoi(wlan_info_item.vlan_id);
		if(ret==vlanid){
			fclose(fid);
			return  flag;
		}
	    }
	}
	fclose(fid);
	flag=1;
	return flag;
}

int add_valn_is_same_vlanid(char *file_name,   const char *be_key,  const char *end_key,int vlanid) 
{
	char line[255];
	FILE *fid;
	int i = 0,ret=0;
	int found_b = -1;
	int found_e = -1;
	int flag=-1;
       if ((vlanid<2)||(vlanid>4096))
	   	return flag;
	struct wlan_info_t wlan_info_item;
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}

	while (!feof(fid))
	{	    
   	    fscanf(fid, "%[^\n]\n", line);
	    if(strcmp(line, be_key) == 0)
	    {
	        found_b = 0;
		continue;
            }
	    if(strcmp(line, end_key) == 0)
	    {
		found_e = 0;
		break;
	    }
	    if((found_b == 0) && (found_e != 0) )
	    {	
		memset(&wlan_info_item, 0, sizeof(struct wlan_info_t));

		sscanf(line,"%s%s%s%s%s%s%s%s%s%s",
		wlan_info_item.dev_name, 
		wlan_info_item.ssid, 
		wlan_info_item.ssid_hide, 
		wlan_info_item.auth, 
		wlan_info_item.psk_type,
		wlan_info_item.psk_key,
		wlan_info_item.vlan_id,
		wlan_info_item.qos,
		wlan_info_item.mac_cmd,
		wlan_info_item.max_user
		);        
		
		ret=atoi(wlan_info_item.vlan_id);
		if(ret==vlanid){
			fclose(fid);
			return  flag;
		}
	    }
	}
	fclose(fid);
	flag=1;
	return flag;
}

int add_valn_is_same_ssid(char *file_name,   const char *be_key,  const char *end_key,char *wlanInfo) 
{
	char line[255];
	FILE *fid;
	int i = 0,ret=0;
	int found_b = -1;
	int found_e = -1;
	int flag=-1;
	if(strlen(wlanInfo)==0){
             return flag;
	}
	struct wlan_info_t wlan_info_item;
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}

	while (!feof(fid))
	{	    
   	    fscanf(fid, "%[^\n]\n", line);
	    if(strcmp(line, be_key) == 0)
	    {
	        found_b = 0;
		continue;
            }
	    if(strcmp(line, end_key) == 0)
	    {
		found_e = 0;
		break;
	    }
	    if((found_b == 0) && (found_e != 0) )
	    {	
		memset(&wlan_info_item, 0, sizeof(struct wlan_info_t));

		sscanf(line,"%s%s%s%s%s%s%s%s%s%s",
		wlan_info_item.dev_name, 
		wlan_info_item.ssid, 
		wlan_info_item.ssid_hide, 
		wlan_info_item.auth, 
		wlan_info_item.psk_type,
		wlan_info_item.psk_key,
		wlan_info_item.vlan_id,
		wlan_info_item.qos,
		wlan_info_item.mac_cmd,
		wlan_info_item.max_user
		);             
     
		if(strcmp(wlan_info_item.ssid, wlanInfo)==0){
			fclose(fid);
			return flag;
		}
	    }
	}
	fclose(fid);
	flag=1;
	return flag;
}

int  count_mssib(char *file_name,   const char *be_key,  const char *end_key)
{
	char line[255];
	FILE *fid;
	int i = 0;
	int found_b = -1;
	int found_e = -1;
	int count=0;

	struct wlan_info_t wlan_info_item;
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}

	while (!feof(fid))
	{	    
   	    fscanf(fid, "%[^\n]\n", line);
	    if(strcmp(line, be_key) == 0)
	    {
	        found_b = 0;
		continue;
            }
	    if(strcmp(line, end_key) == 0)
	    {
		found_e = 0;
		break;
	    }
	    if((found_b == 0) && (found_e != 0) )
	    {	
		memset(&wlan_info_item, 0, sizeof(struct wlan_info_t));

		sscanf(line,"%s%s%s%s%s%s%s%s%s%s",
		wlan_info_item.dev_name, 
		wlan_info_item.ssid, 
		wlan_info_item.ssid_hide, 
		wlan_info_item.auth, 
		wlan_info_item.psk_type,
		wlan_info_item.psk_key,
		wlan_info_item.vlan_id,
		wlan_info_item.qos,
		wlan_info_item.mac_cmd,
		wlan_info_item.max_user
		);
		if(strstr(wlan_info_item.dev_name, "wlan") !=NULL){
			count++;
		}
	    }
	}
	fclose(fid);
	return count;
}
int del_MSSID_conf(char *file_name, char *be_key,char *end_key, unsigned int  modfiyCount)
{
	char line[255];
	FILE *fid, *fidw;
	char tmp_file[255]= "";
	int found = -1;
	int i = 0;
	int del_rec = 0;
	int count=0;
	char buf[1024]="";			
	strcpy(tmp_file, file_name);
	strcat(tmp_file,".snmp");
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}
	if((fidw = fopen(tmp_file, "w")) == NULL)
	{
		printf("Open write config file error!\n");
		return -1;
	}
	
	while (!feof(fid))
	{
		fgets(line, 255, fid);
		if(feof(fid)) break;
		if (strchr(line, '\n'))  *(strchr(line, '\n')) = '\0';

		if(strcmp(line, be_key) == 0)
		 {
			found = 0;
			fprintf(fidw, "%s\n", line);
			continue;
		 }
		
		if((found == 0) && (strcmp(line, end_key) != 0))
		{
			count++;
			if(count!=modfiyCount)
			{
				fprintf(fidw, "%s\n", line);
			}
			else
			{
				//if(buf != NULL) fprintf(fidw, "%s\n", buf);
			}
			i++;
		}
		else
		{
			fprintf(fidw, "%s\n", line);
		}
	
	}
	fclose(fid);
	fclose(fidw);
	unlink(file_name);
	rename(tmp_file, file_name);
	return 0;
}

int index_read_SSID(char *file_name, char *be_key,char *end_key, unsigned int  index,struct wlan_info_t *wlan_info)
{
	char line[255];
	FILE *fid;
	int i = 0;
	int found_b = -1;
	int found_e = -1;
	int count=0;

	struct wlan_info_t wlan_info_item;
	
	if((fid = fopen(file_name, "r")) == NULL)
	{
		printf("Open read config file error!\n");
		return -1;
	}

	while (!feof(fid))
	{	    
   	    fscanf(fid, "%[^\n]\n", line);
	    if(strcmp(line, be_key) == 0)
	    {
	        found_b = 0;
		continue;
            }
	    if(strcmp(line, end_key) == 0)
	    {
		found_e = 0;
		break;
	    }
	    if((found_b == 0) && (found_e != 0) )
	    {	
	       count++;
		if(count==index){
		    sscanf(line,"%s%s%s%s%s%s%s%s%s%s",
		        wlan_info_item.dev_name, 
			 wlan_info_item.ssid, 
			 wlan_info_item.ssid_hide, 
			 wlan_info_item.auth, 
			 wlan_info_item.psk_type,
			 wlan_info_item.psk_key,
			 wlan_info_item.vlan_id,
			 wlan_info_item.qos,
			 wlan_info_item.mac_cmd,
			 wlan_info_item.max_user
			 );
		    memcpy(wlan_info,&wlan_info_item,sizeof(struct wlan_info_t));
		    fclose(fid);
		    return 1 ;
		}
	    }
	}
	fclose(fid);
	return count;
}
void display_mssid(struct wlan_info_t mssid)
{
	struct wlan_info_t  *wp;
	wp=&mssid;
	printf("\n\tdev_name:%s\n\tssid:%s\n\tssid_hide:%s\n\tauth:%s\n\tpsk_type:%s\n\tpsk_key:%s   \
		\n\tvlan_id:%s\n\tqos:%s\n\tmac_cmd:%s \n\tmax_user:%s\n",
		   wp->dev_name,wp->ssid,wp->ssid_hide,wp->auth,wp->psk_type, wp->psk_key,
		   wp->vlan_id,wp->qos,wp->mac_cmd,wp->max_user);
}

int save_community_conf(char type, char* filename, char *command, char *key, char *value)
{
	FILE* fidIn, *fidOut;
	char line[1024], tmp_line[1024];
        char tmp_fname[255], *index;
        char separator[2];
        int i=0;
	
	if ((fidIn=fopen(filename,"r"))==NULL) return 0;
	strcpy(tmp_fname,filename);	
	strcat(tmp_fname,".snmp");
	
        if ((fidOut=fopen(tmp_fname,"w"))==NULL) return 0;

        strcpy(separator,(type==SEP_EQUAL?"=":type==SEP_SPACE?" ":"\t"));
        type=separator[0];

	while(!feof(fidIn))
	{
		fgets(line,1024,fidIn);
                strcpy(tmp_line,command);
                strcat(tmp_line,key);
                if (((index=strstr(line,tmp_line))!=NULL) && (index==line)) {
                    i=1;
                    if (!feof(fidIn)) {
                        if (type != '0')
                            fprintf(fidOut,"%s%s%c%s\n",command,key,type,value);
                        else
                            fprintf(fidOut,"%s%%c%s\n",command,key,value);
                    }
                } else
                    if (!feof(fidIn)) fprintf(fidOut,"%s",line);
        }

        if (i==0) {
            if (type != '0') { fprintf(fidOut,"%s%s%c%s\n",command,key,type,value); }
            else fprintf(fidOut,"%s%s%s\n",command,key,value);
        }
             
	fclose(fidIn);
	fclose(fidOut);
	unlink(filename);
	rename(tmp_fname,filename);
	return 1;
}

int get_channel(int skfd,char *ifname)
{
	struct iwreq		wrq;
	struct iw_range	range;
	double		freq;
	int			channel = 0;
	char buffer[128]={0,};
	/* Get list of frequencies / channels */
	if(iw_get_range_info(skfd, ifname, &range) < 0)
	{
		return 0;
	}

	if(iw_get_ext(skfd, ifname, SIOCGIWFREQ, &wrq) >= 0)
	{
		freq = iw_freq2float(&(wrq.u.freq));
		iw_print_freq(buffer, freq);
		channel = iw_freq_to_channel(freq, &range);
		if(channel < 0)
		{
			channel = 0;
		}
	}
	return channel;  
}

int  iw_enum_channel(int ifs, int * channel)
{
	char		buff[1024]={0,};
	FILE *	fh;
	int		i=0;
	int skfd = -1;

	char tmp_txt[128]={0,}; 

	if((skfd = iw_sockets_open()) < 0)
	{
		return 0;
	}
	fh = fopen(PROC_NET_WIRELESS, "r");

	if(fh != NULL)
	{
		/* Eat 2 lines of header */
		fgets(buff, sizeof(buff), fh);
		fgets(buff, sizeof(buff), fh);

		/* Read each device line */
		while(fgets(buff, sizeof(buff), fh) && (ifs>0))
		{
			char	name[IFNAMSIZ + 1];
			char *s;
			/* Extract interface name */
			s = iw_get_ifname(name, sizeof(name), buff);

			if(!s){
				channel[i]=0; 
				goto exit;
			}
			else
			{ 	
				/* Got it, print info about this interface */
				// (*fn)(skfd, name, args, count);
				bzero(buff,0);
				channel[i] = get_channel(skfd, name);
			}
			i++;  ifs--;
		}

	fclose(fh);
	}
exit:	
	close(skfd);
	return i;
}

int exec_cmd(const unsigned char *cmd)
{
        FILE *fp = NULL;

        if ((fp = popen(cmd, "r")) == NULL)
        {
                if (fp != NULL)
                        pclose(fp);
                return -1;
        }
        if (fp != NULL)
                pclose(fp);

        return 0;
}

/* #0045-2 guoxd_004 20081129 add start */
int write_wapiConfigPSKPassPhrase(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int ret = 0;
    int index = 0;
    int policy = 0;
    int psk_type = 0;
    unsigned char buff[256];
    struct wlan_info_t  wlan_scr_info;
	
    switch ( action ) {
       case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len < 8 * sizeof(char) || var_val_len > 64 * sizeof(char)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   break;
	   
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
			
	  memset(&wlan_scr_info, 0, sizeof(wlan_scr_info));

	  /* get index for table(1, 2, 3, 4, .....) */			
	  index = name[12];

	  ret = index_read_SSID(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, index, &wlan_scr_info);
	  if(ret == 0){
            fprintf(stderr,"write to wapiMssidWlanSSID: not config wlan \n");
            return SNMP_ERR_NOCREATION;
	  }

	  /* judge is PSK mode ? */
 	  policy = atoi(wlan_scr_info.auth);

	  /* 0: open; 7: psk; 11: cert mode*/
	  if (policy != 7)
	  {
	  	  return SNMP_ERR_WRONGTYPE;
	  }

	  /* check input */
	  psk_type = atoi(wlan_scr_info.psk_type);
	  if (psk_type == 1)/* HEX */
	  {
	  	if ((var_val_len % 2) != 0)
			return SNMP_ERR_WRONGLENGTH;

		if (!wapi_is_hex_str(var_val, var_val_len))
			return SNMP_ERR_WRONGTYPE;
	  }

	  /* update the psk value */
	  memset(wlan_scr_info.psk_key, 0, sizeof(wlan_scr_info.psk_key));
	  memcpy(wlan_scr_info.psk_key, var_val, var_val_len);
	  /* save one ssid information  */
	  set_wlan_table(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, index, wlan_scr_info);

#if 1
	  memset(buff, 0, sizeof(buff));
	  /* set cmd */
	  write_word(buff, CGI_CMD_RELOAD, 2);

	  /* reboot wapid */
	  ret = wapi_notify_wapid(buff, 4, sizeof(buff) - 1);
#endif
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
/* #0045-2 guoxd_004 20081129 add end */


/* #0045-2 guoxd_001 20081103 add start */
int write_wapiConfigUnicastRekeyMethod(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];
    unsigned char rekey_buff[32];
    int offset = 2;
    int len = 4+4+4+4;
    int ret = -1;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (unsigned long *) var_val ;
	   if ((value < WAPI_REKEY_U_POLICY_NONE) || (value > WAPI_REKEY_U_POLICY_TANDP))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", WAPI_REKEY_U_POLICY_STR, temp);
	   rekey_u_policy = *(unsigned int *)var_val;

          /* process policy */
	   memset(rekey_buff, 0, sizeof(rekey_buff));
	   /* set cmd */
	   write_word(rekey_buff, CGI_CMD_REKEY, offset);
	   offset += 2;	   
	   /* set rekey type */
	   write_word(rekey_buff, WAPI_REKEY_TYPE_UNICAST, offset);
	   offset += 2;	   
	   /* set rekey policy */
	   write_word(rekey_buff, rekey_u_policy, offset);
	   offset += 2;

	   /* notify the wapid */
	   ret = wapi_notify_wapid(rekey_buff, len, sizeof(rekey_buff) -1);

          /* respond ...... */
		  
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int write_wapiConfigUnicastRekeyTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];
    unsigned char rekey_buff[32];
    int offset = 2;
    int len = 4+4+4+4;
    int ret = -1;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   /* five minutes ~~  one year */
	   if ((value < 300) || (value > 31536000))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", WAPI_REKEY_U_TIME_STR, temp);

          /* process time value ... */
	   rekey_u_seconds= *(unsigned int *)var_val;

	   {
		   memset(rekey_buff, 0, sizeof(rekey_buff));
		   /* set cmd */
		   write_word(rekey_buff, CGI_CMD_REKEY, offset);
		   offset += 2;	   
		   /* set rekey type */
		   write_word(rekey_buff, WAPI_REKEY_TYPE_UNICAST, offset);
		   offset += 2;	   
		   /* set rekey policy */
		   write_word(rekey_buff, rekey_u_policy, offset);
		   offset += 2;
		   /* set timeout value */
		   write_dword(rekey_buff, rekey_u_seconds, offset);

		   /* notify the wapid */
		   ret = wapi_notify_wapid(rekey_buff, len, sizeof(rekey_buff) -1);  

	          /* repond ...... */
	
	   }
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int write_wapiConfigUnicastRekeyPackets(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   /* 1073741824 = 1024 * 1024 * 1024 */
	   if ((value < 1048576) || (value > 1073741824))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", WAPI_REKEY_U_PACKET_STR, temp);

          /* process packet value ... */
	   rekey_u_packets = *(unsigned int *)var_val;
		  
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}




/* #0045-2 guoxd_002 20081109 add start */
int write_wapiConfigMulticastRekeyMethod(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];
    unsigned char rekey_buff[32];
    int offset = 2;
    int len = 4+4+4+4;
    int ret = -1;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (unsigned long *) var_val ;
	   if ((value < WAPI_REKEY_M_POLICY_NONE) || (value > WAPI_REKEY_M_POLICY_TANDP))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", WAPI_REKEY_M_POLICY_STR, temp);
	   rekey_m_policy = *(unsigned int *)var_val;

          /* process policy */
	   memset(rekey_buff, 0, sizeof(rekey_buff));
	   /* set cmd */
	   write_word(rekey_buff, CGI_CMD_REKEY, offset);
	   offset += 2;	   
	   /* set rekey type */
	   write_word(rekey_buff, WAPI_REKEY_TYPE_MULTI, offset);
	   offset += 2;	   
	   /* set rekey policy */
	   write_word(rekey_buff, rekey_m_policy, offset);
	   offset += 2;

	   /* notify the wapid */
	   ret = wapi_notify_wapid(rekey_buff, len, sizeof(rekey_buff) -1);

          /* repond ...... */
		  
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int write_wapiConfigMulticastRekeyTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];
    unsigned char rekey_buff[32];
    int offset = 2;
    int len = 4+4+4+4;
    int ret = -1;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   /* five minutes ~~  one year */
	   if ((value < 300) || (value > 31536000))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", WAPI_REKEY_M_TIME_STR, temp);

          /* process time value ... */
	   rekey_m_seconds = *(unsigned int *)var_val;

	   {
		   memset(rekey_buff, 0, sizeof(rekey_buff));
		   /* set cmd */
		   write_word(rekey_buff, CGI_CMD_REKEY, offset);
		   offset += 2;	   
		   /* set rekey type */
		   write_word(rekey_buff, WAPI_REKEY_TYPE_MULTI, offset);
		   offset += 2;	   
		   /* set rekey policy */
		   write_word(rekey_buff, rekey_m_policy, offset);
		   offset += 2;
		   /* set timeout value */
		   write_dword(rekey_buff, rekey_m_seconds, offset);

		   /* notify the wapid */
		   ret = wapi_notify_wapid(rekey_buff, len, sizeof(rekey_buff) -1);  

	          /* repond ...... */
	
	   }
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int write_wapiConfigMulticastRekeyPackets(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   /* 1073741824 = 1024 * 1024 * 1024 */
	   if ((value < 1048576) || (value > 1073741824))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", WAPI_REKEY_M_PACKET_STR, temp);

          /* process packet value ... */
	   rekey_m_packets = *(unsigned int *)var_val;
		  
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



int write_wapiConfigMulticastRekeyStrict(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];
    unsigned char rekey_buff[32];
    int offset = 2;
    int len = 2+2+4;
    int ret = -1;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (long *) var_val ;
	   if ((value != 0) && (value != 1))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", "STA_LEAVE_REKEY_M", temp);

	   /* notify wapid */
	   memset(rekey_buff, 0, sizeof(rekey_buff));
	   /* set cmd */
	   write_word(rekey_buff, CGI_CMD_REKEY_M_LEAVE, offset);
	   offset += 2;
	   /* set value */
	   write_dword(rekey_buff, *(unsigned long *) var_val, offset);

	   /* notify the wapid */
	   ret = wapi_notify_wapid(rekey_buff, len, sizeof(rekey_buff) - 1);
	   
          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
/* #0045-2 guoxd_002 20081109 add end */



/* #0045-2 guoxd_002 20081225 add start */
int write_wapiConfigCertificateUpdateCount(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];
    unsigned char buff[32];
    int offset = 2;
    int len = 2+2+4;
    int ret = -1;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (unsigned long *) var_val ;
	   if ((value < WAPI_REPLAY_MIN_VALUE) || (value > WAPI_REPLAY_MAX_VALUE))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", WAPI_REPLAY_LIMIT_CERT_STR, temp);

          /* process policy */
	   memset(buff, 0, sizeof(buff));
	   /* set cmd */
	   write_word(buff, CGI_CMD_REPLAY_LIMIT_CERT, offset);
	   offset += 2;	   
	   /* set rekey type */
	   write_dword(buff, *(unsigned long *) var_val, offset);

	   /* notify the wapid */
	   ret = wapi_notify_wapid(buff, len, sizeof(buff) -1);

          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



int write_wapiConfigUnicastUpdateCount(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];
    unsigned char buff[32];
    int offset = 2;
    int len = 2+2+4;
    int ret = -1;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (unsigned long *) var_val ;
	   if ((value < WAPI_REPLAY_MIN_VALUE) || (value > WAPI_REPLAY_MAX_VALUE))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", WAPI_REPLAY_LIMIT_USK_STR, temp);

          /* process policy */
	   memset(buff, 0, sizeof(buff));
	   /* set cmd */
	   write_word(buff, CGI_CMD_REPLAY_LIMIT_USK, offset);
	   offset += 2;	   
	   /* set rekey type */
	   write_dword(buff, *(unsigned long *) var_val, offset);

	   /* notify the wapid */
	   ret = wapi_notify_wapid(buff, len, sizeof(buff) -1);

          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int write_wapiConfigMulticastUpdateCount(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char temp[16];
    unsigned char buff[32];
    int offset = 2;
    int len = 2+2+4;
    int ret = -1;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to wapiPwlanAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to wapiPwlanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
   	   value = * (unsigned long *) var_val ;
	   if ((value < WAPI_REPLAY_MIN_VALUE) || (value > WAPI_REPLAY_MAX_VALUE))
		return SNMP_ERR_WRONGVALUE;
	   break;	  
        case RESERVE2:
          break;
        case FREE:
	      break;
        case ACTION:
	   memset(temp, 0, sizeof(temp));
          sprintf(temp,"%ld",*(unsigned long *) var_val);
          save_global_conf(SEP_EQUAL, WLAN_CONFIG, "", WAPI_REPLAY_LIMIT_MSK_STR, temp);

          /* process policy */
	   memset(buff, 0, sizeof(buff));
	   /* set cmd */
	   write_word(buff, CGI_CMD_REPLAY_LIMIT_MSK, offset);
	   offset += 2;	   
	   /* set rekey type */
	   write_dword(buff, *(unsigned long *) var_val, offset);

	   /* notify the wapid */
	   ret = wapi_notify_wapid(buff, len, sizeof(buff) -1);

          break;
        case UNDO:
          break;
        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}
/* #0045-2 guoxd_002 20081225 add end */




/* ---------------------------------------------------------------------------------------
 * [Name]     wapi_is_wapi_by_devname
 * [Function]   judge for wapi 
 * [Input]       const unsigned char *dev_name
 * [Output]     NULL 
 * [Return]     int		
 *                               -1    error
 *					0	wapi disable
 *					1     wapi enable		
 * [Limitation] NULL
 * ---------------------------------------------------------------------------------------
 */
static int wapi_is_wapi_by_devname(const unsigned char *dev_name)
{
	int ret = -1;
	int policy = -1;
	struct wlan_info_t wlaninfo;

	/* check the param */
	if (dev_name == NULL)
		return ret;

	/* clean buffer */
	memset(&wlaninfo, 0, sizeof(wlaninfo));

	/* search the wireless device information by name */
	serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, dev_name,&wlaninfo); 

	/* funciton return */
	policy = atoi(wlaninfo.auth);
	if (policy == 0)
		ret = 0;
	else
		ret = 1;
	
	return ret;
}


/* ---------------------------------------------------------------------------------------
 * [Name]     wapi_is_psk_by_devname
 * [Function]   judge for psk 
 * [Input]       const unsigned char *dev_name
 * [Output]     NULL 
 * [Return]     int		
 *                               -1    error
 *					0	psk disable
 *					1     psk enable		
 * [Limitation] NULL
 * ---------------------------------------------------------------------------------------
 */
static int wapi_is_psk_by_devname(const unsigned char *dev_name)
{
	int ret = -1;
	int policy = -1;
	struct wlan_info_t wlaninfo;

	/* check the param */
	if (dev_name == NULL)
		return ret;

	/* clean buffer */
	memset(&wlaninfo, 0, sizeof(wlaninfo));

	/* search the wireless device information by name */
	serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, dev_name,&wlaninfo); 

	policy = atoi(wlaninfo.auth);

	/* funciton return */
	if (policy & 0x04)
		ret = 1;
	else
		ret = 0;
	
	return ret;
}



/* ---------------------------------------------------------------------------------------
 * [Name]      wapi_is_cert_by_devname
 * [Function]   judge for cert 
 * [Input]       const unsigned char *dev_name
 * [Output]     NULL 
 * [Return]     int		
 *                               -1    error
 *					0	cert disable
 *					1     cert enable		
 * [Limitation] NULL
 * ---------------------------------------------------------------------------------------
 */
static int wapi_is_cert_by_devname(const unsigned char *dev_name)
{
	int ret = -1;
	int policy = -1;
	struct wlan_info_t wlaninfo;

	/* check the param */
	if (dev_name == NULL)
		return ret;

	/* clean buffer */
	memset(&wlaninfo, 0, sizeof(wlaninfo));

	/* search the wireless device information by name */
	serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, dev_name,&wlaninfo);

	policy = atoi(wlaninfo.auth);

	/* funciton return */
	if (policy & 0x08)
		ret = 1;
	else
		ret = 0;
	
	return ret;
}


/* ---------------------------------------------------------------------------------------
 * [Name]     wapi_read_reusk_info
 * [Function]   read the usk update information 
 * [Input]       int index
 * [Output]     NULL 
 * [Return]     int		
 *                               -1       fail
 *				      >= 0   values	
 * [Limitation] NULL
 * ---------------------------------------------------------------------------------------
 */
static int wapi_read_reusk_info(int index)
{
	int ret = -1;
	FILE *fp = NULL;
	prop_data properties[KEYS_MAX];
	int prop_count = 0;
	unsigned char ap_parameter[64];
	unsigned char *symbol = NULL;
	
	switch (index)
	{
		case WAPI_REKEY_U_POLICY:
			/* read rekey policy */
			symbol = WAPI_REKEY_U_POLICY_STR;
			break;

		case WAPI_REKEY_U_TIME:
			/* read rekey timeout seconds */
			symbol = WAPI_REKEY_U_TIME_STR;
			break;
			
		case WAPI_REKEY_U_PACKET:
			/* read rekey packets */
			symbol = WAPI_REKEY_U_PACKET_STR;
			break;

		default:
			break;			
	}

	if (symbol != NULL)
	{
		/* clean buffer  */
		memset(properties, 0, sizeof(properties));
		memset(ap_parameter, 0, sizeof(ap_parameter));

		/* read ap config file */		
	       prop_count = load_prop(SEP_EQUAL,WLAN_CONFIG,properties);
	       get_prop(symbol, ap_parameter, properties, prop_count);
	       free_prop(properties,prop_count) ;

		/* get the actual value */
		ret = atoi(ap_parameter);
	}

	return ret;

}



/* ---------------------------------------------------------------------------------------
 * [Name]      wapi_read_remsk_info
 * [Function]   read the msk update information 
 * [Input]       int index
 * [Output]     NULL 
 * [Return]     int		
 *                               -1       fail
 *				      >= 0   values	
 * [Limitation] NULL
 * ---------------------------------------------------------------------------------------
 */
static int wapi_read_remsk_info(int index)
{
	int ret = -1;
	FILE *fp = NULL;
	prop_data properties[KEYS_MAX];
	int prop_count = 0;
	unsigned char ap_parameter[64];
	unsigned char *symbol = NULL;
	
	switch (index)
	{
		case WAPI_REKEY_M_POLICY:
			/* read rekey policy */
			symbol = WAPI_REKEY_M_POLICY_STR;
			break;

		case WAPI_REKEY_M_TIME:
			/* read rekey timeout seconds */
			symbol = WAPI_REKEY_M_TIME_STR;
			break;
			
		case WAPI_REKEY_M_PACKET:
			/* read rekey packets */
			symbol = WAPI_REKEY_M_PACKET_STR;
			break;

		default:
			break;			
	}

	if (symbol != NULL)
	{
		/* clean buffer  */
		memset(properties, 0, sizeof(properties));
		memset(ap_parameter, 0, sizeof(ap_parameter));

		/* read ap config file */		
	       prop_count = load_prop(SEP_EQUAL,WLAN_CONFIG,properties);
	       get_prop(symbol, ap_parameter, properties, prop_count);
	       free_prop(properties,prop_count) ;

		/* get the actual value */
		ret = atoi(ap_parameter);
	}

	return ret;

}



/* #0045-2 guoxd_002 20081109 add start */
/* ---------------------------------------------------------------------------------------
 * [Name]     wapi_read_int_for_key
 * [Function]   read the config file information 
 * [Input]       unsigned char *filename
 *                  unsigned char *key
 * [Output]     NULL 
 * [Return]     int		
 *                               -1       fail
 *				      >= 0   values	
 * [Limitation] NULL
 * ---------------------------------------------------------------------------------------
 */
static int wapi_read_int_for_key(unsigned char *filename, unsigned char *key)
{
	int ret = -1;
	FILE *fp = NULL;
	prop_data properties[KEYS_MAX];
	int prop_count = 0;
	unsigned char ap_parameter[64];
	unsigned char *symbol = NULL;

	if (filename == NULL || key == NULL)
	{
		return ret;
	}

	/* clean buffer  */
	memset(properties, 0, sizeof(properties));
	memset(ap_parameter, 0, sizeof(ap_parameter));

	/* read ap config file */		
       prop_count = load_prop(SEP_EQUAL,filename,properties);
       get_prop(key, ap_parameter, properties, prop_count);
       free_prop(properties,prop_count) ;

	/* get the actual value */
	ret = atoi(ap_parameter);

	return ret;

}
/* #0045-2 guoxd_002 20081109 add end */


static int wapi_notify_wapid(unsigned char *buff, int len, int max_len)
{
       struct srv_info wai_srv;
	//unsigned char recv_buff[1024];  /* #0045-2 guoxd_004 20081126 del */
	const unsigned char  *loop_ip = "127.0.0.1";
	int ret = -1;

	/* check the param */
	if(buff == NULL || len <= 0 || max_len < len)
	{		
		return ret;
	}

	/* clean buffer */
	memset(&wai_srv, 0, sizeof(struct srv_info));

	/* init server information */
	wai_srv.port = WAI_WEB_PORT;
	ret = init_srv_info(&wai_srv, loop_ip);
	if(ret == 0)
	{    
		goto err_exit;
	}

	/* send request to wapid program */
	ret = wapi_send_notify_wapid(&wai_srv, buff, len);
	if(ret <= 0)
	{
		goto err_exit;
	}

	/* recv respond from wapid program */
	/* #0045-2 guoxd_004 20081126 modify start */
	memset(buff, 0, max_len);
	ret = wapi_recv_notify_wapid(&wai_srv, buff, max_len);
	/* #0045-2 guoxd_004 20081126 modify end */

 err_exit:
	close(wai_srv.fd);
	return ret;

}
/* #0045-2 guoxd_001 20081103 add end */


/* #0045-2 guoxd_004 20081129 add start */
/* ---------------------------------------------------------------------------------------
 * [Name]     wapi_get_psktype_by_devname
 * [Function]   get psk type 
 * [Input]       const unsigned char *dev_name
 * [Output]     NULL 
 * [Return]     int		
 *                               -1    error
 *					0	!psk
 *					1     ascii
 *                                2     hex
 * [Limitation] NULL
 * ---------------------------------------------------------------------------------------
 */
static int wapi_get_psktype_by_devname(const unsigned char *dev_name)
{
	int ret = -1;
	int policy = -1;
	int psk_type = -1;
	struct wlan_info_t wlaninfo;

	/* check the param */
	if (dev_name == NULL)
		return ret;

	/* clean buffer */
	memset(&wlaninfo, 0, sizeof(wlaninfo));

	/* search the wireless device information by name */
	ret = serch_by_name(WLAN_CONFIG, WLAN_BEGIN, WLAN_END, dev_name,&wlaninfo); 

	if (ret < 0)
	{
		ret = -1;
		return ret;
	}	

	/* get ssid  mode */
	policy = atoi(wlaninfo.auth);

	/* 0: open; 7: psk; 11: cert mode*/
	if (policy == 0 || policy == 11)
	{
		ret = 0;  /* 0: !PSK */
	}
	else
	{
		psk_type = atoi(wlaninfo.psk_type);
		if (psk_type == 0)
		{
			ret = 1;  /* 1: ASCII */
		}
		else
		{
			ret = 2;  /* 2: HEX */
		}
	}

	return ret;
}



/* ---------------------------------------------------------------------------------------
 * [Name]      wapi_is_hex_str
 * [Function]   judge is the hex string 
 * [Input]       const unsigned char *in
 *                  int     len
 * [Output]     NULL 
 * [Return]     int		
 *					0	!hex
 *					1     hex
 * [Limitation] NULL
 * ---------------------------------------------------------------------------------------
 */
static int wapi_is_hex_str(const unsigned char *in, int len)
{
	int ret = 0;
	int i = 0;
	const unsigned char *p = in;

	if (in == NULL || len <= 0)
		return ret;

	for (i = 0; i < len; i++)
	{
		if ( !((*p >= 'A' && *p <= 'F')
			|| (*p >= 'a' && *p <= 'f')
			|| (*p >= '0' && *p <= '9')) )
		{
			return 0;
		}

		p++;
	}

	return 1;
}
/* #0045-2 guoxd_004 20081129 add end */




int
write_sysAcOnlineUserMax(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
   char strTemp[64];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to syswapiAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to syswapiAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        //  size  = var_val_len;
         // value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	  save_global_conf(SEP_EQUAL,AC_SNMP_CONF,"","ACMAXONLINE",strTemp);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sysAcPortalCertConnectMax(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
   char strTemp[64];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to syswapiAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to syswapiAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
  //        size  = var_val_len;
       //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	  save_global_conf(SEP_EQUAL,AC_SNMP_CONF,"","PORTAL_MAX",strTemp);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sysAcPortalCertConnectCurrent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char strTemp[64];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to syswapiAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to syswapiAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        //  size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	   save_global_conf(SEP_EQUAL,AC_SNMP_CONF,"","PORTAL_CURRENT",strTemp);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sysAcPPPOEConnectMax(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char strTemp[64];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to syswapiAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to syswapiAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	   save_global_conf(SEP_EQUAL,AC_SNMP_CONF,"","PPPOE_MAX",strTemp);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_sysAcPPPOEConnectCurrent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to syswapiAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to syswapiAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         //size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	   save_global_conf(SEP_EQUAL,AC_SNMP_CONF,"","PPPOE_CURRENT",strTemp);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_wapiConfigSATimeout(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to syswapiAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to syswapiAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         //size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	   save_global_conf(SEP_EQUAL,AC_SNMP_CONF,"","STA_TIMEOUT",strTemp);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}





char * str_replace(const char * s, const char * f, const char * r)
{
   int inum = 1;
   int if_len, ir_len;
   char * ps;
   char * pt;
   char * pn;
   char * pp;

   if(s==0 || f==0 || r==0) return 0;
   if(s[0]==0 || f[0]==0) return 0;

   if_len = strlen(f);
   ir_len = strlen(r);

   for(ps=(char *)s;;)
   {
      pt = strstr(ps, f);
      if(pt == 0)
      {
         inum += strlen(ps);
         break;
      }
      inum += (pt - ps) + ir_len;
      ps = pt + if_len;
   }

   pn = pp = malloc(inum);
   if(pn == 0) return 0;
   pn[inum-1] = 0;

   for(ps=(char *)s;;)
   {
      pt = strstr(ps, f);
      if(pt == 0)
      {
         memcpy(pp, ps, strlen(ps));
         break;
      }

      memcpy(pp, ps, pt - ps);
      pp += pt - ps;
      memcpy(pp, r, ir_len);
      pp += ir_len;
      ps = pt + if_len;
   }

   return pn;
}





//bottom
