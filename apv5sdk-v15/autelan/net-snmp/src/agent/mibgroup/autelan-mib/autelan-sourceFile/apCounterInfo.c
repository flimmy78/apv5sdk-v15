/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: apCounterInfo.c
* description:  implementation for the counter information of AP
* 
*
* 
************************************************************************************/


/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "apCounterInfo.h"
#include <unistd.h>
#include <net/if.h>
#include <linux/sockios.h>


#include "wapi/ieee80211_ioctl.h"


int  allcount=0;
int  errcount=0;

/* add by heyanhua for the node apUsrTxRetryPks 2010-4-15 ---start---  */
#define isspace(c) ((((c)==' ')||(((unsigned int)((c)-9))<=(13-9))))
#define debug_print 0
#define	SIOCGATHSTATS	(SIOCDEVPRIVATE+0)


typedef struct {
	unsigned char radio_id;
	unsigned char id;
	unsigned char updown_time;
} interface_updown_time;

typedef struct {  //pei add 0415
	unsigned char id;
	unsigned char status;  //0-not exist,1-up,2-down,3-error
} interface_status;



typedef struct{
	int cpu_use_ratio;
	unsigned int tx_mgmt;
	unsigned int rx_mgmt;
	unsigned int tx_packets;
	unsigned int tx_errors;
	unsigned int tx_retry;
	unsigned int tx_unicast; 
	unsigned int tx_broadcast;
	unsigned int tx_multicast;
	unsigned int tx_drop;
	unsigned int rx_unicast;
	unsigned int rx_broadcast;
	unsigned int rx_multicast;
	unsigned int rx_drop; 
	unsigned int wpi_replay_error;
	unsigned int wpi_decryp_error;
	unsigned int wpi_mic_error;
	unsigned int disassoc_unnormal;
	unsigned int rx_assoc_norate;
	unsigned int rx_assoc_capmismatch;
	unsigned int assoc_invalid;
	unsigned int reassoc_deny;
	unsigned char get_Ip_mode;
	unsigned short mem_total;
	unsigned char mem_use_ratio;
	unsigned short flash_total;
	int flash_free;
	unsigned char snr;
	unsigned char temperature;  
	unsigned char eth_count;
	interface_updown_time *eth_updown_time;
	unsigned char ath_count;
	interface_updown_time *ath_updown_time;
	unsigned char wifi_count;  
	interface_status *wifi_status;  
	}extra_info;



//int getifstats(const char *ifname,unsigned long *iframes,unsigned long *oframes);
int CWGetExtraInfo(char *wifiname, extra_info *extraInfoValues);

/* add by heyanhua for the node apUsrTxRetryPks 2010-4-15 ---start---  */


/* 
 * apCounterInfo_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

//oid apCounterInfo_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,2,1,4 };
oid *apCounterInfo_variables_oid;

/* 
 * variable4 apCounterInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the apCounterInfo mib section 
 */

struct variable4  apCounterInfo_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define APUSRRXBYTES		1
{APUSRRXBYTES,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 1 }},
#define APUSRTXBYTES		2
{APUSRTXBYTES,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 2 }},
#define APUSRRXPKS		3
{APUSRRXPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 3 }},
#define APUSRTXPKS		4
{APUSRTXPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 4 }},
#define APUSRRXERRPKS		5
{APUSRRXERRPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 5 }},
#define APUSRTXERRPKS		6
{APUSRTXERRPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 6 }},
#define APUSRERRPKSRATE		7
{APUSRERRPKSRATE,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 7 }},
#define APUSRTXDISCARDPKS		8
{APUSRTXDISCARDPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 8 }},
#define APNETRXBYTES		9
{APNETRXBYTES,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 9 }},
#define APNETTXBYTES		10
{APNETTXBYTES,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 10 }},
#define APNETRXPKS		11
{APNETRXPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 11 }},
#define APNETTXPKS		12
{APNETTXPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 12 }},
#define APNETRXERRPKS		13
{APNETRXERRPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 13 }},
#define APNETERRPKSRATE		14
{APNETERRPKSRATE,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 14 }},
#define APETH0RXCORRECTPKS		15
{APETH0RXCORRECTPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 15 }},
#define APETH1RXCORRECTPKS		16
{APETH1RXCORRECTPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 16 }},
#define APNETINTERFACECOUNT		17
{APNETINTERFACECOUNT,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 17 }},
#define APETH0INTERFACEDESCIP		18
{APETH0INTERFACEDESCIP,  ASN_OCTET_STR,  RONLY ,  var_apCounterInfo, 1,  { 18 }},
#define APETH1INTERFACEDESCIP		19
{APETH1INTERFACEDESCIP,  ASN_OCTET_STR,  RONLY ,  var_apCounterInfo, 1,  { 19 }},
#define APETH0INTERFACERATE		20
{APETH0INTERFACERATE,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 20 }},
#define APETH1INTERFACERATE		21
{APETH1INTERFACERATE,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 21 }},
#define APETH0TXTRAFFIC		22
{APETH0TXTRAFFIC,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 22 }},
#define APETH1TXTRAFFIC		23
{APETH1TXTRAFFIC,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 23 }},
#define APETH0RXTRAFFIC		24
{APETH0RXTRAFFIC,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 24 }},
#define APETH1RXTRAFFIC		25
{APETH1RXTRAFFIC,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 25 }},
#define APPHYERRCOUNTER		26
{APPHYERRCOUNTER,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 26 }},
#define APSNRBSSIDTXSIGNALPKTS		27
{APSNRBSSIDTXSIGNALPKTS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 27 }},
#define APSNRBSSIDRXSIGNALPKTS		28
{APSNRBSSIDRXSIGNALPKTS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 28 }},
#define APSNRBSSIDSIGNALPKTS		29
{APSNRBSSIDSIGNALPKTS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 29 }},
#define APUSRTXCORRECTPKS		30
{APUSRTXCORRECTPKS,  ASN_INTEGER,  RONLY ,  var_apCounterInfo, 1,  { 30 }},
#define APUSRTXRETRYPKS       31
{APUSRTXRETRYPKS, ASN_INTEGER, RONLY , var_apCounterInfo, 1, {31}},
};
/*    (L = length of the oidsuffix) */


/** Initializes the apCounterInfo module */
void
init_apCounterInfo(void)
{
  //  'cat  /jffs/.OEM/.vendor_oid'
   	FILE *fp;
	char oid_str[64]={0};
	char oid_tmp[64]={0};
	int  oid_len=0;
	int  count = 0;
	char *p = NULL;
	char *ptr=NULL;
	
    fp=fopen( "/jffs/.OEM/.vendor_oid","r");
    if(fp)
    {
    	 memset(oid_str,0,64);
		 fgets(oid_str,sizeof(oid_str),fp);
		 oid_str[strlen(oid_str)-1] = '\0';
		 fclose(fp);
    }
    else
     {
    	memset(oid_str,0,64);
        strcpy(oid_str, "1.3.6.1.4.1.31656");
	  }

	memset(oid_tmp,0,64);
	strcpy(oid_tmp,oid_str);
		 
    ptr = strtok(oid_tmp, "."); 
	while(NULL != ptr)
	{
		oid_len++;
		ptr = strtok(NULL,".");
	 }
	
    oid_len = oid_len + 5;	
	apCounterInfo_variables_oid=(oid *)malloc(sizeof(oid)*(oid_len));

    p = strtok(oid_str, ".");
    while( NULL != p)
    {
         apCounterInfo_variables_oid[count++] = (oid)atoi(p);
         p = strtok(NULL,".");
    }

    apCounterInfo_variables_oid[count ++] = 2;
    apCounterInfo_variables_oid[count ++] = 3;
    apCounterInfo_variables_oid[count ++] = 2;
    apCounterInfo_variables_oid[count ++] = 1;
    apCounterInfo_variables_oid[count ++] = 4;
	

    DEBUGMSGTL(("apCounterInfo", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("apCounterInfo", apCounterInfo_variables, variable4,
               apCounterInfo_variables_oid, count);

    /* place any other initialization junk you need here */
}

/*
 * var_apCounterInfo():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_apCounterInfo(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static char value[COUNT_MAX];
    static char string[COUNT_LEN];
    static char buffer[COUNT_LEN];
    static char string1[COUNT_LEN];
    static char buffer1[COUNT_LEN];
    static char strBuf[COUNT_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
   char crc_err[COUNT_LEN];
   char key_err[COUNT_LEN];
    char phy_err[COUNT_LEN];
    FILE *fp;
      int   usr_rx_byte;
      int   usr_tx_byte;
      int   usr_rx_pks;
      int   usr_tx_pks;
      int   usr_err_rx_pks;
      int   usr_err_tx_pks;
      int   net_rx_pks;
      int   net_tx_pks;
      int   net_err_rx_pks;	
      int   mana_rx;	
      int   mana_tx;	
      int   sum = 0;
      int  sum1,sum2,sum3;
	if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case APUSRRXBYTES:
       {   
			 memset( buffer, 0, COUNT_LEN );
			 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/ath/{print $0}'|awk -F \"[ ]+|:\" '/RX bytes/{print $4}'");
			printf("buffer:%s\n",buffer);
			 fp=popen(buffer,"r");
			 if(fp)
				{
					memset (string, 0, COUNT_LEN);
					while(fgets(string,sizeof(string),fp)) 
				       {
						  CGetChar(&sum, string);
						  printf("APUSRRXBYTESsum:%d\n",sum);
				        }
					   pclose(fp);
				}
			 usr_rx_byte=sum;
			 long_ret=usr_rx_byte;
   		   printf("usr_rx_byte:%d,long_ret:%d\n",usr_rx_byte,long_ret);
   		    return ( u_char  * ) &long_ret;
		 }
	
    case APUSRTXBYTES:
       {    
			 memset( buffer, 0, COUNT_LEN );
			 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/ath/{print $0}'|awk -F \"[ ]+|:\" '/TX bytes/{print $9}'");
			 fp=popen(buffer,"r");
			 if(fp)
				  {
					memset (string, 0, COUNT_LEN);
					while(fgets(string,sizeof(string),fp)) 
				       {
						  CGetChar(&sum, string);
						  printf("APUSRTXBYTES:sum:%d\n",sum);
				        }
					   pclose(fp);
					   usr_tx_byte=sum;
					   long_ret=usr_tx_byte;
					   return ( u_char  * )&long_ret;
				 }
		 }

	
    case APUSRRXPKS:
	{    
			 memset( buffer, 0, COUNT_LEN );
			 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/ath/{print $0}'|awk -F \"[ ]+|:\" '/RX packets/{print $4}'");
			 fp=popen(buffer,"r");
			 if(fp)
				{
					memset (string, 0, COUNT_LEN);
					while(fgets(string,sizeof(string),fp)) 
				       {
						  CGetChar(&sum, string);
						  printf("APUSRRXPKS:sum:%d\n",sum);
				        }
					   pclose(fp);
					   usr_rx_pks=sum;
					   long_ret=usr_rx_pks;
					   return ( u_char  * ) &long_ret;
				 }
			}

    case APUSRTXPKS:
		
        {    
			 memset( buffer, 0, COUNT_LEN );
			 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/ath/{print $0}'|awk -F \"[ ]+|:\" '/TX packets/{print $4}'");
			 fp=popen(buffer,"r");
			 if(fp)
				{
					memset (string, 0, COUNT_LEN);
					while(fgets(string,sizeof(string),fp)) 
				       {
						  CGetChar(&sum, string);
				        }
					   pclose(fp);
					   usr_tx_pks=sum;
					   allcount=sum;
					    printf("allcount:%d\n",allcount);
					    long_ret=usr_tx_pks;
					   return ( u_char  * ) &long_ret;
				 }
	}

	
		
    case APUSRRXERRPKS:
	{    
				 memset( crc_err, 0, COUNT_LEN );
				 memset( key_err, 0, COUNT_LEN );
				 memset( phy_err, 0, COUNT_LEN );
				 sprintf( crc_err, "%s", "/usr/sbin/athstats |awk '/cuz of bad CRC/{print $1}'");
				 sprintf( key_err, "%s", "/usr/sbin/athstats |awk '/cuz decryption/{print $1}'");
				 sprintf( phy_err, "%s", "/usr/sbin/athstats |awk '/PHY errors/{print $1}'");

				  fp=popen(crc_err,"r");
					 if(fp)
						{
							memset (string, 0, COUNT_LEN);
							fgets(string,sizeof(string),fp); 
						       sum += atoi(string);
							   pclose(fp);
						 }
				  fp=popen(key_err,"r");
					if(fp)
						{
							memset (string, 0, COUNT_LEN);
							fgets(string,sizeof(string),fp); 
						    sum += atoi(string);
							pclose(fp);
						 }
				  fp=popen(phy_err,"r");
					 if(fp)
						{
							memset (string, 0, COUNT_LEN);
							fgets(string,sizeof(string),fp); 
						       sum += atoi(string);
							   pclose(fp);
						 }
				   usr_err_rx_pks=sum;
				   long_ret=usr_err_rx_pks;
				   return ( u_char  * ) &long_ret;

			}	

   case APUSRTXERRPKS:
  	{
		 sprintf( crc_err, "%s", "/usr/sbin/athstats |awk '/cuz of bad CRC/{print $1}'");
		 sprintf( key_err, "%s", "/usr/sbin/athstats |awk '/cuz decryption/{print $1}'");
		 sprintf( phy_err, "%s", "/usr/sbin/athstats |awk '/PHY errors/{print $1}'");

		  fp=popen(crc_err,"r");
			 if(fp)
				{
					memset (string, 0, COUNT_LEN);
					fgets(string,sizeof(string),fp); 
				       sum1 = atoi(string);
					   pclose(fp);
				 }
		  fp=popen(key_err,"r");
			if(fp)
				{
					memset (string, 0, COUNT_LEN);
					fgets(string,sizeof(string),fp); 
				       sum2= atoi(string);
					pclose(fp);
				 }
         long_ret=sum1+sum2;
	 return (u_char*) &long_ret;
   	}

    case APUSRERRPKSRATE:

	 memset( buffer, 0, COUNT_LEN );
	 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/ath/{print $0}'|awk -F \"[ ]+|:\" '/TX packets/{print $4}'");
	 fp=popen(buffer,"r");
	 if(fp)
		{
			memset (string, 0, COUNT_LEN);
			while(fgets(string,sizeof(string),fp)) 
		       {
				  CGetChar(&sum, string);
		        }
			   pclose(fp);
			   usr_tx_pks=sum;
		 }


	 memset( buffer, 0, COUNT_LEN );
	 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/ath/{print $0}'|awk -F \"[ ]+|:\" '/RX packets/{print $4}'");
	 fp=popen(buffer,"r");
	 if(fp)
		{
			memset (string, 0, COUNT_LEN);
			while(fgets(string,sizeof(string),fp)) 
		       {
				  CGetChar(&sum, string);
				  printf("APUSRRXPKS:sum:%d\n",sum);
		        }
			   pclose(fp);
			   usr_rx_pks=sum;
		 }


		 memset( crc_err, 0, COUNT_LEN );
		 memset( key_err, 0, COUNT_LEN );
		 memset( phy_err, 0, COUNT_LEN );
		 sprintf( crc_err, "%s", "/usr/sbin/athstats |awk '/cuz of bad CRC/{print $1}'");
		 sprintf( key_err, "%s", "/usr/sbin/athstats |awk '/cuz decryption/{print $1}'");
		 sprintf( phy_err, "%s", "/usr/sbin/athstats |awk '/PHY errors/{print $1}'");

		  fp=popen(crc_err,"r");
			 if(fp)
				{
					memset (string, 0, COUNT_LEN);
					fgets(string,sizeof(string),fp); 
				       sum1 = atoi(string);
					   pclose(fp);
				 }
		  fp=popen(key_err,"r");
			if(fp)
				{
					memset (string, 0, COUNT_LEN);
					fgets(string,sizeof(string),fp); 
				       sum2= atoi(string);
					pclose(fp);
				 }
		  fp=popen(phy_err,"r");
			 if(fp)
				{
					memset (string, 0, COUNT_LEN);
					fgets(string,sizeof(string),fp); 
				       sum3 = atoi(string);
					   pclose(fp);
				 }
		   usr_err_rx_pks=sum1+sum2+sum3;
		   errcount=usr_err_rx_pks;
		   long_ret=GetPercentage(usr_err_rx_pks,(usr_rx_pks+usr_tx_pks))*100;
		   return  (u_char*) &long_ret;


 case APUSRTXDISCARDPKS:

	  {    
			 memset( buffer, 0, COUNT_LEN );
			 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/ath/{print $0}'|awk -F \"[ ]+|:\" '/TX packets/{print $8}'");
			 fp=popen(buffer,"r");
			 if(fp)
				{
					memset (string, 0, COUNT_LEN);
					while(fgets(string,sizeof(string),fp)) 
				       {
						  CGetChar(&sum, string);
				        }
					   pclose(fp);
					  long_ret=sum;
					   return (u_char*) &long_ret;
				 }
			}

	
    case APNETRXBYTES:
       {    
		 memset( buffer, 0, COUNT_LEN );
		 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/eth/{print $0}'|awk -F \"[ ]+|:\" '/RX bytes/{print $4}'");
		 fp=popen(buffer,"r");
		 if(fp)
			{
				memset (string, 0, COUNT_LEN);
				while(fgets(string,sizeof(string),fp)) 
			       {
					  CGetChar(&sum, string);
			        }
				  pclose(fp);
				  long_ret=sum;
				  return  (u_char*)&long_ret;
		   }
   }
	
    case APNETTXBYTES:

		{    
				 memset( buffer, 0, COUNT_LEN );
				 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/eth/{print $0}'|awk -F \"[ ]+|:\" '/TX bytes/{print $9}'");
				 fp=popen(buffer,"r");
				 if(fp)
					{
						memset (string, 0, COUNT_LEN);
						while(fgets(string,sizeof(string),fp)) 
					       {
							  CGetChar(&sum, string);
					        }
						   pclose(fp);
						  long_ret=sum;
						  return (u_char*)&long_ret;    
					 }
			}
		
    case APNETRXPKS:

		{    
				 memset( buffer, 0, COUNT_LEN );
				 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/eth/{print $0}'|awk -F \"[ ]+|:\" '/RX packets/{print $4}'");
				 fp=popen(buffer,"r");
				 if(fp)
					{
						memset (string, 0, COUNT_LEN);
						while(fgets(string,sizeof(string),fp)) 
					       {
							  CGetChar(&sum, string);
					        }
						   pclose(fp);
					 }
				 
						   long_ret=sum;
						   return  (u_char*) &long_ret;
			}


   case APNETTXPKS:
        {    
				 memset( buffer, 0, COUNT_LEN );
				 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/eth/{print  $0}'|awk -F  \"[ ]+|:\" '/TX packets/{print $4}'");
				 fp=popen(buffer,"r");
				 if(fp)
					{
						memset (string, 0, COUNT_LEN);
						while(fgets(string,sizeof(string),fp)) 
					       {
							  CGetChar(&sum, string);
					        }
						   pclose(fp);
						   long_ret=sum;
						   return  (u_char*) &long_ret;
					 }
			}


	
    case APNETRXERRPKS:
		
      {   
		 memset( buffer, 0, COUNT_LEN );
		 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/eth/{print $0}'|awk -F \"[ ]+|:\" '/RX packets/{print $6}'");
		 fp=popen(buffer,"r");
		 if(fp)
			{
				memset (string, 0, COUNT_LEN);
				while(fgets(string,sizeof(string),fp)) 
			       {
					  CGetChar(&sum, string);
			        }
				   pclose(fp);
				   net_err_rx_pks=sum;
				   return (u_char*)&net_err_rx_pks;    
			 }
	}
    case APNETERRPKSRATE:
        {    

		 memset( buffer, 0, COUNT_LEN );
		 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/eth/{print  $0}'|awk -F  \"[ ]+|:\" '/TX packets/{print $4}'");
		 fp=popen(buffer,"r");
		 if(fp)
			{
				memset (string, 0, COUNT_LEN);
				while(fgets(string,sizeof(string),fp)) 
			       {
					  CGetChar(&sum, string);
			        }
				   pclose(fp);
				   net_tx_pks=sum;
			 }


		memset( buffer, 0, COUNT_LEN );
		sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/eth/{print $0}'|awk -F \"[ ]+|:\" '/RX packets/{print $6}'");
		 fp=popen(buffer,"r");
		 if(fp)
		{
			memset (string, 0, COUNT_LEN);
			while(fgets(string,sizeof(string),fp)) 
			{
				 CGetChar(&sum, string);
			}
			  pclose(fp);
			 net_err_rx_pks=sum;
		 }


	 memset( buffer, 0, COUNT_LEN );
	 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/eth/{print $0}'|awk -F \"[ ]+|:\" '/TX packets/{print $4}'");
	 fp=popen(buffer,"r");
	 if(fp)
		{
			memset (string, 0, COUNT_LEN);
			while(fgets(string,sizeof(string),fp)) 
		       {
				  CGetChar(&sum, string);
		        }
			   pclose(fp);
		    }
 long_ret=GetPercentage(sum,(net_rx_pks+net_tx_pks))*100;
 return  (u_char*)&long_ret;    
	}

    

    case APETH0RXCORRECTPKS:
  {
	   memset( buffer, 0, COUNT_LEN );
	   sprintf( buffer, "%s", "/sbin/ifconfig eth0|awk  -F \"[ ]+|:\" '/RX packets/{print $4}'");
          fp=popen(buffer,"r");
	    if(fp)
	   	{
		   memset (string, 0, COUNT_LEN);
		   fgets(string,sizeof(string),fp);
		   string[strlen(string)-1]='\0';
		   pclose(fp);
		   long_ret=atoi(string);
	          return  (u_char*)&long_ret;
	   	}
	}
    case APETH1RXCORRECTPKS:
   {
	   memset( buffer, 0, COUNT_LEN );
	   sprintf( buffer, "%s", "/sbin/ifconfig eth1|awk  -F \"[ ]+|:\" '/RX packets/{print $4}'");
          fp=popen(buffer,"r");
	    if(fp)
	   	{
		   memset (string, 0, COUNT_LEN);
		   fgets(string,sizeof(string),fp);
		   string[strlen(string)-1]='\0';
		   pclose(fp);
		   long_ret=atoi(string);
	           return (u_char*)&long_ret;
	   	}
	}
    
    case APNETINTERFACECOUNT:
         long_ret=2;
        return ( u_char  * ) &long_ret;
    case APETH0INTERFACEDESCIP:
	{ 
		memset(buffer,0,COUNT_LEN);
		memset(string,0,COUNT_LEN);
		memset(value,0,COUNT_MAX);
		sprintf(buffer,"%s","/usr/sbin/getsysname.sh");
		sprintf(string,"%s","/usr/sbin/showsysinfo |awk -F \"[ ]+|:\" '/Device Type/{print $4}'");
		 fp=popen( buffer,"r");
		if(fp)
	      {
		 memset( buffer1, 0, COUNT_LEN );
		fgets(buffer1,sizeof(buffer1),fp);
		buffer1[strlen(buffer1)-1] = '\0';
		pclose(fp);
		}
		
		 fp=popen( string,"r");
		if(fp)
	      {
		 memset( string1, 0, COUNT_LEN );
		fgets(string1,sizeof(string1),fp);
		string1[strlen(string1)-1] = '\0';
		pclose(fp);
		}
		 sprintf(value," %s%s%s%s%s","eth0","product  by",buffer1,"devicename:",string1);
		*var_len = strlen ( value);
              return  (u_char*)value;
		
	}
			
    case APETH1INTERFACEDESCIP:
	{ 
		memset(value,0,COUNT_MAX);
		memset(buffer,0,COUNT_LEN);
		memset(string,0,COUNT_LEN);
		sprintf(buffer,"%s","/usr/sbin/getsysname.sh");
		sprintf(string,"%s","/usr/sbin/showsysinfo |awk -F \"[ ]+|:\" '/Device Type/{print $4}'");
		 fp=popen( buffer,"r");
		if(fp)
	      {
		 memset( buffer1, 0, COUNT_LEN );
		fgets(buffer1,sizeof(buffer1),fp);
		buffer1[strlen(buffer1)-1] = '\0';
		pclose(fp);
		}
		
		 fp=popen( string,"r");
		if(fp)
	      {
		 memset( string1, 0, COUNT_LEN );
		fgets(string1,sizeof(string1),fp);
		string1[strlen(string1)-1] = '\0';
		pclose(fp);
		}
		 sprintf(value," %s%s%s%s%s","eth1","product  by",buffer1,"devicename:",string1);
		*var_len = strlen (value );
             return  (u_char*)value;
		
	}
	
    case APETH0INTERFACERATE:
      {    
		memset( buffer, 0, COUNT_LEN );
		sprintf( buffer, "%s", "/usr/sbin/ethtool eth0|awk '/Speed:/{print $2}'");
		fp=popen(buffer,"r");
		  if(fp)
			{
				memset (string, 0, COUNT_LEN);
				fgets(string,sizeof(string),fp);
				string[strlen(string)-1] = '\0';
				 pclose(fp);
				long_ret=atoi(string);
				return (u_char*) &long_ret;
			 }
    }

    case APETH1INTERFACERATE:
{    
		memset( buffer, 0, COUNT_LEN );
		sprintf( buffer, "%s", "/usr/sbin/ethtool eth1|awk '/Speed:/{print $2}'");
		fp=popen(buffer,"r");
		  if(fp)
			{
				memset (string, 0, COUNT_LEN);
				fgets(string,sizeof(string),fp);
				string[strlen(string)-1] = '\0';
				long_ret=atoi(string);
				pclose(fp);
				return (u_char*) &long_ret;
			 }
    }


    case APETH0TXTRAFFIC:
           { 
			  fp=popen( " cat  /tmp/interface-rate |awk '/eth0/{print $3}' ","r");
			    if(fp)
			      {
			  	 memset( string, 0, COUNT_LEN );
			  	 fgets(string,sizeof(string),fp);
				 string[strlen(string)-1] = '\0';
				 long_ret=atoi(string);
				 pclose(fp);
				 return (u_char*) &long_ret;
				}
  
		}


	    case APETH1TXTRAFFIC:
           { 
			  fp=popen( " cat  /tmp/interface-rate |awk '/eth1/{print $3}' ","r");
			    if(fp)
			      {
			  	 memset( string, 0, COUNT_LEN );
			  	 fgets(string,sizeof(string),fp);
				 string[strlen(string)-1] = '\0';
				 pclose(fp);
				long_ret=atoi(string);
				 return (u_char*)&long_ret;
				}
  
		}
	   case APETH0RXTRAFFIC:
       		 { 
			  fp=popen( " cat  /tmp/interface-rate |awk '/eth0/{print $2}' ","r");
			    if(fp)
			      {
			  	 memset( string, 0, COUNT_LEN );
			  	 fgets(string,sizeof(string),fp);
				 string[strlen(string)-1] = '\0';
				 pclose(fp);
				 long_ret=atoi(string);
				 return  (u_char*)&long_ret;
				}
  
		 }
	   
    case APETH1RXTRAFFIC:
        { 
			  fp=popen( " cat  /tmp/interface-rate |awk '/eth1/{print $2}' ","r");
			    if(fp)
			      {
			  	 memset( string, 0, COUNT_LEN );
			  	 fgets(string,sizeof(string),fp);
				 string[strlen(string)-1] = '\0';
				 pclose(fp);
				 long_ret=atoi(string);
				 return (u_char*) &long_ret;
				}
  
		}


	case APPHYERRCOUNTER:
        { 
			  memset( buffer, 0, COUNT_LEN );
			  sprintf( buffer, "%s", "/usr/sbin/athstats|awk '/PHY errors/{print $1}'");
			  fp=popen(buffer,"r");
			  if(fp)
			  	{
				  memset( string, 0, COUNT_LEN );
				  fgets(string,sizeof(string),fp);
				  string[strlen(string)-1] = '\0';
				  pclose(fp);
				  long_ret=atoi(string);
				  return (u_char*)&long_ret;    
			  	}
		 }
	
   case APSNRBSSIDTXSIGNALPKTS:
   	    { 
			  memset( buffer, 0, COUNT_LEN );
			  sprintf( buffer, "%s", "/usr/sbin/athstats|awk '/tx management frames/{print $1}'");
			  fp=popen(buffer,"r");
			  if(fp)
			  	{
				  memset( string, 0, COUNT_LEN );
				  fgets(string,sizeof(string),fp);
				  string[strlen(string)-1] = '\0';
				   pclose(fp);
				  printf("string:%s\n",string);
				   long_ret=atoi(string);
				  return (u_char*)&long_ret;    
			  	}
		 }
       
    case  APSNRBSSIDRXSIGNALPKTS:
     { 
			  memset( buffer, 0, COUNT_LEN );
			  sprintf( buffer, "%s", "/usr/sbin/athstats|awk '/rx management frames/{print $1}'");
			  fp=popen(buffer,"r");
			  if(fp)
			  	{
				  memset( string, 0, COUNT_LEN );
				  fgets(string,sizeof(string),fp);
				  string[strlen(string)-1] = '\0';
				  pclose(fp);
				  long_ret=atoi(string);
				  return (u_char*)&long_ret;    
			  	}
		 }
    case APSNRBSSIDSIGNALPKTS:
   	    { 
			  memset( buffer, 0, COUNT_LEN );
			  sprintf( buffer, "%s", "/usr/sbin/athstats|awk '/tx management frames/{print $1}'");
			  fp=popen(buffer,"r");
			  if(fp)
			  	{
				  memset( string, 0, COUNT_LEN );
				  fgets(string,sizeof(string),fp);
				  string[strlen(string)-1] = '\0';
				   pclose(fp);
				   mana_tx=atoi(string);
			  	}
		
			  memset( strBuf, 0, COUNT_LEN );
			  sprintf( strBuf, "%s", "/usr/sbin/athstats|awk '/rx management frames/{print $1}'");
			  fp=popen(strBuf,"r");
			  if(fp)
			  	{
				  memset( string, 0, COUNT_LEN );
				  fgets(string,sizeof(string),fp);
				  string[strlen(string)-1] = '\0';
				  pclose(fp);
				  }
			mana_rx=atoi(string);
		
		long_ret=mana_tx+mana_rx;
		return ( u_char  * )&long_ret;    
   }
	
case APUSRTXCORRECTPKS:
        {    
			 memset( buffer, 0, COUNT_LEN );
			 sprintf( buffer, "%s", "/sbin/ifconfig |awk 'BEGIN{RS=\"\\n\\n\"}/ath/{print $0}'|awk -F \"[ ]+|:\" '/TX packets/{print $4}'");
			 fp=popen(buffer,"r");
			 if(fp)
				{
					memset (string, 0, COUNT_LEN);
					while(fgets(string,sizeof(string),fp)) 
				       {
						  CGetChar(&sum, string);
				        }
					   pclose(fp);
					   usr_tx_pks=sum;
					   allcount=sum;
					    printf("allcount:%d\n",allcount);
 				 }

       long_ret=allcount- errcount;
	return  (u_char*)&long_ret;  
}
// heyh add ---2010-04-13
case APUSRTXRETRYPKS:
		{
			FILE *fp;
			char *q;
			int i,count=0;
			long sum[12],total=0;
			char ifname[IFNAMSIZ];
			extra_info extraInfoValues;
			
			fp=fopen("/proc/net/dev", "r");
			if(fp!=NULL)
			{
				char line[256];
				while(fgets(line,sizeof(line),fp))
				{
					q = strstr(line,"wifi");
					if(q != NULL)
						{
							count++;
						}
				}
				fclose(fp);
			}
			printf("hyh test count:%d\n",count);
			extraInfoValues.tx_retry = 0;
			memset(sum, 0, 12);
		for(i=0; i<count; i++)
				{
					memset(ifname, 0, IFNAMSIZ);
					sprintf(ifname,"wifi%d\0",i);
					sum[i]= CWGetExtraInfo(ifname, &extraInfoValues);
					printf("hyh test  sum[%d]:%ld\n",i,sum[i]);
				}
			for(i=0;i < count;i++)
				total += sum[i];
			long_ret = total;
			return (u_char *)&long_ret;
		}
	
	
    default:
      ERROR_MSG("");
    }
    return NULL;
}




double GetPercentage(int firstNumber, int secondNumber)
{
	return (firstNumber/(double)secondNumber);
}




 void CGetChar(int *sum, char* Src)
{
	unsigned j = 0;
	long IsLeft = TRUE;
	char buffer[10]= {0};
    unsigned nStart= 0;
	for (nStart = 0; nStart < strlen(Src); nStart++)
	{ 
		if (Src[nStart] == ' ' || Src[nStart] == '\t' 
			|| Src[nStart] == '\r' || Src[nStart] == '\0' || Src[nStart] == '\n')
		{
			if (IsLeft)
				continue;
			else 
				break;
		}
		buffer[j++] = Src[nStart];		
		IsLeft = FALSE;
	}
	
	*sum += atoi(buffer);
	
}

/*  add by heyanhua for the node apUsrTxRetryPks 2010-4-15  ---start--- */
int getifstats(const char *ifname,unsigned long *iframes,unsigned char *oframes)
{
	FILE *fd=fopen("/proc/net/dev","r");
	if(fd!=NULL){
		char line[256];
		while(fgets(line,sizeof(line),fd)){
			char *cp,*tp;

			for(cp=line;isspace(*cp);cp++)
				;
			if(cp[0]!=ifname[0])
				continue;
			for(tp=cp;*tp!=':'&& *tp;tp++)
				;
			if(*tp == ':'){
				*tp++ = '\0';
				if(strcmp(cp, ifname) != 0)
					continue;
				sscanf(tp, "%*llu %lu %*u %*u %*u %*u %*u %*u %*llu %lu",
					iframes, oframes);
				fclose(fd);
				return 1;
				}
			}
		fclose(fd);
	}
	return 0;
}

int CWGetExtraInfo(char *wifiname, extra_info *extraInfoValues)
{
	int s;
	struct ifreq ifr;
	struct ath_stats total;
	unsigned long itot, otot;
	printf("heyanhua test 1...\n");

	s=socket(AF_INET, SOCK_DGRAM, 0);
	printf("heyanhua test 2...\n");
	if(s < 0)
	{
		if(debug_print)
			printf("create sock to get extra info error!\n");
		return 0;
	}
	printf("heyanhua test 3...\n");
	//strncpy(ifr.ifr_name,wifiname, sizeof(ifr.ifr_name));
	memset(ifr.ifr_name,0,sizeof(ifr.ifr_name));
	strcpy(ifr.ifr_name,wifiname);
	printf("heyh test ifr.ifr_name:%s\n",ifr.ifr_name);
	printf("heyanhua test 4...\n");

	ifr.ifr_data = (caddr_t) &total;
	printf("heyanhua test 5...\n");
	if(ioctl(s, SIOCGATHSTATS, &ifr) < 0)
	{
		if(debug_print)
			printf("ioctl to get extra info error!\n");
		close(s);
		return 0;
	}
	if(!getifstats(ifr.ifr_name, &itot, &otot))
	{
		if(debug_print)
			printf("getifstats to get extra info error!\n");
		close(s);
		return 0;
	}
	printf("heyanhua test 6...\n");
	printf("hyh test!--1-- extraInfoValues->tx_retry:%d\n",extraInfoValues->tx_retry);
	extraInfoValues->tx_mgmt += total.ast_tx_mgmt;
	extraInfoValues->rx_mgmt += total.ast_rx_mgt;
	extraInfoValues->tx_packets += total.ast_tx_packets;
	extraInfoValues->tx_errors += total.ast_tx_xretries;
	extraInfoValues->tx_retry += total.ast_tx_xretries;

	close(s);
	printf("hyh test!--2-- extraInfoValues->tx_retry:%d\n",extraInfoValues->tx_retry);
	return extraInfoValues->tx_retry;
}
/*  add by heyanhua for the node apUsrTxRetryPks 2010-4-15  ---end--- */


