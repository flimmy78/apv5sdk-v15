/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: apAttributeInfo.c
* description:  implementation for the attribute information of AP
* 
*
* 
************************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "apAttributeInfo.h"
#include "apCounterInfo.h"

char platcert[30]="admin";
char platkey[30]="admin";
//int divideSSIDnum=12;
int bss_ssid_prio=4;
int net_ssid_prio=2;
long channel_pattern=0;   //heyanhua modify 2010-5-4


/* 
 * apAttributeInfo_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

//oid apAttributeInfo_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,2,1,3 };
oid *apAttributeInfo_variables_oid;
/* 
 * variable4 apAttributeInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the apAttributeInfo mib section 
 */

struct variable4 apAttributeInfo_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define APFIREWARE		1
{APFIREWARE,  ASN_OCTET_STR,  RONLY ,  var_apAttributeInfo, 1,  { 1 }},
#define APDEVICESN		2
{APDEVICESN,  ASN_OCTET_STR,  RONLY ,  var_apAttributeInfo, 1,  { 2 }},
#define APDEVICETYPE		3
{APDEVICETYPE,  ASN_OCTET_STR,  RONLY ,  var_apAttributeInfo, 1,  { 3 }},
#define APMODE		4
{APMODE,  ASN_OCTET_STR,  RONLY ,  var_apAttributeInfo, 1,  { 4 }},
#define APUPTIME		5
{APUPTIME,  ASN_OCTET_STR,  RONLY ,  var_apAttributeInfo, 1,  { 5 }},
#define APETHUPLINKTRAFFIC		6
{APETHUPLINKTRAFFIC,  ASN_INTEGER,  RONLY ,  var_apAttributeInfo, 1,  { 6 }},
#define APUSRUPLINKTRAFFIC		7
{APUSRUPLINKTRAFFIC,  ASN_INTEGER,  RONLY ,  var_apAttributeInfo, 1,  { 7 }},
#define APUTILRESOURCE		8
{APUTILRESOURCE,  ASN_INTEGER,  RONLY ,  var_apAttributeInfo, 1,  { 8 }},
#define APSYSNAME		9
{APSYSNAME,  ASN_OCTET_STR,  RWRITE,  var_apAttributeInfo, 1,  { 9 }},
#define APDIVIDESSIDCOUNT		10
{APDIVIDESSIDCOUNT,  ASN_INTEGER,  RWRITE,  var_apAttributeInfo, 1,  { 10 }},
#define APBUSSINESSSSIDPRIORITY		11
{APBUSSINESSSSIDPRIORITY,  ASN_INTEGER,  RWRITE,  var_apAttributeInfo, 1,  { 11 }},
#define APNETADMINSSIDPRIORITY		12
{APNETADMINSSIDPRIORITY,  ASN_INTEGER,  RWRITE,  var_apAttributeInfo, 1,  { 12 }},
#define APCHANNELPATTERN		13
{APCHANNELPATTERN,  ASN_INTEGER,  RWRITE,  var_apAttributeInfo, 1,  { 13 }},
#define APSIGNALNOISERATIO		14
{APSIGNALNOISERATIO,  ASN_OCTET_STR,  RONLY ,  var_apAttributeInfo, 1,  { 14 }},
#define APWIFI0HOPFREQTIMES		15
{APWIFI0HOPFREQTIMES,  ASN_INTEGER,  RONLY ,  var_apAttributeInfo, 1,  { 15 }},
#define APWIFI1HOPFREQTIMES		16
{APWIFI1HOPFREQTIMES,  ASN_INTEGER,  RONLY ,  var_apAttributeInfo, 1,  { 16 }},
#define APWIFI0HOPFREQDETECTINTERVAL		17
{APWIFI0HOPFREQDETECTINTERVAL,  ASN_INTEGER,  RWRITE,  var_apAttributeInfo, 1,  { 17 }},
#define APWIFI1HOPFREQDETECTINTERVAL		18
{APWIFI1HOPFREQDETECTINTERVAL,  ASN_INTEGER,  RWRITE,  var_apAttributeInfo, 1,  { 18 }},
#define APPLATTOTERMINALCERTACCOUNT		19
{APPLATTOTERMINALCERTACCOUNT,  ASN_OCTET_STR,  RWRITE,  var_apAttributeInfo, 1,  { 19 }},
#define APPLATTOTERMINALCERTPASSWORD		20
{APPLATTOTERMINALCERTPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_apAttributeInfo, 1,  { 20 }},
#define SECAPUTILRESOURCE		21
{SECAPUTILRESOURCE,  ASN_INTEGER,  RONLY ,  var_apAttributeInfo, 1,  { 21 }},
#define APCONFIGBSSIDNUM		22
{APCONFIGBSSIDNUM,  ASN_INTEGER,  RONLY ,  var_apAttributeInfo, 1,  { 22 }},
#define APNETIFNUMBER    23
{APNETIFNUMBER, ASN_INTEGER,  RONLY,  var_apAttributeInfo, 1, {23}},

};
/*    (L = length of the oidsuffix) */


/** Initializes the apAttributeInfo module */
void
init_apAttributeInfo(void)
{
  //  'cat  /jffs/.OEM/.vendor_oid'
  FILE *fp;
  char oid_str[64]={0};
  char oid_tmp[64]={0};
  int  oid_len=0;
  int count = 0;
  char *p = NULL;
  char *ptr=NULL;
  
  fp=fopen( "/jffs/.OEM/.vendor_oid","r");
  if(fp)
  {
	  memset(oid_str,0,64);
	  fgets(oid_str,sizeof(oid_str),fp);
	  oid_str[strlen(oid_str)-1] = '\0';
	  fclose(fp); 
   }
  else
  {
	   memset(oid_str,0,64);
	   strcpy(oid_str, "1.3.6.1.4.1.31656"); 
   }
  
  
  memset(oid_tmp,0,64);
  strcpy(oid_tmp,oid_str);
	   
  ptr = strtok(oid_tmp, "."); 
  while(NULL != ptr)
  {
	  oid_len++;
	  ptr = strtok(NULL,".");
   }
  
  oid_len = oid_len + 5;  
  apAttributeInfo_variables_oid=(oid *)malloc(sizeof(oid)*(oid_len));
  
    p = strtok(oid_str, ".");
    while( NULL != p)
    {
         apAttributeInfo_variables_oid[count++] = (oid)atoi(p);
         p = strtok(NULL,".");
    }
    apAttributeInfo_variables_oid[count ++] = 2;
    apAttributeInfo_variables_oid[count ++] = 3;
    apAttributeInfo_variables_oid[count ++] = 2;
    apAttributeInfo_variables_oid[count ++] = 1;
    apAttributeInfo_variables_oid[count ++] = 3;

    DEBUGMSGTL(("apAttributeInfo", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("apAttributeInfo", apAttributeInfo_variables, variable4,
               apAttributeInfo_variables_oid, count);

    /* place any other initialization junk you need here */
}

/*
 * var_apAttributeInfo():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_apAttributeInfo(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char buffer[COUNT_LEN];
    static unsigned char string[COUNT_LEN];
	static unsigned char string1[30];
	
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    static unsigned  percent=0;
    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case APFIREWARE:
   {   FILE *fp;
	    memset( buffer, 0, COUNT_LEN );
	    sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/Software/{print $2}'");
	    fp=popen(buffer,"r");
		memset (string, 0, COUNT_LEN);
		fgets(string,sizeof(string),fp);
		string[strlen(string)-1] = '\0';
		pclose(fp);
		*var_len = strlen(string);
	       return (u_char *)string;
	}
    case APDEVICESN:
       {   
	   FILE *fp;
	    memset( buffer, 0, COUNT_LEN );
	    sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/SN/{print $2}'");
	    fp=popen(buffer,"r");
		if(fp)
		{
			memset (string, 0, COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			*var_len = strlen(string);
	     		  return (u_char *)string;

			}
	
	     }
	
    case APDEVICETYPE:
       {  
	   FILE *fp;
	   memset( buffer, 0, COUNT_LEN );
	   sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/Type/{print $2}'");
	   fp=popen(buffer,"r");
	  	 if(fp)
		    {
			   memset (string, 0, COUNT_LEN);
			   fgets(string,sizeof(string),fp);
			   string[strlen(string)-1] = '\0';
			   pclose(fp);
			*var_len = strlen(string);
	     		  return (u_char *)string;
		   }
		   
	}
	
    case APMODE:
       { 
	   FILE *fp;
	   char buffer[COUNT_LEN];
	   memset( buffer, 0, COUNT_LEN );
	   sprintf( buffer, "%s", "/usr/sbin/showsysinfo|awk -F \":\" '/Ap Mode/{print $2}'");
	   fp=popen(buffer,"r");
		   if(fp)
		   	{
			   memset (string, 0, COUNT_LEN);
			   fgets(string,sizeof(string),fp);
			   string[strlen(string)-1] = '\0';
			   pclose(fp);
			  *var_len = strlen(string);
	     		  return (u_char *)string;
	           }
		   
	  }
	
    case APUPTIME:
     { 
	 FILE *fp;
	    fp=popen( "/usr/bin/uptime |awk '{print $1}'","r");
	     if(fp)
		    {   
		         memset( string, 0, COUNT_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			   pclose(fp);
			  *var_len = strlen(string);
	     		  return (u_char *)string;
		    }
	 }
	
    case APETHUPLINKTRAFFIC:
    { 
	 FILE *fp;
	    fp=popen( "cat  /tmp/interface-rate |awk '/eth0/{print $3}'","r");
	     if(fp)
		    {   
		         memset( string, 0, COUNT_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			   pclose(fp);
			  *var_len = strlen(string);
	     		  return (u_char *)string;
			     }
	}
	
    case APUSRUPLINKTRAFFIC:
      { 
	  FILE *fp;
	    fp=popen( "cat  /tmp/interface-rate |awk '/ath0/{print $3}'","r");
	     if(fp)
		    {   
		      memset( string, 0, COUNT_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			   pclose(fp);
			  *var_len = strlen(string);
	     		  return (u_char *)string;

		   }
      }
	
    case APUTILRESOURCE:
      {   
		 FILE *fp;
		 int sum = 0;
		 int rx=0,tx=0;
		 char str_cmd1[COUNT_LEN];
		 char str_cmd2[COUNT_LEN];

		 memset( str_cmd1, 0, COUNT_LEN );
		 memset( str_cmd1, 0, COUNT_LEN );

		 sprintf( str_cmd1, "%s", "cat /tmp/interface-rate |awk '/ath0/{print $2}'");
                sprintf( str_cmd2, "%s", "cat /tmp/interface-rate |awk '/ath0/{print $3}'");
		 fp=popen(str_cmd1,"r");
		 if(fp)
			{
				memset (string, 0, COUNT_LEN);
				while(fgets(string,sizeof(string),fp)) 
			       {
					  CGetChar(&sum, string);
			        }
				   pclose(fp);
			        rx=sum;	   
			 }
		 fp=popen(str_cmd2,"r");
		 if(fp)
			{
				memset (string, 0, COUNT_LEN);
				while(fgets(string,sizeof(string),fp)) 
			       {
					  CGetChar(&tx, string);
			        }
			          tx=sum;	   
				   pclose(fp);
			 }

       percent = GetPercentage(((tx+rx)*8),23*1024*1024)*100;	 
       long_ret= percent > 100 ? 100 : percent  ;
       return (u_char *)&long_ret;  
}
	
    case APSYSNAME:
        *write_method = write_apSysName;
		{ 
			  FILE *fp;
			  fp=popen( "/usr/sbin/getsysname.sh","r");
			  memset( string, 0, COUNT_LEN );
			  fgets(string,sizeof(string),fp);
			   pclose(fp);
			  *var_len = strlen(string);
	     		  return (u_char *)string;

		}

	 case APDIVIDESSIDCOUNT:
        *write_method = write_apDivideSSIDCount;
	//  long_ret=divideSSIDnum;
		{
			FILE *fp;
			char *q;
			int count=0;
			fp=fopen("/proc/net/dev","r");
			if(fp)
				{
					char line[256];
					while(fgets(line,sizeof(line),fp))
					{
						q=strstr(line, "wifi");
						if(q != NULL)
							count++;
					}
					fclose(fp);
				}
			long_ret = 8*count;
		}
    	 return (u_char *)&long_ret ;

    case APBUSSINESSSSIDPRIORITY:
        *write_method = write_apBussinessSSIDPriority;
	 long_ret=bss_ssid_prio;
          return (u_char *)&long_ret ;

    case APNETADMINSSIDPRIORITY:
        *write_method = write_apNetAdminSSIDPriority;
      	  long_ret=net_ssid_prio;
    	 return (u_char *)&long_ret ;

    case APCHANNELPATTERN:
		  *write_method = write_apChannelPattern;
	      long_ret=channel_pattern;
		   return (u_char *) &long_ret ;
    case APSIGNALNOISERATIO:
	{ 
	  FILE *fp;
	  fp=popen( "/usr/sbin/iwconfig ath0 |awk -F \"[ ]+|:|=\" '/Link/{print $4}'","r");
	  if(fp)
	  	{
		  memset( string, 0, COUNT_LEN );
		  fgets(string,sizeof(string),fp);
		  string[strlen(string)-1] = '\0';
		   pclose(fp);
		  *var_len = strlen(string);
     		  return (u_char *)string;
		  }
	 }	
   
case APWIFI0HOPFREQTIMES:    //heyh modify ---2010-5-6
	    { 
			 FILE *fp;
			  fp=popen( "cat /tmp/auto_channel_count_wifi0","r");
			  if(fp){
			  memset( string, 0, COUNT_LEN );
			  fgets(string,sizeof(string),fp);
		//	  string[strlen(string)-1] = '\0';
			   pclose(fp);
			  	}
			  long_ret = atoi(string);
	     		  return (u_char *)&long_ret;
		}	

   case APWIFI1HOPFREQTIMES:
            { 
		 FILE *fp;
		  fp=popen( "cat /tmp/auto_channel_count_wifi1","r");
		  if(fp)
		  	{
			  memset( string, 0, COUNT_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			   pclose(fp);
		  	}
			  long_ret = atoi(string);
	     		  return (u_char *)&long_ret;
		}


    case APWIFI0HOPFREQDETECTINTERVAL:
        *write_method = write_apWiFi0HopFreqDetectInterval;
             { 
		 FILE *fp;
		  fp=popen( "/usr/sbin/getautochlintvl.sh","r");
		  if(fp)
		  	{
			  memset( string, 0, COUNT_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			   pclose(fp);
		  	}

		}
			    long_ret = atoi(string)*60;
	     		return (u_char *)&long_ret;

  case APWIFI1HOPFREQDETECTINTERVAL:
        *write_method = write_apWiFi1HopFreqDetectInterval;
             { 
		 FILE *fp;
		  fp=popen( "/usr/sbin/getautochlintvl.sh","r");
		  if(fp)
		  	{
			  memset( string, 0, COUNT_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			   pclose(fp);

		  	}
		}
					  long_ret = atoi(string)*60;
		     	  return (u_char *)&long_ret;
    case APPLATTOTERMINALCERTACCOUNT:
	 memset(string,0,COUNT_LEN);
        *write_method = write_apPlatToTerminalCertAccount;
	  strcpy(string,platcert);
           *var_len= strlen( string);
	   return (u_char *) string;
	 
    case APPLATTOTERMINALCERTPASSWORD:
	 memset(string,0,COUNT_LEN);
        *write_method = write_apPlatToTerminalCertPassword;
	  strcpy(string,platkey);
           *var_len = strlen ( string);
	   return (u_char *) string;
	 
    case SECAPUTILRESOURCE:
   {   
		 FILE *fp;
		 int sum = 0;
		 int r=0,t=0;
		 char str_cmd1[COUNT_LEN];
		 char str_cmd2[COUNT_LEN];

		 memset( str_cmd1, 0, COUNT_LEN );
		 memset( str_cmd2, 0, COUNT_LEN );

		 sprintf( str_cmd1, "%s", "cat /tmp/interface-rate |awk '/ath1/{print $2}'");
         sprintf( str_cmd2, "%s", "cat /tmp/interface-rate |awk '/ath1/{print $3}'");
		 fp=popen(str_cmd1,"r");
		 if(fp)
			{
				memset (string, 0, COUNT_LEN);
				while(fgets(string,sizeof(string),fp)) 
			       {
					  CGetChar(&sum, string);
			        }
				   r=sum;
				   printf("111sum:%d\n",sum);
				   pclose(fp);
			 }
		 fp=popen(str_cmd2,"r");
		 if(fp)
			{
				memset (string, 0, COUNT_LEN);
				while(fgets(string,sizeof(string),fp)) 
			       {
					  CGetChar(&sum, string);
			        }
				   t=sum;
				   printf("222sum:%d\n",sum);

				   pclose(fp);
			 }

   percent = GetPercentage(((t+r)*8),23*1024*1024)*100;	 
      long_ret= percent > 100 ? 100 : percent  ;
      return (u_char *)&long_ret;  
}

    case APCONFIGBSSIDNUM:
             { 
			 FILE *fp;
			  fp=popen( " cat /proc/net/wireless |wc -l","r");
			  memset( string, 0, COUNT_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			   pclose(fp); 
			   long_ret=atoi(string);
			   long_ret=long_ret-2;
			   return (u_char *)&long_ret ;
		}
	case APNETIFNUMBER:
		{
			FILE *fp;
			char *p,*q;
			int wificnt=0,ethcnt=0;
			fp=popen("cat /proc/net/dev","r");
			if(fp)
				{
					char line[256];
					while(fgets(line,sizeof(line),fp))
						{
							p=strstr(line,"wifi");
								if(NULL!=p)
									wificnt++;
							q=strstr(line,"eth");
								if(NULL!=q)
									ethcnt++;
						}
					pclose(fp);
				}
			long_ret=wificnt+ethcnt;
			return (u_char *)&long_ret;
		}
		


    default:
      ERROR_MSG("");
    }
    return NULL;
}





int
write_apSysName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char  value[COUNT_LEN];
   char   buffer[COUNT_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apAttributeInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >128* sizeof(char)) {
              fprintf(stderr,"write to apAttributeInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset( buffer, 0, COUNT_LEN);
			memset(value,0,COUNT_LEN);
			memcpy(value, var_val, var_val_len);
			sprintf(buffer,"%s  %s" ,"/usr/sbin/setsysname.sh ",value);
			system(buffer);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apDivideSSIDCount(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apAttributeInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apAttributeInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          //      divideSSIDnum=value;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apBussinessSSIDPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apAttributeInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apAttributeInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

	long_ret = *((long *) var_val);
       if ((long_ret < 1)||(long_ret > 7)) {
            fprintf(stderr, "write to dot11DTIMPeriod:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
               break;

        case RESERVE2:
          //size  = var_val_len;
         // value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
                            bss_ssid_prio=long_ret;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apNetAdminSSIDPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long  long_ret; //modify by heyanhua for set --2010-5-25

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apAttributeInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apAttributeInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	 long_ret = *((long *) var_val);
         if ((long_ret < 1)||(long_ret > 7)) {
            fprintf(stderr, "write to apAttributeInfo:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
                      net_ssid_prio =long_ret;

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apChannelPattern(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   long  value;
   char cmd[128];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apAttributeInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apAttributeInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
		  value=*(long *)var_val;
		  if(value<0||value>1){
		  	fprintf(stderr, "write to apAttributeInfo:bad value\n");
			return SNMP_ERR_WRONGVALUE;
		  	}

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(cmd,0,128);
		  sprintf(cmd,"%s %ld","set_channel_auto ath0",value);
		  system(cmd);
		   channel_pattern=value;
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apWiFi0HopFreqDetectInterval(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long long_ret;
	char cmd[256];
	char cmd1[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apAttributeInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apAttributeInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	 long_ret=*(long *)var_val;	  
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			printf("heyh test long_ret:%ld\n",long_ret);
			memset(cmd,0,256);
			memset(cmd1,0,256);
			printf("heyh test... long_ret:%ld\n",long_ret);
		//	fprintf(cmd,"%s%ld","/usr/sbin/set_crontab \"auto_channel wifi0\" s",long_ret);
			sprintf(cmd,"%s%ld","/usr/sbin/set_crontab \"auto_channel_wifi0\" m",long_ret);
			printf("heyh test cmd:%s\n",cmd);
			system(cmd);
			sprintf(cmd1,"%s %ld","/usr/sbin/setautochlintvl.sh",long_ret);
			printf("heyh test cmd1:%s\n",cmd1);
			system(cmd1);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apWiFi1HopFreqDetectInterval(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long long_ret;
	char cmd[256];
	char cmd1[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apAttributeInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apAttributeInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   long_ret=*(long *) var_val;	  
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(cmd,0,256);
			memset(cmd1,0,256);
			sprintf(cmd,"%s%ld","set_crontab \"auto_channel wifi1\" m",long_ret);
			system(cmd);
			sprintf(cmd1,"%s %ld","/usr/sbin/setautochlintvl.sh",long_ret);
			system(cmd1);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apPlatToTerminalCertAccount(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char  value[COUNT_LEN];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apAttributeInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apAttributeInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          		 memset( value, 0, strlen(value));
			memcpy( value, var_val, var_val_len);
			memset( platcert, 0, 30);
			strcpy(platcert,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apPlatToTerminalCertPassword(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   char value[COUNT_LEN];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apAttributeInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apAttributeInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             		 memset( value, 0, COUNT_LEN);
			memcpy( value, var_val, var_val_len);	
			strcpy(platkey,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

