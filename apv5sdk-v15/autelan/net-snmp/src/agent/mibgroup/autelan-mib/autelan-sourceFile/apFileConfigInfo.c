/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: apFileConfigInfo.c
* description:  implementation for the configuration of Radius server
* 
*
* 
************************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "apFileConfigInfo.h"
#include "wapi/wapicgifunc.h"
#include <ap_interface.h>
/* 
 * apFileConfigInfo_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
static char *hextob ( char *s );

//oid apFileConfigInfo_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,2,1,11 };
oid  *apFileConfigInfo_variables_oid;
 
/* 
 * variable4 apFileConfigInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the apFileConfigInfo mib section 
 */
static u_long long_ret;


struct variable4 apFileConfigInfo_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define MAINRADIUSAUTHSERVERIPADD		1
{MAINRADIUSAUTHSERVERIPADD,  ASN_IPADDRESS,  RWRITE,  var_apFileConfigInfo, 1,  { 1 }},
#define MAINRADIUSAUTHSERVERPORT		2
{MAINRADIUSAUTHSERVERPORT,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 2 }},
#define MAINRADIUSAUTHSERVERSHAREDKEY		3
{MAINRADIUSAUTHSERVERSHAREDKEY,  ASN_OCTET_STR,  RWRITE,  var_apFileConfigInfo, 1,  { 3 }},
#define SECRADIUSAUTHSERVERIPADD		4
{SECRADIUSAUTHSERVERIPADD,  ASN_IPADDRESS,  RWRITE,  var_apFileConfigInfo, 1,  { 4 }},
#define SECRADIUSAUTHSERVERPORT		5
{SECRADIUSAUTHSERVERPORT,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 5 }},
#define SECRADIUSAUTHSERVERSHAREDKEY		6
{SECRADIUSAUTHSERVERSHAREDKEY,  ASN_OCTET_STR,  RWRITE,  var_apFileConfigInfo, 1,  { 6 }},
#define MAINRADIUSACCSERVERIPADD		7
{MAINRADIUSACCSERVERIPADD,  ASN_IPADDRESS,  RWRITE,  var_apFileConfigInfo, 1,  { 7 }},
#define MAINRADIUSACCSERVERPORT		8
{MAINRADIUSACCSERVERPORT,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 8 }},
#define MAINRADIUSACCSERVERSHAREDKEY		9
{MAINRADIUSACCSERVERSHAREDKEY,  ASN_OCTET_STR,  RWRITE,  var_apFileConfigInfo, 1,  { 9 }},
#define SECRADIUSACCSERVERIPADD		10
{SECRADIUSACCSERVERIPADD,  ASN_IPADDRESS,  RWRITE,  var_apFileConfigInfo, 1,  { 10 }},
#define SECRADIUSACCSERVERPORT		11
{SECRADIUSACCSERVERPORT,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 11 }},
#define SECRADIUSACCSERVERSHAREDKEY		12
{SECRADIUSACCSERVERSHAREDKEY,  ASN_OCTET_STR,  RWRITE,  var_apFileConfigInfo, 1,  { 12 }},
#define SYSLOGSVCENABLE		13
{SYSLOGSVCENABLE,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 13 }},
#define SYSLOGSERVERIPADDR		14
{SYSLOGSERVERIPADDR,  ASN_IPADDRESS,  RWRITE,  var_apFileConfigInfo, 1,  { 14 }},
#define APSYSLOGSERVERPORT		15
{APSYSLOGSERVERPORT,  ASN_INTEGER,  RONLY ,  var_apFileConfigInfo, 1,  { 15 }},
#define SYSLOGREPORTEVENTLEVEL		16
{SYSLOGREPORTEVENTLEVEL,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 16 }},
#define LOADFLAG		17
{LOADFLAG,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 17 }},
#define FILENAME		18
{FILENAME,  ASN_OCTET_STR,  RWRITE,  var_apFileConfigInfo, 1,  { 18 }},
#define FILETYPE		19
{FILETYPE,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 19 }},
#define TRANSPROTOCOL		20
{TRANSPROTOCOL,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 20 }},
#define SERVERADDR		21
{SERVERADDR,  ASN_IPADDRESS,  RWRITE,  var_apFileConfigInfo, 1,  { 21 }},
#define SERVERPORT		22
{SERVERPORT,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 22 }},
#define SERVERUSERNAME		23
{SERVERUSERNAME,  ASN_OCTET_STR,  RWRITE,  var_apFileConfigInfo, 1,  { 23 }},
#define SERVERPASSWD		24
{SERVERPASSWD,  ASN_OCTET_STR,  RWRITE,  var_apFileConfigInfo, 1,  { 24 }},
#define TRANSSTATUS		25
{TRANSSTATUS,  ASN_INTEGER,  RONLY ,  var_apFileConfigInfo, 1,  { 25 }},
#define FAILREASON		26
{FAILREASON,  ASN_OCTET_STR,  RONLY ,  var_apFileConfigInfo, 1,  { 26 }},
#define APFILEUPGRADE		27
{APFILEUPGRADE,  ASN_OCTET_STR,  RWRITE,  var_apFileConfigInfo, 1,  { 27 }},
#define SYSLOGMUTIIP		28
{SYSLOGMUTIIP,  ASN_OCTET_STR,  RWRITE,  var_apFileConfigInfo, 1,  { 28 }},
#define MACADDRWITHAC		29
{MACADDRWITHAC,  ASN_OCTET_STR,  RONLY,  var_apFileConfigInfo, 1,  { 29 }},
#define TRAFFICTHRESHHD		30
{TRAFFICTHRESHHD,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 30 }},
#define TRAFFICDIFFTHRESHHD		31
{TRAFFICDIFFTHRESHHD,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 31 }},
#define LOADBALANCETRAFFICEENABLE		32
{LOADBALANCETRAFFICEENABLE,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 32 }},
#define USERSTHRESHHD		33
{USERSTHRESHHD,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 33 }},
#define USERSDIFFTHRESHHD		34
{USERSDIFFTHRESHHD,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 34 }},
#define LOADBALANCEUSERSENABLE		35
{LOADBALANCEUSERSENABLE,  ASN_INTEGER,  RWRITE,  var_apFileConfigInfo, 1,  { 35 }},

};
/*    (L = length of the oidsuffix) */


/** Initializes the apFileConfigInfo module */
void
init_apFileConfigInfo(void)
{
  //  'cat  /jffs/.OEM/.vendor_oid'

    FILE *fp;
    char oid_str[64]={0};
	char oid_tmp[64]={0};
	int  oid_len=0;
	int  count = 0;
    char *p = NULL;
	char *ptr=NULL;

	fp=fopen( "/jffs/.OEM/.vendor_oid","r");
    if(fp)
    {
    	memset(oid_str,0,64);
		fgets(oid_str,sizeof(oid_str),fp);
		oid_str[strlen(oid_str)-1] = '\0';
		fclose(fp);
    }

   else
    {
	    memset(oid_str,0,64);
    	strcpy(oid_str, "1.3.6.1.4.1.31656");  
	}
	
	memset(oid_tmp,0,64);
	strcpy(oid_tmp,oid_str);

	ptr = strtok(oid_tmp, "."); 
	while(NULL != ptr)
	{
		oid_len++;
		ptr = strtok(NULL,".");
	 }
	
    oid_len = oid_len + 5;	
	apFileConfigInfo_variables_oid = (oid *)malloc(sizeof(oid)*(oid_len));

    p = strtok(oid_str, ".");
    while( NULL != p)
     {	
         apFileConfigInfo_variables_oid[count++] = (oid)atoi(p);
         p = strtok(NULL,".");
     }
    apFileConfigInfo_variables_oid[count ++] = 2;
    apFileConfigInfo_variables_oid[count ++] = 3;
    apFileConfigInfo_variables_oid[count ++] = 2;
    apFileConfigInfo_variables_oid[count ++] = 1;
    apFileConfigInfo_variables_oid[count ++] = 11;

    DEBUGMSGTL(("apFileConfigInfo", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("apFileConfigInfo", apFileConfigInfo_variables, variable4,
               apFileConfigInfo_variables_oid,count);

    /* place any other initialization junk you need here */
}

/*
 * var_apFileConfigInfo():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_apFileConfigInfo(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[128];
    static unsigned char para[32];
    static unsigned char buffer[512];
	int  retu_addr=0;
    static oid objid[128];
    static struct counter64 c64;
    prop_data properties[255];
    int prop_count=0;
    FILE *stream;
	char MACWork[17];
    int file_flag=0;
    
    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case MAINRADIUSAUTHSERVERIPADD:
	  memset(para,0,32);
        *write_method = write_MainRadiusAuthServerIPAdd;
	   wireless_radius_get_authip("1",para, 32 );
          retu_addr=inet_addr(para);
	  *var_len = 4;      
	  return ( UCHAR * )&retu_addr;
	  

    case MAINRADIUSAUTHSERVERPORT:
	  memset(para,0,32);
        *write_method = write_MainRadiusAuthServerPort;
         wireless_radius_get_authport( "1",para, 32 ); 
	  ulong_ret=atoi(para);	 
	 return ( UCHAR * )&ulong_ret;
	 
	
    case MAINRADIUSAUTHSERVERSHAREDKEY:
	  memset(para,0,32);
         *write_method = write_MainRadiusAuthServerSharedKey;
          wireless_radius_get_sharekey( "1", para, 32);
	   *var_len = strlen (para );
	   return ( UCHAR * )para;

		
    case SECRADIUSAUTHSERVERIPADD:
	    memset(para,0,32);
        *write_method = write_SecRadiusAuthServerIPAdd;
	   wireless_radius_get_authip("0",para, 32 );
          retu_addr=inet_addr(para);
	  *var_len = 4;      
	  return ( UCHAR * )&retu_addr;
	  
	  
    case SECRADIUSAUTHSERVERPORT:
	  memset(para,0,32);
        *write_method = write_SecRadiusAuthServerPort;
         wireless_radius_get_authport( "0",para, 32 ); 
	  ulong_ret=atoi(para);	 
	 return ( UCHAR * )&ulong_ret;
	 

    case SECRADIUSAUTHSERVERSHAREDKEY:
	 memset(para,0,32);
        *write_method = write_SecRadiusAuthServerSharedKey;
          wireless_radius_get_sharekey( "0", para, 32 );
	   *var_len = strlen (para );
	    return ( UCHAR * )para;
		
		
    case MAINRADIUSACCSERVERIPADD:
	 memset(para,0,32);
        *write_method = write_MainRadiusAccServerIPAdd;
        wireless_radius_get_acctip( "1", para, 32 ); 
          retu_addr=inet_addr(para);
	  *var_len = 4;      
	  return ( UCHAR * )&retu_addr;
	  

    case MAINRADIUSACCSERVERPORT:
	 memset(para,0,32);
        *write_method = write_MainRadiusAccServerPort;
         wireless_radius_get_acctport( "1",para,32 ); 
	  ulong_ret=atoi(para);	 
	 return ( UCHAR * )&ulong_ret;

	 
    case MAINRADIUSACCSERVERSHAREDKEY:
	 memset(para,0,32);
        *write_method = write_MainRadiusAccServerSharedKey;
          wireless_radius_get_asharekey( "1", para, 32 );
	   *var_len = strlen (para );
	    return ( UCHAR * )para;

		
    case SECRADIUSACCSERVERIPADD:
	 memset(para,0,32);
        *write_method = write_SecRadiusAccServerIPAdd;
        wireless_radius_get_acctip( "0", para, 32 ); 
          retu_addr=inet_addr(para);
	  *var_len = 4;      
	  return ( UCHAR * )&retu_addr;

	  
    case SECRADIUSACCSERVERPORT:
	 memset(para,0,32);
        *write_method = write_SecRadiusAccServerPort;
         wireless_radius_get_acctport( "0",para,32 ); 
	  ulong_ret=atoi(para);	 
	 return ( UCHAR * )&ulong_ret;


	 
    case SECRADIUSACCSERVERSHAREDKEY:
	 memset(para,0,32);
        *write_method = write_SecRadiusAccServerSharedKey;
          wireless_radius_get_asharekey( "0", para, 32 );
	   *var_len = strlen (para );
	    return ( UCHAR * )para;

		
    case SYSLOGSVCENABLE:
	 memset(para,0,32);
        *write_method = write_SyslogSvcEnable;
 	 prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
        get_prop("SYSLOG_ENABLE",para,properties,prop_count);
        free_prop(properties,prop_count) ;	   
        ulong_ret =atoi(para);
	 return ( UCHAR * )&ulong_ret;
		 
    case SYSLOGSERVERIPADDR:
	 memset(para,0,32);
        *write_method = write_SyslogServerIPAddr;
 	  prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
         get_prop("SYSLOG_IP",para,properties,prop_count);
         free_prop(properties,prop_count) ;	   
          retu_addr=inet_addr(para);
	  *var_len = 4;      
	  return ( UCHAR * )&retu_addr;

		 
    case APSYSLOGSERVERPORT:
	  ulong_ret=514;	 
	 return ( UCHAR * )&ulong_ret;

    case SYSLOGREPORTEVENTLEVEL:
	 memset(para,0,32);
        *write_method = write_SyslogReportEventLevel;
 	 prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
        get_prop("SYSLOG_LEVEL",para,properties,prop_count);
        free_prop(properties,prop_count) ;	   
        ulong_ret =atoi(para);
        return (unsigned char *) &ulong_ret;
	  
    case LOADFLAG:
        *write_method = write_LoadFlag;
 	 prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
        get_prop("LOAD_FLAG",para,properties,prop_count);
        free_prop(properties,prop_count) ;	   
        ulong_ret =atoi(para);
        return (unsigned char *) &ulong_ret;

	  
    case FILENAME:
	   memset(para,0,32);
        *write_method = write_FileName;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("FILE_NAME",para,properties,prop_count);
          free_prop(properties,prop_count) ;	   
	     *var_len = strlen(para);
          return (unsigned char *) para;    

		  
    case FILETYPE:
	   memset(para,0,32);
        *write_method = write_FileType;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("FILE_TYPE",para,properties,prop_count);
          free_prop(properties,prop_count) ;
          long_ret =atoi(para);
          return (unsigned char *) &long_ret;
		  

    case TRANSPROTOCOL:
	  memset(para,0,32);
        *write_method = write_TransProtocol;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("TRANS_PROTOCOL",para,properties,prop_count);
          free_prop(properties,prop_count) ;
          long_ret =atoi(para);
          return (unsigned char *) &long_ret;

		  
    case SERVERADDR:
	  memset(para,0,32);
        *write_method = write_ServerAddr;
	  prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
         get_prop("SERVER_IP",para,properties,prop_count);
          free_prop(properties,prop_count) ;
	   retu_addr=inet_addr(para);
	  *var_len = 4;      
	  return ( UCHAR * )&retu_addr;
	  
    case SERVERPORT:
	 memset(para,0,32);
        *write_method = write_ServerPort;
        prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
        get_prop("SERVER_PORT",para,properties,prop_count);
        free_prop(properties,prop_count) ;
          long_ret =atoi(para);
          return (unsigned char *) &long_ret;
		  
    case SERVERUSERNAME:
	 memset(para,0,32);
        *write_method = write_ServerUsername;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("SERVER_USERNAME",para,properties,prop_count);
          free_prop(properties,prop_count) ;	   
	  *var_len = strlen(para);
          return (unsigned char *) para;    

    case SERVERPASSWD:
	 memset(para,0,32);
        *write_method = write_ServerPasswd;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("SERVER_PASSWD",para,properties,prop_count);
          free_prop(properties,prop_count) ;	   
	  *var_len = strlen(para);
          return (unsigned char *) para;    


    case TRANSSTATUS:
     {
        FILE *fp1,*fp2;
        fp1=fopen( "/tmp/trans_suc","r");
        fp2=fopen( "/tmp/trans_fail","r");
        if(fp1)
        {
            long_ret = 1;
            fclose(fp1);
        }
        else if(fp2)
        {
            long_ret = 2;
            fclose(fp2);
        }
        else
        {
            long_ret = 0;
        }
        
        return (unsigned char *) &long_ret;
     } 

    case FAILREASON:
        {
            FILE *fp;
            fp = fopen( "/tmp/trans_fail","r");
            if(fp)
            {
                fgets(buffer, sizeof(buffer), fp);
                memset(buffer, 0, sizeof(buffer));
                buffer[strlen(buffer) - 1] = '\0';
                fclose(fp);
            }
            *var_len = strlen(buffer);
            return (unsigned char *) buffer;    
        }


    case APFILEUPGRADE:
        *write_method = write_apFileUpGrade;
	   memset(para,0,32);
	   strcpy(para,"upGrade file");
	  *var_len = strlen(para);
          return (unsigned char *) para;
		  
   case  SYSLOGMUTIIP:
	   memset(buffer,0,512);
        *write_method = write_SyslogMutiIp;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("SYSLOG_MUTIIP",buffer,properties,prop_count);
          free_prop(properties,prop_count) ;	   
	  *var_len = strlen(buffer);
          return (unsigned char *) buffer; 
		  
  case   MACADDRWITHAC:	  
   {   FILE *stream;
   	stream   =   popen("/sbin/ifconfig |awk '/eth0/{print $5}'", "r");   
        if(stream)
		{
	          memset(string,0,256);
		  fgets(string,64,stream);
	         string[strlen(string)-1]='\0';
		  pclose(stream); 
		  } 
		  printf("string:%s\n",string);
		  MACWork[ 0] = string[ 0];
		  MACWork[ 1] = string[ 1];
		  MACWork[ 2] = string[ 3];
		  MACWork[ 3] = string[ 4];
		  MACWork[ 4] = string[ 6];
		  MACWork[ 5] = string[ 7];
		  MACWork[ 6] = string[ 9];
		  MACWork[ 7] = string[10];
		  MACWork[ 8] = string[12];
		  MACWork[ 9] = string[13];
		  MACWork[10] = string[15];
		  MACWork[11] = string[16];
		  MACWork[12] = '\0';
		  *var_len = 6;
		  printf("MACWork:%s\n",MACWork);
		  return (unsigned char *)  hextob ( MACWork );
		
  	}		  

      case TRAFFICTHRESHHD:
        *write_method = write_TrafficThreshhd;
		
      case TRAFFICDIFFTHRESHHD:
        *write_method = write_TrafficDiffThreshhd;
		
      case LOADBALANCETRAFFICEENABLE:
        *write_method = write_LoadBalanceTrafficeEnable;

		
      case USERSTHRESHHD:
	   memset(para,0,32);
        *write_method = write_UsersThreshhd;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("LOADBL_TRD",para,properties,prop_count);
          free_prop(properties,prop_count) ;	   
          long_ret =atoi(para);
          return (unsigned char *) &long_ret;
		  
    case USERSDIFFTHRESHHD:
	   memset(para,0,32);
        *write_method = write_UsersDiffThreshhd;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("LOADBL_DVA",para,properties,prop_count);
          free_prop(properties,prop_count) ;	   
          long_ret =atoi(para);
          return (unsigned char *) &long_ret;
    case LOADBALANCEUSERSENABLE:
	   memset(para,0,32);
        *write_method = write_LoadBalanceUsersEnable;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("LOADBL_ENA",para,properties,prop_count);
          free_prop(properties,prop_count) ;	   
          long_ret =atoi(para);
          return (unsigned char *) &long_ret;

    default:
      ERROR_MSG("");
    }
    return NULL;
}





int
write_MainRadiusAuthServerIPAdd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char strBuf[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
       //   size  = var_val_len;
        //  value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(strBuf,0,32);
              sprintf(strBuf,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
              	wireless_radius_set_authip( "1", strBuf);


	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_MainRadiusAuthServerPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,32);
	  sprintf( strTemp, "%d",*(long *) var_val);
	  wireless_radius_set_authport( "1",strTemp );
	  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_MainRadiusAuthServerSharedKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[32];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32*sizeof(char)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
 
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			
              memset(value,0,32);
              memcpy(value,var_val,var_val_len);
	       value[var_val_len]='\0';
	       wireless_radius_set_sharekey( "1",value); 
 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SecRadiusAuthServerIPAdd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
     char strBuf[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
 
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			
		memset(strBuf,0,32);
              sprintf(strBuf,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
	       wireless_radius_set_authip( "0", strBuf);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SecRadiusAuthServerPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

	  memset(strTemp,0,32);
	  sprintf( strTemp, "%d",*(long *) var_val);
	  wireless_radius_set_authport( "0",strTemp );
	  
	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SecRadiusAuthServerSharedKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char value[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32*sizeof(char)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
     

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
              memset(value,0,32);
              memcpy(value,var_val,var_val_len);
	       value[var_val_len]='\0';
	       wireless_radius_set_sharekey( "0",value); 

	 break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_MainRadiusAccServerIPAdd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
      u_long value;
     char strBuf[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        //  size  = var_val_len;
     //     value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(strBuf,0,32);
              sprintf(strBuf,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
		wireless_radius_set_acctip( "1",strBuf);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_MainRadiusAccServerPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,32);
	  sprintf( strTemp, "%d",*(long *) var_val);
	 wireless_radius_set_acctport( "1",strTemp); 


	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_MainRadiusAccServerSharedKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
              memset(value,0,32);
              memcpy(value,var_val,var_val_len);
	       value[var_val_len]='\0';
		wireless_radius_set_asharekey( "1",value); 

	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SecRadiusAccServerIPAdd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
     char strBuf[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(strBuf,0,32);
              sprintf(strBuf,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
		wireless_radius_set_acctip( "0",strBuf);

	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SecRadiusAccServerPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[32];
    long long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	 long_ret =*((long *) var_val);
	   if(1 != long_ret){
		    fprintf(stderr,"write to apGeneralInfo: bad value\n");
		    return SNMP_ERR_WRONGVALUE;
	   	}          break;

        case RESERVE2:
          
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,32);
	  sprintf( strTemp, "%d",long_ret);
	 wireless_radius_set_acctport( "0",strTemp); 

		  break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SecRadiusAccServerSharedKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           	memset(value,0,32);
              memcpy(value,var_val,var_val_len);
	       value[var_val_len]='\0';
		wireless_radius_set_asharekey( "0",value); 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SyslogSvcEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[32];
    char strBuf[32];
    char para[32];
    char string[256];
	
    static struct counter64 c64;
    prop_data properties[255];
    int prop_count=0;
    int prop_numb=0;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  
	  long_ret=*((long *) var_val);
	  if(long_ret<0||long_ret>1){
	    fprintf(stderr,"write to apFileConfigInfo: bad value\n");
              return SNMP_ERR_WRONGVALUE;
	    }
          break;

        case RESERVE2:
     
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	
	         sprintf(strBuf,"%d",long_ret);
	         save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","SYSLOG_ENABLE",strBuf);
		    memset(strTemp,0,32);
	        memset(strBuf,0,32);
	  	    system("killall syslogd 1>/dev/null 2>&1");
            if( long_ret == 1)
            {
 	 	    prop_numb=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
        	    get_prop("SYSLOG_MUTIIP",strTemp,properties,prop_numb);
                   free_prop(properties,prop_numb) ;	   
 	 	    prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
        	    get_prop("SYSLOG_LEVEL",strBuf,properties,prop_count);
                   free_prop(properties,prop_count) ;	  
			printf("strTemp:%s  strBuf:%s\n",strTemp,strBuf);	   
		     sprintf(string,"%s  \"%s\"  %s  %s","/sbin/syslogd  -R",strTemp, "-l",strBuf);
		     printf("syslog:string is: %s\n",string);
                    system(string);
            }



       break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SyslogServerIPAddr(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    u_long value;
    char strBuf[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(strBuf,0,32);
              sprintf(strBuf,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
	       save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","SYSLOG_IP",strBuf);
			  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SyslogReportEventLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[64];
    long long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	 long_ret =*((long *) var_val);
	 /*  hyh modify--20091020 */
	 //  if(1 != long_ret){
	    if(long_ret<1||long_ret>7){
		    fprintf(stderr,"write to apGeneralInfo: bad value\n");
		    return SNMP_ERR_WRONGVALUE;
	   	}          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",long_ret);
	  save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","SYSLOG_LEVEL",strTemp);

	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

//heyanhua modify 2010-5-3
int
write_LoadFlag(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char  string[256];
	char  string1[256];
    char para[64];
    char strBuf[64];
    char strTemp[64];
    long  long_ret,file_type;
    static struct counter64 c64;
    prop_data properties[255];
    int prop_count=0;
    int prop_numb=0;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	        long_ret  =*((long *) var_val);
	   	if((long_ret<1)||(long_ret>2)){
              fprintf(stderr,"write to apFileConfigInfo: bad value\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   
          break;

        case RESERVE2:
 

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(para,0,32);
			prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
			get_prop("FILE_TYPE",para,properties,prop_count);
			free_prop(properties,prop_count);
			file_type=atoi(para);
			
			if(long_ret==1&&file_type==1){
			memset(strBuf,0,64);
	  memset(strTemp,0,64);
			prop_numb=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
	               get_prop("SERVER_IP",strBuf,properties,prop_numb);
	               free_prop(properties,prop_numb) ;
			prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
	               get_prop("FILE_NAME",strTemp,properties,prop_count);
	               free_prop(properties,prop_count) ;
             memset(para,0,64);
			 prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
	               get_prop("FILE_NAME",para,properties,prop_count);
	               free_prop(properties,prop_count) ;	
                   system("rm -rf /tmp/trans_fail");
                   system("rm -rf /tmp/trans_suc");
		        sprintf(string," ( %s && %s %s  %s  %s 1>/tmp/translog" \
		       " 2>/tmp/trans_fail && rm -rf /tmp/trans_fail && touch " \
		       "/tmp/trans_suc && /usr/sbin/sysupgrade /tmp/%s && " \
		       "/sbin/sysreboot ) &","cd  /tmp","tftp   -g" 
		       ,strBuf,"-r",strTemp, para);
			 printf("tftp string:%s\n",string);
			 system(string);
	       }
			else if(long_ret==1&&file_type==2)
			{
				memset(strBuf,0,64);
				memset(para,0,64);
				memset(string,0,256);
				memset(string1,0,256);
				prop_numb=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
				get_prop("SERVER_IP",strBuf,properties,prop_numb);
				free_prop(properties,prop_numb);

				prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
				get_prop("FILE_NAME",para,properties,prop_count);
				free_prop(properties,prop_count);
				sprintf(string,"%s %s %s","tftp -g -r",para,strBuf);
				sprintf(string1,"%s %s %s","cp",para,"/jffs/");
				system("cd /tmp");
				system(string);
				system(string1);
				system("/sbin/sysreboot");
			}
			else if(long_ret==2)
				{
					memset(string,0,64);
					memset(strBuf,0,64);
					memset(para,0,64);
					prop_numb=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
					get_prop("SERVER_IP",strBuf,properties,prop_numb);
					free_prop(properties,prop_numb);

					prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
					get_prop("FILE_NAME",para,properties,prop_count);
					free_prop(properties,prop_count);
					sprintf(string,"%s%s %s","cp /jffs/",para,"/tmp/");
					printf("heyh test ---string:%s\n",string);
					system(string);
				}
			
          

	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_FileName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[128];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

		  break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,128);
	       memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
	      save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","FILE_NAME",value);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_FileType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char strTemp[64];
    long value;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	   save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","FILE_TYPE",strTemp);

		 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_TransProtocol(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	   save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","TRANS_PROTOCOL",strTemp);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ServerAddr(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     long  value;
     char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(strTemp,0,64);
              sprintf(strTemp,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
	       save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","SERVER_IP",strTemp);

		  break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ServerPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	    long_ret=*((long *) var_val);	
		
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

	   memset(strTemp,0,64);
	  sprintf( strTemp, "%d",long_ret);
	   save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","SERVER_PORT",strTemp);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ServerUsername(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[128];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32*sizeof(char)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

		memset(value,0,128);
	       memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
	       save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","SERVER_USERNAME",value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ServerPasswd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[128];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,128);
	       memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
	       save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","SERVER_PASSWD",value);
   

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apFileUpGrade(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[128];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

		  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_SyslogMutiIp(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[512];
    char string[512];
    char strBuf[32];
	prop_data properties[255];
    int prop_count=0;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >512* sizeof(char)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:

		memset(value,0,512);
		memset(string,0,512);
		memset(strBuf,0,512);
	       memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
	       save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","SYSLOG_MUTIIP",value);
		  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_TrafficThreshhd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_TrafficDiffThreshhd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_LoadBalanceTrafficeEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}




int
write_UsersThreshhd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long  long_ret;
    char strTemp[64];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	        long_ret  =*((long *) var_val);
	   	if((long_ret<1)||(long_ret>128)){
              fprintf(stderr,"write to apFileConfigInfo: bad value\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",long_ret);
	  save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","LOADBL_TRD",strTemp);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_UsersDiffThreshhd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long  long_ret;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

	        long_ret  =*((long *) var_val);
	   if((long_ret<1)||(long_ret>128)){
              fprintf(stderr,"write to apFileConfigInfo: bad value\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",long_ret);
	  save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","LOADBL_DVA",strTemp);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_LoadBalanceUsersEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long  long_ret;
    char para[64];
    char strBuf[64];
    char strTemp[64];
    char string[128];
    prop_data properties[255];
    int prop_count=0;
    int prop_numb=0;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apFileConfigInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apFileConfigInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

	        long_ret  =*((long *) var_val);
	   if((long_ret!=0)&&(long_ret!=1)&&(long_ret!=2)){
              fprintf(stderr,"write to apFileConfigInfo: bad value\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  if(long_ret==1)
	     {
	     	 memset(para, 0, 64);
	       sprintf( para, "%d", long_ret);
		memset(strBuf, 0, 64);
		memset(strTemp, 0, 64);
		save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","LOADBL_ENA",para);
		prop_numb=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
               get_prop("LOADBL_TRD",strBuf,properties,prop_numb);
               free_prop(properties,prop_numb) ;
		prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
               get_prop("LOADBL_DVA",strTemp,properties,prop_count);
               free_prop(properties,prop_count) ;
	       sprintf(string,"%s  %s   %s &","/usr/sbin/server",strBuf,strTemp);
        system(string);
		system("/usr/sbin/client &");
	       }
	  else if (long_ret==2)
	  	{
		   system("/usr/sbin/client &");
	        }
	  else 
	  	{
			system("killall server");
			system("killall client");
	        }
	  		  
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


static char *hextob ( char *s )
{
    char nibl, *byt;
    static char bin[20];

    byt = bin;

    while ((nibl = *s++) && nibl != ' ') {    /* While not end of string. */
      nibl -= ( nibl > '9') ?  ('a' - 10): '0';
      *byt = nibl << 4;                              /* place high nibble */
      if((nibl = *s++) && nibl != ' ') {
        nibl -= ( nibl > '9') ?  ('a' - 10): '0';
        *byt |= nibl;                                /*  place low nibble */
      }
      else break;
      ++byt;
    }
    *++byt = '\0';
    return ( bin );
}


