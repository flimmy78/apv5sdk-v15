/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: apGeneralInfo.c
* description:  implementation for the general information of AP
* 
*
* 
************************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "apGeneralInfo.h"
#include "wapi/wapicgifunc.h"
#include <ap_interface.h>

/* 
 * apGeneralInfo_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

//oid apGeneralInfo_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,2,1,10 };
oid *apGeneralInfo_variables_oid;
/* 
 * variable4 apGeneralInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the apGeneralInfo mib section 
 */



struct variable4 apGeneralInfo_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define SYSTIME		1
{SYSTIME,  ASN_OCTET_STR,  RWRITE,  var_apGeneralInfo, 1,  { 1 }},
#define PRIMDNSSERVERIPADD		2
{PRIMDNSSERVERIPADD,  ASN_IPADDRESS,  RWRITE,  var_apGeneralInfo, 1,  { 2 }},
#define SECONDNSSERVERIPADD		3
{SECONDNSSERVERIPADD,  ASN_IPADDRESS,  RWRITE,  var_apGeneralInfo, 1,  { 3 }},
#define SNMPPORT		4
{SNMPPORT,  ASN_INTEGER,  RONLY ,  var_apGeneralInfo, 1,  { 4 }},
#define READCOMMUNITYNAME		5
{READCOMMUNITYNAME,  ASN_OCTET_STR,  RWRITE,  var_apGeneralInfo, 1,  { 5 }},
#define WRITECOMMUNITYNAME		6
{WRITECOMMUNITYNAME,  ASN_OCTET_STR,  RWRITE,  var_apGeneralInfo, 1,  { 6 }},
#define STATWINDOWTIME		7
{STATWINDOWTIME,  ASN_TIMETICKS,  RWRITE,  var_apGeneralInfo, 1,  { 7 }},
#define SAMPLETIME		8
{SAMPLETIME,  ASN_INTEGER,  RWRITE,  var_apGeneralInfo, 1,  { 8 }},
#define HEARTBEATPERIOD		9
{HEARTBEATPERIOD,  ASN_INTEGER,  RWRITE,  var_apGeneralInfo, 1,  { 9 }},
#define SYSREMOTERESTART		10
{SYSREMOTERESTART,  ASN_INTEGER,  RWRITE,  var_apGeneralInfo, 1,  { 10 }},
#define SYSRESTART		11
{SYSRESTART,  ASN_INTEGER,  RWRITE,  var_apGeneralInfo, 1,  { 11 }},
#define SYSRESET		12
{SYSRESET,  ASN_INTEGER,  RWRITE,  var_apGeneralInfo, 1,  { 12 }},
#define SOFTWARENAME		13
{SOFTWARENAME,  ASN_OCTET_STR,  RONLY ,  var_apGeneralInfo, 1,  { 13 }},
#define SOFTWAREVERSION		14
{SOFTWAREVERSION,  ASN_OCTET_STR,  RONLY ,  var_apGeneralInfo, 1,  { 14 }},
#define SOFTWAREVENDOR		15
{SOFTWAREVENDOR,  ASN_OCTET_STR,  RONLY ,  var_apGeneralInfo, 1,  { 15 }},
#define CPUTYPE		16
{CPUTYPE,  ASN_OCTET_STR,  RONLY ,  var_apGeneralInfo, 1,  { 16 }},
#define CPUUSAGETHRESHHD		17
{CPUUSAGETHRESHHD,  ASN_INTEGER,  RWRITE,  var_apGeneralInfo, 1,  { 17 }},
#define APMEMORYTYPE		18
{APMEMORYTYPE,  ASN_OCTET_STR,  RONLY ,  var_apGeneralInfo, 1,  { 18 }},
#define MEMORYSIZE		19
{MEMORYSIZE,  ASN_GAUGE,  RONLY ,  var_apGeneralInfo, 1,  { 19 }},
#define MEMUSAGETHRESHHD		20
{MEMUSAGETHRESHHD,  ASN_INTEGER,  RWRITE,  var_apGeneralInfo, 1,  { 20 }},
#define APFLASHSIZE		21
{APFLASHSIZE,  ASN_GAUGE,  RONLY ,  var_apGeneralInfo, 1,  { 21 }},
#define ROGUEAPTRIGGER		22
{ROGUEAPTRIGGER,  ASN_OCTET_STR,  RWRITE,  var_apGeneralInfo, 1,  { 22 }},
#define SETPINGIPADDR    24
{SETPINGIPADDR, ASN_IPADDRESS, RWRITE, var_apGeneralInfo, 1, {24}},
#define SYSPINGTESTING   25
{SYSPINGTESTING, ASN_OCTET_STR, RONLY, var_apGeneralInfo, 1, {25}},
#define HARDWAREVERSION  26
{HARDWAREVERSION, ASN_OCTET_STR, RONLY, var_apGeneralInfo, 1, {26}},
#define SETPINGIPV6ADDR   27
{SETPINGIPV6ADDR, ASN_OCTET_STR, RWRITE, var_apGeneralInfo, 1, {27}},
#define SYSPINGIPV6TESTING  28
{SYSPINGIPV6TESTING, ASN_OCTET_STR, RONLY, var_apGeneralInfo, 1, {28}},
};
/*    (L = length of the oidsuffix) */


/** Initializes the apGeneralInfo module */
void
init_apGeneralInfo(void)
{
  //  'cat  /jffs/.OEM/.vendor_oid'

    FILE *fp;
  	char oid_str[64]={0};
  	char oid_tmp[64]={0};
  	int  oid_len=0;
  	int  count = 0;
  	char *p = NULL;
  	char *ptr=NULL;
	
    fp=fopen( "/jffs/.OEM/.vendor_oid","r");
    if(fp)
    {
    	memset(oid_str,0,64);
		fgets(oid_str,sizeof(oid_str),fp);
		oid_str[strlen(oid_str)-1] = '\0';
		fclose(fp);
    }

   else
    {
	   memset(oid_str,0,64);
       strcpy(oid_str, "1.3.6.1.4.1.31656"); 
	}

	memset(oid_tmp,0,64);
	strcpy(oid_tmp,oid_str);

	ptr = strtok(oid_tmp, "."); 
	while(NULL != ptr)
	{
		oid_len++;
		ptr = strtok(NULL,".");
	 }
	
    oid_len = oid_len + 5;	
	apGeneralInfo_variables_oid = (oid *)malloc(sizeof(oid)*(oid_len));

	p = strtok(oid_str, ".");
    while( NULL != p)
   {
       apGeneralInfo_variables_oid[count++] = (oid)atoi(p);
       p = strtok(NULL,".");
    }
    apGeneralInfo_variables_oid[count ++] = 2;
    apGeneralInfo_variables_oid[count ++] = 3;
    apGeneralInfo_variables_oid[count ++] = 2;
    apGeneralInfo_variables_oid[count ++] = 1;
    apGeneralInfo_variables_oid[count ++] = 10;

    DEBUGMSGTL(("apGeneralInfo", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("apGeneralInfo", apGeneralInfo_variables, variable4,
               apGeneralInfo_variables_oid,count);

    /* place any other initialization junk you need here */
}

/*
 * var_apGeneralInfo():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_apGeneralInfo(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[256];
	static unsigned char string1[2048];
	char string2[2048];
    static  char   str_tmp[1024];
    static unsigned char ap_parameter[256];
    static unsigned char para[256];
	static unsigned char ipaddr[32];
    prop_data properties[255];
    int prop_count=0;
    static oid objid[128];
    static struct counter64 c64;
    FILE  *stream;
    static char buffer[4][32];
    static char strBuf[2][32];
    static char MACWork[17];
    static char *token;
    static char *pos;  
	static int retu_addr=0;
    int byte_read=0;
    int memTotal=0;
    int  i=0;
	
	
    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case SYSTIME:
        *write_method = write_SysTime;
	 stream=popen("date","r");
	  if(stream)
	    {
		  memset( string, 0, 256 );
		  fgets(string,sizeof(string),stream);
		  string[strlen(string)-1] = '\0';
		  pclose(stream);
		  *var_len = strlen (string );
	      return (u_char*)string;
	    }

    case PRIMDNSSERVERIPADD:
	 memset( string, 0, 256 );
        *write_method = write_PrimDNSServerIPAdd;
	  network_get_dns(string,1,20 );
	   retu_addr=inet_addr(string);
	  *var_len = 4;      
	  return (u_char*)&retu_addr;

    case SECONDNSSERVERIPADD:
	 memset( string, 0, 256 );
        *write_method = write_SeconDNSServerIPAdd;
	  network_get_dns(string,2,20 );
	   retu_addr=inet_addr(string);
	  *var_len = 4;      
	  return (u_char*)&retu_addr;
	  
    case SNMPPORT:
	     ulong_ret =161;
            return (u_char*) &ulong_ret;
			
    case READCOMMUNITYNAME:
        *write_method = write_ReadCommunityName;
		memset(string,0,256);
		memset(para,0,256);
	       memset(buffer[0],0,32);
	       memset(buffer[1],0,32);
	       memset(buffer[2],0,32);
	       memset(buffer[3],0,32);
		   
		stream=fopen("/etc/snmp/snmpd.conf","r");
		if(stream)
		{
			fgets(string,64,stream);
			token=strtok(string," ");
			while(NULL!=token)
				{
		                 strcpy(buffer[i],token);
				   token=strtok(NULL," ");
				    i++;
				  }
			 strcpy(para,buffer[3]);
		         para[strlen(para)-1] = '\0';
			 fclose(stream);
		 }
	    *var_len = strlen(para);
            return (u_char *) para; 

			
    case WRITECOMMUNITYNAME:
        *write_method = write_WriteCommunityName;
	       memset(string,0,256);
		memset(para,0,256);
	       memset(buffer[0],0,32);
	       memset(buffer[1],0,32);
	       memset(buffer[2],0,32);
	       memset(buffer[3],0,32);
		   
		stream=fopen("/etc/snmp/snmpd.conf","r");
		if(stream)
		{
			fgets(string,64,stream);
			fgets(string,64,stream);
			token=strtok(string," ");
			while(NULL!=token)
				{
		                 strcpy(buffer[i],token);
				   token=strtok(NULL," ");
				    i++;
				  }
			 strcpy(para,buffer[3]);
			 para[strlen(para)-1] = '\0';
			 fclose(stream);
		 }
	    *var_len = strlen(para);
            return (u_char *) para;    

	case STATWINDOWTIME:
        *write_method = write_StatWindowTime;
	   memset(ap_parameter,0,256);
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("STAT_WINDOW_TIME",ap_parameter,properties,prop_count);
          free_prop(properties,prop_count) ;	   
          long_ret =atoi(ap_parameter);
          return (u_char*) &long_ret;
		
    case SAMPLETIME:
	   memset(ap_parameter,0,256);
          *write_method = write_SampleTime;
	   prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
          get_prop("SAMPLE_TIME",ap_parameter,properties,prop_count);
          free_prop(properties,prop_count) ;	   
          ulong_ret =atoi(ap_parameter);
          return (u_char*) &ulong_ret;

		
    case HEARTBEATPERIOD:
	memset(ap_parameter,0,256);
       *write_method = write_HeartbeatPeriod;
	prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
       get_prop("HEART_BEAT_PERIOD",ap_parameter,properties,prop_count);
       free_prop(properties,prop_count) ;	   
        ulong_ret =atoi(ap_parameter);
        return (u_char*) &ulong_ret;
      case SYSREMOTERESTART:
        *write_method = write_SysRemoteRestart;
	     ulong_ret =1;
            return (u_char*) &ulong_ret;
    case SYSRESTART:
        *write_method = write_SysRestart;
	     ulong_ret =1;
            return (u_char*) &ulong_ret;
			
    case SYSRESET:
        *write_method = write_SysReset;
	     ulong_ret =1;
            return (u_char*) &ulong_ret;
			
  case SOFTWARENAME:
   memset(para,0,256);
   sprintf(para,"%s","/usr/sbin/showsysinfo |awk -F \":\"  '/Device/{print  $2}' ");
   stream=popen(para,"r");
   if(stream)
   	{
          memset(string,0,256);
	   fgets(string,sizeof(string),stream);
	   string[strlen(string)-1]='\0';
	   pclose(stream);
       }

	*var_len = strlen(string);
         return (u_char*) string;    


 case SOFTWAREVERSION:
   memset(para,0,256);
   sprintf(para,"%s","/usr/sbin/showsysinfo |awk -F \":\" '/Software/{print $2}'");
   stream=popen(para,"r");
   if(stream)
   	{
          memset(string,0,256);
	   fgets(string,sizeof(string),stream);
	   string[strlen(string)-1]='\0';
	   pclose(stream);
       }

	*var_len = strlen(string);
         return (u_char*) string;    

    case SOFTWAREVENDOR:
   memset(para,0,256);
   sprintf(para,"%s","/usr/sbin/showsysinfo |awk -F \":\"  '/Company/{print  $2}' ");
   stream=popen(para,"r");
   if(stream)
   	{
          memset(string,0,256);
	   fgets(string,sizeof(string),stream);
	   string[strlen(string)-1]='\0';
	   pclose(stream);
       }

	*var_len = strlen(string);
         return (u_char*) string;    
		 
    case CPUTYPE:
      stream   =   fopen("/proc/cpuinfo",   "r");   
      if(stream)
		{
			fgets(string,64,stream);
			token=strtok(string,":");
			while(NULL!=token)
				{
		                 strcpy(strBuf[i],token);
				   token=strtok(NULL,":");
				    i++;
				  }
			 strcpy(para,strBuf[1]);
			  para[strlen(para)-1] = '\0';
			 fclose(stream);
		 }
	    *var_len = strlen(para);
            return (u_char*) para;    


    case CPUUSAGETHRESHHD:
        *write_method = write_CPUusageThreshhd;
	 prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
        get_prop("CPU_USAGE_THRESHHD",ap_parameter,properties,prop_count);
        free_prop(properties,prop_count) ;	   
        ulong_ret =atoi(ap_parameter);
        return (u_char*) &ulong_ret;


    case APMEMORYTYPE:
	 memset(ap_parameter,0,256);
	 prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
        get_prop("AP_MEMORY",ap_parameter,properties,prop_count);
        free_prop(properties,prop_count) ;	   
	 *var_len = strlen(ap_parameter);
         return (u_char*) ap_parameter;    

    case MEMORYSIZE:
      stream = fopen("/proc/meminfo", "r");   
      byte_read=fread(str_tmp, 1, sizeof(str_tmp), stream);   
      fclose(stream);   
      if (byte_read==0||byte_read==sizeof(str_tmp))   
      return   -1;   
      str_tmp[byte_read]   =   '\0';   
       pos   =   strstr(str_tmp,   "MemTotal:");   
      if   (NULL==pos)     
      return   -1;   
      sscanf(pos,   "MemTotal:               %d   kB",  &memTotal);
	 printf("memTotal:%d\n",memTotal);
       long_ret =memTotal*1024;   
       return (u_char *) &long_ret;

    case MEMUSAGETHRESHHD:
	 memset(ap_parameter,0,256);
        *write_method = write_MemUsageThreshhd;
	prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
      get_prop("MEM_USAGE_THRESHHD",ap_parameter,properties,prop_count);
       free_prop(properties,prop_count) ;	   
        ulong_ret =atoi(ap_parameter);
        return (u_char*) &ulong_ret;

    case APFLASHSIZE:
        long_ret =32*1024*1024;   
        return (u_char *) &long_ret;
		
    case ROGUEAPTRIGGER:
        *write_method = write_RogueApTrigger;
	memset(string,0,256);
	strcpy(string,"trigger rogue ap");
	 *var_len = strlen(string);
       return (u_char*) string;   

//heyanhua add for setPingIPaddr ---2010-4-23
    case SETPINGIPADDR:
		memset(ipaddr,0,32);
		*write_method = write_setPingIPaddr;
		 prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
         get_prop("PING_ADDR",ipaddr,properties,prop_count);
         free_prop(properties,prop_count) ;	 
		 printf("setPingIPaddr:%s\n",ipaddr);
          retu_addr=inet_addr(ipaddr);
	  *var_len = 4;      
	  return ( UCHAR * )&retu_addr;
		

//heyanhua add for ping testing ---2010-4-22
	case SYSPINGTESTING:
		{
			FILE *fp;
			char cmd[128];
			memset(cmd, 0, 128);
			memset(string1,0,2048);
			memset(string2,0,2048);

			prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
         get_prop("PING_ADDR",para,properties,prop_count);
         free_prop(properties,prop_count) ;	   
		 printf("The PING_ADDR is :%s\n",para);
        //  retu_addr=inet_addr(para);
			sprintf(cmd,"%s %s","/bin/ping -c 4",para);

				fp=popen(cmd,"r");
				if(fp)
				{
					while(NULL!=fgets(string1,sizeof(string1),fp))
					strcat(string2,string1);
					printf("heyanhua test! string1:%s\n",string1);
					pclose(fp);
				}
			*var_len=strlen(string2);
			printf("heyanhua test 1:string2:%s\n",string2);
			return (u_char *)string2;
		}
	
	case HARDWAREVERSION:  //heyanhua add 2010-4-30
		{
			FILE *fp;
			fp=popen("/usr/sbin/showsysinfo |awk -F : '/Hardware/ {print $2}'","r");
			if(fp)
				{
					memset(string,0,256);
					fgets(string,sizeof(string),fp);
					pclose(fp);
				}
			*var_len=strlen(string);
			return (u_char *)string;
		}
	case SETPINGIPV6ADDR:
		memset(string,0,256);
			*write_method=write_setPingIPv6addr;
			prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
         get_prop("PING_IPv6_ADDR",string,properties,prop_count);
         free_prop(properties,prop_count) ;	 
		 printf("setPingIPaddr:%s\n",string);
	  *var_len = strlen(string);      
	  return ( UCHAR * )string;

	  case SYSPINGIPV6TESTING:
	  	{
			FILE *fp;
			char cmd[128];
			memset(cmd, 0, 128);
			memset(string1,0,2048);
			memset(string2,0,2048);

			prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
         get_prop("PING_IPv6_ADDR",para,properties,prop_count);
         free_prop(properties,prop_count) ;	   
		 printf("The PING_IPv6_ADDR is :%s\n",para);
			sprintf(cmd,"%s %s","/bin/ping6 -c 4",para);

				fp=popen(cmd,"r");
				if(fp)
				{
					while(NULL!=fgets(string1,sizeof(string1),fp))
					strcat(string2,string1);
					printf("heyanhua test! string1:%s\n",string1);
					pclose(fp);
				}
			*var_len=strlen(string2);
			printf("heyanhua test 1:string2:%s\n",string2);
			return (u_char *)string2;
		}

    default:
      ERROR_MSG("");
    }
    return NULL;
}





int
write_SysTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[128];
    char string[128];

    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apGeneralInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
        //  value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,128);
		memset(string,0,128);
	       memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
		sprintf(string,"%s   %s","date  -s",value);
		system(string);
		
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_PrimDNSServerIPAdd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     long value;
     char strBuf[128];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apGeneralInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(strBuf,0,128);
              sprintf(strBuf,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
              network_set_dns(strBuf,1);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SeconDNSServerIPAdd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     long value;
     char strBuf[128];

	switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apGeneralInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(strBuf,0,128);
              sprintf(strBuf,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
              network_set_dns(strBuf,2);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_ReadCommunityName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
        FILE *fp;
     char string[1024];
     char strTemp[256];
     char strBuf[2][32];
     char *token;
     char *cnew;
     int byte_read;
     int i=0;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apGeneralInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32*sizeof(char)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
          memset(strTemp,0,256);
	  memset(strBuf[0],0,32);
	  memset(strBuf[1],0,32);
	  memset(string,0,1024);
	  system("killall  snmpd");
	  memcpy(strTemp, var_val, var_val_len);
         strTemp[var_val_len] = '\0';
	  token = strtok(strTemp, ":");
  		while (NULL != token)
			{
			        strcpy(strBuf[i],token);   
				token = strtok(NULL,":");
				i++;
			}
		
		fp=fopen("/etc/snmp/snmpd.conf","r+");
               byte_read=fread(string,1,sizeof(string),fp);
		 if(byte_read==0||byte_read==sizeof(string))
		     return -1;
		 string[byte_read]='\0';
		 fclose(fp);
		 cnew=str_replace(string,strBuf[0],strBuf[1]);
		 fp=fopen("/etc/snmp/snmpd.conf","w+");
	        fwrite(cnew,byte_read,1,fp);
		 fclose(fp);
		system("/usr/sbin/snmpd  -c   /etc/snmp/snmpd.conf  -C  &");
		
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_WriteCommunityName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
      FILE *fp;
     char string[1024];
     char strTemp[256];
     char strBuf[2][32];
     char *token;
     char *cnew;
     int byte_read;
     int i=0;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apGeneralInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
 	  memset(strTemp,0,256);
	  memset(strBuf[0],0,32);
	  memset(strBuf[1],0,32);
	  memset(string,0,1024);
	  system("killall  snmpd");
	  memcpy(strTemp, var_val, var_val_len);
         strTemp[var_val_len] = '\0';
	  token = strtok(strTemp, ":");
  		while (NULL != token)
			{
			        strcpy(strBuf[i],token);   
				token = strtok(NULL,":");
				i++;
			}
		
		fp=fopen("/etc/snmp/snmpd.conf","r+");
               byte_read=fread(string,1,sizeof(string),fp);
		 if(byte_read==0||byte_read==sizeof(string))
		     return -1;
		 string[byte_read]='\0';
		 fclose(fp);
		 cnew=str_replace(string,strBuf[0],strBuf[1]);
		 fp=fopen("/etc/snmp/snmpd.conf","w+");
	        fwrite(cnew,byte_read,1,fp);
		fclose(fp);
		system("/usr/sbin/snmpd  -c   /etc/snmp/snmpd.conf  -C  &");

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_StatWindowTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_TIMETICKS) {
              fprintf(stderr, "write to apGeneralInfo not ASN_TIMETICKS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
   //       size  = var_val_len;
     //     value = * (u_long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	   save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","STAT_WINDOW_TIME",strTemp);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SampleTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apGeneralInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
       //   value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*(long *) var_val);
	   save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","SAMPLE_TIME",strTemp);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_HeartbeatPeriod(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;
    char strTemp[64];
    char string[128];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apGeneralInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
       //   size  = var_val_len;
       //   value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
 	  memset(strTemp,0,64);
 	  memset(string,0,128);
	  sprintf( strTemp, "%d",*(long *) var_val);
	  save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","HEART_BEAT_PERIOD",strTemp);
	  sprintf(string,"%s%s","/usr/sbin/set_crontab /usr/sbin/pertrap m",strTemp);
	  printf("string:%s\n",string);
	  system(string);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_SysRemoteRestart(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apGeneralInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

	   long_ret = *((long *) var_val);
	   if(1 != long_ret){
	    fprintf(stderr,"write to apGeneralInfo: bad value\n");
		return SNMP_ERR_WRONGVALUE;}

          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			system("/sbin/syscoldreboot");
        break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SysRestart(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apGeneralInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

	  long_ret = *((long *) var_val);
	   if(1 != long_ret){
	    fprintf(stderr,"write to apGeneralInfo: bad value\n");
		return SNMP_ERR_WRONGVALUE;
		}

          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
               ap_system_reboot () ;  
	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SysReset(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apGeneralInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  
	 long_ret =*((long *) var_val);
	   if(1 != long_ret){
		    fprintf(stderr,"write to apGeneralInfo: bad value\n");
		    return SNMP_ERR_WRONGVALUE;
	   	}

          break;

        case RESERVE2:
         

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			ap_system_reset();
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_CPUusageThreshhd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{

    long value;
    int size;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apGeneralInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }


          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	   memset(strTemp,0,64);
	   sprintf( strTemp, "%d",*((long *) var_val));
	   save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","CPU_USAGE_THRESHHD",strTemp);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_MemUsageThreshhd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    char strTemp[64];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apGeneralInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	  memset(strTemp,0,64);
	  sprintf( strTemp, "%d",*((long *) var_val));
	   save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","MEM_USAGE_THRESHHD",strTemp);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_RogueApTrigger(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned char string[128];
    static unsigned char para[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apGeneralInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(string,0,128);
		memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		sprintf(para,"%s  %s","/usr/sbin/rogueap_detect",string);
		printf("para:%s\n",para);
		system(para);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

//heyanhua add for setPingIPaddr  ---2010-4-23
int
write_setPingIPaddr(int action,
			u_char   *var_val,
			u_char    var_val_type,
			size_t    var_val_len,
			u_char   *statP,
			oid      *name,
			size_t    name_len)
{
	 u_long value;
     char strBuf[32];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apGeneralInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to apGeneralInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			  memset(strBuf,0,32);
              sprintf(strBuf,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
              save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","PING_ADDR",strBuf);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_setPingIPv6addr(int action,
				u_char	 *var_val,
				u_char	  var_val_type,
				size_t	  var_val_len,
				u_char	 *statP,
				oid 	 *name,
				size_t	  name_len)
	{
		 u_long value;
		 char strBuf[128];
	
		switch ( action ) {
			case RESERVE1:
			  if (var_val_type != ASN_OCTET_STR) {
				  fprintf(stderr, "write to apGeneralInfo not ASN_OCTET_STR\n");
				  return SNMP_ERR_WRONGTYPE;
			  }
			  if (var_val_len > 128*sizeof(char)) {
				  fprintf(stderr,"write to apGeneralInfo: bad length\n");
				  return SNMP_ERR_WRONGLENGTH;
			  }
			  break;
	
			case RESERVE2:
	
			  break;
	
			case FREE:
				 /* Release any resources that have been allocated */
			  break;
	
			case ACTION:
				  memset(strBuf,0,128);
				 // sprintf(strBuf,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
				 memcpy(strBuf,var_val,var_val_len);
				  save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"","PING_IPv6_ADDR",strBuf);
			  break;
	
			case UNDO:
				 /* Back out any changes made in the ACTION case */
			  break;
	
			case COMMIT:
				 /*
				  * Things are working well, so it's now safe to make the change
				  * permanently.  Make sure that anything done here can't fail!
				  */
			  break;
		}
		return SNMP_ERR_NOERROR;
	}

