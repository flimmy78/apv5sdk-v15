/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: attackLogTable.c
* description:  implementation for the log information of WIDS 
* 
*
* 
************************************************************************************/


/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "attackLogTable.h"

#define  ATTACK_LOG   "/tmp/attr-log"

int  get_log_line();
void  get_log_content(int  index_line,char *result );
/* 
 * attackLogTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

//oid attackLogTable_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,2,1,12 };
oid *attackLogTable_variables_oid;
/* 
 * variable4 attackLogTable_variables:
 *   this variable defines function callbacks and type return information 
 *   for the attackLogTable mib section 
 */

struct variable4 attackLogTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

//#define ATTACKLOGINDEX		1
//{ATTACKLOGINDEX,  ASN_INTEGER,  RONLY,   var_attackLogTable, 2,  {  1, 1 }},
#define ATTACKLOGVALUE		2
{ATTACKLOGVALUE,  ASN_OCTET_STR,  RONLY,   var_attackLogTable, 2,  {  1, 2 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the attackLogTable module */
void
init_attackLogTable(void)
{
  //  'cat  /jffs/.OEM/.vendor_oid'
  FILE *fp;
  char oid_str[64]={0};
  char oid_tmp[64]={0};
  int  oid_len=0;
  int  count = 0;
  char *p = NULL;
  char *ptr=NULL;
  
  fp=fopen( "/jffs/.OEM/.vendor_oid","r");
  if(fp)
  {
	  memset(oid_str,0,64);
	  fgets(oid_str,sizeof(oid_str),fp);
	  oid_str[strlen(oid_str)-1] = '\0';
	  fclose(fp);
  }
  else
   {
	  memset(oid_str,0,64);
	  strcpy(oid_str, "1.3.6.1.4.1.31656"); 
   }
  
  
  memset(oid_tmp,0,64);
  strcpy(oid_tmp,oid_str);
	   
  ptr = strtok(oid_tmp, "."); 
  while(NULL != ptr)
  {
	  oid_len++;
	  ptr = strtok(NULL,".");
   }
  
  oid_len = oid_len + 5;  
  attackLogTable_variables_oid = (oid *)malloc(sizeof(oid)*(oid_len));
  
    p = strtok(oid_str, ".");
    while( NULL != p)
    {
         attackLogTable_variables_oid[count++] = (oid)atoi(p);
         p = strtok(NULL,".");
    }
	
    attackLogTable_variables_oid[count ++] = 2;
    attackLogTable_variables_oid[count ++] = 3;
    attackLogTable_variables_oid[count ++] = 2;
    attackLogTable_variables_oid[count ++] = 1;
    attackLogTable_variables_oid[count ++] = 12;

    DEBUGMSGTL(("attackLogTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("attackLogTable", attackLogTable_variables, variable4,
               attackLogTable_variables_oid,count);

    /* place any other initialization junk you need here */
}


/*
 * var_attackLogTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_attackLogTable above.
 */
unsigned char *
var_attackLogTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[256];
    static unsigned char buffer[256];
    static unsigned char value[256];
    static unsigned char strBuf[256];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
     int  i = 0,lineSize;
	 
    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
   
    lineSize=get_log_line();
    if(lineSize==0)
	return NULL;
	  	
    if (header_simple_table(vp,name,length,exact,var_len,write_method, lineSize)
                                                == MATCH_FAILED )
    return NULL;
	
    for ( i = 1; i <=name[*length - 1]; i++ )
      {
        memset(string,0,256);
        get_log_content(i,string);
     }
	
    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
			
    case ATTACKLOGVALUE:
	 *var_len = strlen (string);
	  return (u_char *)string;
    default:
      ERROR_MSG("");
    }
    return NULL;
}

    int  get_log_line()
	{
	     FILE *fp;
	     int  retu;
	     char buffer[256];
	     char value[256];
	      memset( buffer, 0, 256 );
    	  fp=fopen( ATTACK_LOG,"r");
          if(fp==NULL)
	      return 0;
	      sprintf( buffer, "%s  %s%s", "cat", ATTACK_LOG ,"|wc -l");
	      fp=popen(buffer,"r");
	       if(fp){
		memset (value, 0, 256);
		fgets(value,sizeof(value),fp);
		value[strlen(value)-1] = '\0';
		pclose(fp);}
		retu=atoi(value);
		return  retu;
    	}

void get_log_content(int  index_line,char *result )
{
	FILE *fp;
	char string[256];
	char strBuf[256];
	memset(string,0,256);
	memset(strBuf,0,256);
	sprintf( string, "%s  %s%s%d%s", "cat", ATTACK_LOG ,"| awk  NR==\" ", index_line, " \" ");
	fp=popen(string,"r");
	if(fp){
               memset (strBuf, 0, 256);
		fgets(strBuf,sizeof(strBuf),fp);
		strcpy(result,strBuf);  
	       }
	pclose(fp);
	
}

