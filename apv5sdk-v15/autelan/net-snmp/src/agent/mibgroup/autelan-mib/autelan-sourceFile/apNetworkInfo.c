/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: apNetworkInfo.c
* description:  implementation for the network information of AP
* 
*
* 
************************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "apNetworkInfo.h"
#include <ap_interface.h>
#define  NET_LEN    256
#define CHAR_LEN  128  //heyh add 20100415

char net_channel[256]="net admin channel";
char tr069_channel[256]="tr069 admin channel";

/* 
 * apNetworkInfo_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
 

//oid apNetworkInfo_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,2,1,2 };
oid *apNetworkInfo_variables_oid;
/* 
 * variable4 apNetworkInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the apNetworkInfo mib section 
 */

struct variable4  apNetworkInfo_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define APIPADDRESS		1
{APIPADDRESS,  ASN_IPADDRESS,  RWRITE,  var_apNetworkInfo, 1,  { 1 }},
#define APNETMASK		2
{APNETMASK,  ASN_IPADDRESS,  RWRITE,  var_apNetworkInfo, 1,  { 2 }},
#define APGATEWAY		3
{APGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_apNetworkInfo, 1,  { 3 }},
#define APIPMODE		4
{APIPMODE,  ASN_OCTET_STR,  RWRITE,  var_apNetworkInfo, 1,  { 4 }},
#define APDNSMODE		5
{APDNSMODE,  ASN_OCTET_STR,  RWRITE,  var_apNetworkInfo, 1,  { 5 }},
#define APTIMEZONE		6
{APTIMEZONE,  ASN_OCTET_STR,  RONLY ,  var_apNetworkInfo, 1,  { 6 }},
#define APNTPMODE		7
{APNTPMODE,  ASN_OCTET_STR,  RWRITE,  var_apNetworkInfo, 1,  { 7 }},
#define APDEFAULTNTP		8
{APDEFAULTNTP,  ASN_OCTET_STR,  RONLY ,  var_apNetworkInfo, 1,  { 8 }},
#define APNTPTIME		9
{APNTPTIME,  ASN_OCTET_STR,  RONLY ,  var_apNetworkInfo, 1,  { 9 }},
#define APGETIPMODE		10
{APGETIPMODE,  ASN_OCTET_STR,  RWRITE,  var_apNetworkInfo, 1,  { 10 }},
#define APLOGSERVERADDRESS		11
{APLOGSERVERADDRESS,  ASN_OCTET_STR,  RWRITE,  var_apNetworkInfo, 1,  { 11 }},
#define APDHCPSERVERSTATUS		12
{APDHCPSERVERSTATUS,  ASN_OCTET_STR,  RWRITE,  var_apNetworkInfo, 1,  { 12 }},
#define APDHCPSERVERPLEASETIME		13
{APDHCPSERVERPLEASETIME,  ASN_INTEGER,  RWRITE,  var_apNetworkInfo, 1,  { 13 }},
#define APNETADMINCHANNEL		14
{APNETADMINCHANNEL,  ASN_OCTET_STR,  RWRITE,  var_apNetworkInfo, 1,  { 14 }},
#define APNETADMINSERVERIP		15
{APNETADMINSERVERIP,  ASN_OCTET_STR,  RWRITE,  var_apNetworkInfo, 1,  { 15 }},
#define APVLANID		16
{APVLANID,  ASN_INTEGER,  RWRITE,  var_apNetworkInfo, 1,  { 16 }},
#define PRIMNTPSERVERIPADD		17
{PRIMNTPSERVERIPADD,  ASN_IPADDRESS,  RWRITE,  var_apNetworkInfo, 1,  { 17 }},
#define SECONNTPSERVERIPADD		18
{SECONNTPSERVERIPADD,  ASN_IPADDRESS,  RWRITE,  var_apNetworkInfo, 1,  {18}},
#define APSHOWVLANID		19
{APSHOWVLANID,  ASN_OCTET_STR,  RWRITE,  var_apNetworkInfo, 1,  { 19 }},
#define TR069BASEDCHANNEL     20     //heyanhua  add start ----2010-04-13
{TR069BASEDCHANNEL, ASN_OCTET_STR , RWRITE ,var_apNetworkInfo , 1,{20}},
#define TR069BASEDSERVERIP    21
{TR069BASEDSERVERIP, ASN_IPADDRESS, RWRITE, var_apNetworkInfo, 1,{21}},
#define TR069PLATCERTACCOUNT    22
{TR069PLATCERTACCOUNT, ASN_OCTET_STR , RWRITE, var_apNetworkInfo, 1 ,{22}},
#define TR069PLATCERTKEY    23
{TR069PLATCERTKEY,ASN_OCTET_STR , RWRITE ,var_apNetworkInfo, 1, {23}},
#define TR069TERMINALCERTACCOUNT  24
{TR069TERMINALCERTACCOUNT,ASN_OCTET_STR, RWRITE, var_apNetworkInfo, 1, {24}},
#define TR069TERMINALCERTKEY  25
{TR069TERMINALCERTKEY, ASN_OCTET_STR, RWRITE, var_apNetworkInfo, 1, {25}},
};

/*    (L = length of the oidsuffix) */


/** Initializes the apNetworkInfo module */
void
init_apNetworkInfo(void)
{
  //  'cat  /jffs/.OEM/.vendor_oid'
  	FILE *fp;
  	char oid_str[64]={0};
  	char oid_tmp[64]={0};
  	int  oid_len=0;
  	int  count = 0;
  	char *p = NULL;
  	char *ptr=NULL;
	
    fp=fopen( "/jffs/.OEM/.vendor_oid","r");
    if(fp)
    {
		memset(oid_str,0,64);
    	fgets(oid_str,sizeof(oid_str),fp);
		oid_str[strlen(oid_str)-1] = '\0';
		fclose(fp);
    }
    else
     {
		memset(oid_str,0,64);
     	strcpy(oid_str, "1.3.6.1.4.1.31656");
	 }

	memset(oid_tmp,0,64);
	strcpy(oid_tmp,oid_str);
		 
    ptr = strtok(oid_tmp, "."); 
	while(NULL != ptr)
	{
		oid_len++;
		ptr = strtok(NULL,".");
	 }
	
    oid_len = oid_len + 5;	
	apNetworkInfo_variables_oid = (oid *)malloc(sizeof(oid)*(oid_len));

    p = strtok(oid_str, ".");
    while( NULL != p)
    {
         apNetworkInfo_variables_oid[count++] = (oid)atoi(p);
         p = strtok(NULL,".");
    }
    apNetworkInfo_variables_oid[count ++] = 2;
    apNetworkInfo_variables_oid[count ++] = 3;
    apNetworkInfo_variables_oid[count ++] = 2;
    apNetworkInfo_variables_oid[count ++] = 1;
    apNetworkInfo_variables_oid[count ++] = 2;
    DEBUGMSGTL(("apNetworkInfo", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("apNetworkInfo", apNetworkInfo_variables, variable4,
               apNetworkInfo_variables_oid, count);

    /* place any other initialization junk you need here */
}

/*
 * var_apNetworkInfo():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_apNetworkInfo(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[NET_LEN];
    static unsigned char buffer[NET_LEN];
    char strBuf[1024];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    static int  retu_addr=0;
     FILE *fp;
if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case APIPADDRESS:
        *write_method = write_apIpAddress;
	   { 
 		 fp=popen( "/sbin/ifconfig  default |awk -F \"[ ]+|:\" '/inet addr/{print $4}'","r");
		 if(fp)
		     {
	 		 memset( buffer, 0, NET_LEN );
	 		 fgets(buffer,sizeof(buffer),fp);
	 		 buffer[strlen(buffer)-1] = '\0';
			 pclose(fp);
		     }
		  retu_addr = inet_addr(buffer);
	        *var_len = 4;      
	         return ( u_char * )&retu_addr;
	   }
		
    case APNETMASK:
        *write_method = write_apNetMask;
	   { 
 		 fp=popen( "/sbin/ifconfig  default |awk -F \"[ ]+|:\" '/Mask/{print $8}'","r");
		 if(fp)
		     {
	 		 memset( buffer, 0, NET_LEN );
	 		 fgets(buffer,sizeof(buffer),fp);
	 		 buffer[strlen(buffer)-1] = '\0';
			 pclose(fp);
		    }
		 retu_addr = inet_addr(buffer);
	        *var_len = 4;      
	         return ( u_char * )&retu_addr;
	   }
		
    case APGATEWAY:
        *write_method = write_apGateWay;
	   { 
 		 fp=popen( "/sbin/route -n|awk  'NR==\"4\"{print $2}'","r");
		 if(fp)
		 {
	 		 memset( buffer, 0, NET_LEN );
	 		 fgets(buffer,sizeof(buffer),fp);
	 		 buffer[strlen(buffer)-1] = '\0';
		        pclose(fp);
			 retu_addr = inet_addr(buffer);
	              *var_len = 4;      
	              return ( u_char * )&retu_addr;
		  }	  
		}
		
    case APIPMODE:
		memset(string,0,NET_LEN);
		*write_method = write_apIpMode;
		network_get_ipmode( string, 30 );
		*var_len = strlen (string );
	     return ( u_char * )string;
		 
    case APDNSMODE:
		 memset(string,0,NET_LEN);
	        *write_method = write_apDnsMode;
	        network_get_dnsmode(string,20 );
		*var_len = strlen (string);
		  return ( u_char * ) string;
		  
    case APTIMEZONE:
		 memset(string,0,NET_LEN);
		network_get_timezone( string ,30);	
		*var_len = strlen ( string);
	     return ( u_char * )string;
		 
    case APNTPMODE:
	        memset(string,0,NET_LEN);
              *write_method = write_apNtpMode;
		 network_get_ntpmode(string , 30);
		*var_len = strlen ( string);
	     return ( u_char * )string;
		 
    case APDEFAULTNTP:
	        memset(string,0,NET_LEN);
		network_get_defaultntp( string ,30);
		 *var_len = strlen (string );
	     return ( u_char * ) string;
		 
    case APNTPTIME:
       { 
		  fp=popen( "/bin/date -R","r");
		  if(fp)
		  {
			  memset( string, 0, NET_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			  pclose(fp);
		    }
			  *var_len = strlen (string);
			  return ( u_char * )string;
	         
	  }
		  
    case APGETIPMODE:
        *write_method = write_apGetIpMode;
	   { 
		  fp=popen( "/usr/sbin/getipmode.sh","r");
		  if(fp)
		      {
			  memset( string, 0, NET_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			   pclose(fp);
			}
		  *var_len = strlen ( string);
		  return ( u_char * )string;
	    }
		
  case APLOGSERVERADDRESS:
        *write_method = write_apLogServerAddress;
	{
	  fp=popen( "/usr/sbin/getlogserver.sh","r");
	  if(fp)
	  	{
		  memset( string, 0, NET_LEN );
		  fgets(string,sizeof(string),fp);
		  string[strlen(string)-1] = '\0';
		  pclose(fp);
	       }
	  *var_len = strlen (string  );
	  return ( u_char * ) string;
       }
		
    case APDHCPSERVERSTATUS:
        *write_method = write_apDHCPServerStatus;
     	{
		fp=popen( "/usr/sbin/getdhcpstatus.sh","r");
		if(fp)
		   {
			 memset( string, 0, NET_LEN );
			 fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
		   }
		*var_len = strlen (string );
		return ( u_char * )string;
	     }
		
    case APDHCPSERVERPLEASETIME:
        *write_method = write_apDHCPServerPleaseTime;
      {
		fp=popen( "/usr/sbin/getdhcpleasetime.sh","r");
		if(fp)
		  {
			 memset( string, 0, NET_LEN );
			 fgets(string,sizeof(string),fp);
			 string[strlen(string)-1] = '\0';
			 pclose(fp);
		 }
		 long_ret=atoi(string);
		return ( u_char * ) &long_ret;
	     }
		
    case APNETADMINCHANNEL:
        *write_method = write_apNetAdminChannel;
	  strcpy(string,net_channel);	
	  *var_len = strlen (string );
          return (u_char*)string;
    case APNETADMINSERVERIP:
	 memset( string, 0, NET_LEN );
        *write_method = write_apNetAdminServerIP;
          snmp_get_trapipaddr(string, 64);
	   printf("string:%s\n",string);
	  *var_len = strlen (string );
          return (u_char*)string;
		  
    case APVLANID:
        *write_method = write_apVlanID;
	 return ( u_char * ) &long_ret;

		
    case PRIMNTPSERVERIPADD:
	 memset( string, 0, NET_LEN );
        *write_method = write_PrimNTPServerIPAdd;
	  network_get_ntp(string,1,20 );
	  retu_addr = inet_addr(string);
	  *var_len = 4;      
	  return ( u_char * )&retu_addr;

    case SECONNTPSERVERIPADD:
	 memset( string, 0, NET_LEN );
        *write_method = write_SeconNTPServerIPAdd;
	  network_get_ntp(string,2,20 );
	  retu_addr = inet_addr(string);
	  *var_len = 4;      
	  return ( u_char * )&retu_addr;
	  
    case APSHOWVLANID:
     *write_method =  write_apShowVlanID;
   { 
	  if(fp=popen( "/usr/sbin/brctl  show","r")){
		  memset( string, 0,NET_LEN );
		  memset(strBuf,0,1024);
		  while(NULL != fgets(string,sizeof(string),fp)){
		  	strcat(strBuf, string);
		     }
		  pclose(fp);
		  strBuf[strlen(strBuf)-1]='\0';
		  *var_len = strlen (strBuf );
		  return (u_char*)strBuf;
	   }
   }    
	 case TR069BASEDCHANNEL:
	 	*write_method= write_tr069BasedChannel;
		strcpy(string,tr069_channel);	
	    *var_len = strlen (string );
          return (u_char*)string;
		
	 case TR069BASEDSERVERIP:
	 	*write_method= write_tr069BasedServerIP;
	 	{
	 		FILE *fp;
			char line[256];
			fp=popen("/usr/sbin/gettr069acs.sh","r");
			if(fp)
			{
				memset(line,0,256);
				fgets(line,sizeof(line),fp);
				strcpy(string,line);
				string[strlen(string)-1]='\0';
				fclose(fp);
			}
	 	}
		retu_addr= inet_addr(string);
	 *var_len=4;
	 return (u_char *)&retu_addr;
	 case TR069PLATCERTACCOUNT:
	 	*write_method= write_tr069PlatCertAccount;
	 {
	 		FILE *fp;
			char line[256];
			fp=popen("/usr/sbin/gettr069passwd.sh |awk 'NR==1'","r");
			if(fp)
			{
				memset(line,0,256);
				fgets(line,sizeof(line),fp);
				strcpy(string,line);
				fclose(fp);
			}
	 	}
	 	*var_len=strlen(string);
	 return (u_char *)string;
	 case TR069PLATCERTKEY:
	 	*write_method= write_tr069PlatCertKey;
	 {
	 		FILE *fp;
			char line[256];
			fp=popen("/usr/sbin/gettr069passwd.sh |awk 'NR==2'","r");
			if(fp)
			{
				memset(line,0,256);
				fgets(line,sizeof(line),fp);
				strcpy(string,line);
				fclose(fp);
			}
	 	}
	 *var_len=strlen(string);
	 return (u_char *)string;
	 case TR069TERMINALCERTACCOUNT:
	 	*write_method=write_tr069TerminalCertAccount;
	 	{
	 		FILE *fp;
			char line[256];
			fp=popen("/usr/sbin/gettr069passwd.sh |awk 'NR==3'","r");
			if(fp)
			{
				memset(line,0,256);
				fgets(line,sizeof(line),fp);
				strcpy(string,line);
				fclose(fp);
			}
	 	}
		*var_len=strlen(string);
	 return (u_char *)string;
	 case TR069TERMINALCERTKEY:
	 	*write_method=write_tr069TerminalCertKey;
	 	{
	 		FILE *fp;
			char line[256];
			fp=popen("/usr/sbin/gettr069passwd.sh |awk 'NR==4'","r");
			if(fp)
			{
				memset(line,0,256);
				fgets(line,sizeof(line),fp);
				strcpy(string,line);
				fclose(fp);
			}
	 	}
	 *var_len=strlen(string);
	 return (u_char *)string;
	  
    default:
      ERROR_MSG("");
    }
    return NULL;
}





int
write_apIpAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     static  char  value[NET_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apNetworkInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(value,0,NET_LEN);
		       sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
		       network_set_ip("default", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apNetMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char  value[NET_LEN];
 
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apNetworkInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
 
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,NET_LEN);
		   sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
		   network_set_netmask("default", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apGateWay(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     static  char value[NET_LEN ];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apNetworkInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,NET_LEN);
		  sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
                 network_set_gw( value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apIpMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static char value [NET_LEN ];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memcpy(value,var_val,var_val_len);
		    	value[var_val_len]='\0';
                      network_set_dnsmode(value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apDnsMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static char value[NET_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
           		 memcpy(value,var_val,var_val_len);
		       value[var_val_len]='\0';
			network_set_dnsmode(value);
            break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apNtpMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static char value[NET_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memcpy(value,var_val,var_val_len);
		        value[var_val_len]='\0';
            		 network_set_ntpmode(value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apGetIpMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   static  char value[NET_LEN];
   static  char string[NET_LEN];
   
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
 		memset( value, 0, NET_LEN);
	        memset( string, 0, NET_LEN);
		memcpy(value,var_val,var_val_len);
		sprintf(string,"%s  %s","/usr/sbin/setipmode.sh  ",value);
		system(string);
             break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apLogServerAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static char value[NET_LEN];
    static char string[NET_LEN];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
                	memset( string, 0, NET_LEN);
                	memset( value, 0, NET_LEN);
			 memcpy(value,var_val,var_val_len);
			sprintf(string,"%s  %s","/usr/sbin/setlogserver.sh ",value);
			system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apDHCPServerStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static char value[NET_LEN];
    static char string[NET_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            memset( value, 0, NET_LEN);
            memset( string, 0, NET_LEN);
             memcpy(value,var_val,var_val_len);
	     sprintf(string,"%s%s" , "/usr/sbin/setdhcpstatus.sh  ",value);
	      system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apDHCPServerPleaseTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static char string[NET_LEN];
    static long long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apNetworkInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	    long_ret = *( (long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            memset( string, 0, NET_LEN);
	     sprintf(string,"%s  %d" , "/usr/sbin/setdhcpleasetime.sh   ",long_ret);
	      system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apNetAdminChannel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[256];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 256*sizeof(char)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
      //    size  = var_val_len;
      //    value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(value,0,256);
			memset(net_channel,0,256);
			memcpy(value,var_val,var_val_len);
			strcpy(net_channel,value);
			
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apNetAdminServerIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static char value[NET_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >32* sizeof(char)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	          memset(value,0,NET_LEN);
	          memcpy(value,var_val,var_val_len);
	           snmp_set_trapipaddr(value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_apVlanID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apNetworkInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_PrimNTPServerIPAdd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     static  char  value[NET_LEN];
	 char cmd[128];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apNetworkInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,NET_LEN);
		memset(cmd,0,128);
	       sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
		   sprintf(cmd,"%s %s","settimeserver1.sh",value);
		   system(cmd);
               network_set_ntp(value,1);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SeconNTPServerIPAdd(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     static  char  value[NET_LEN];
	 char cmd[128];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apNetworkInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
  
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,NET_LEN);
	       sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
		   sprintf(cmd,"%s %s","settimeserver2.sh",value);
		   system(cmd);
               network_set_ntp(value,2);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}





int
write_apShowVlanID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apNetworkInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/* heyh add start   ---2010-04-13  */
int
write_tr069BasedChannel(int action,
                  u_char  *var_val,
                  u_char   var_val_type,
                  size_t   var_val_len,
                  u_char  *statP,
                  oid     *name,
                  size_t   name_len)
{
	    char value[256];
		int size;
	
		switch ( action ) {
			case RESERVE1:
			  if (var_val_type != ASN_OCTET_STR) {
				  fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
				  return SNMP_ERR_WRONGTYPE;
			  }
			  if (var_val_len > 256*sizeof(char)) {
				  fprintf(stderr,"write to apNetworkInfo: bad length\n");
				  return SNMP_ERR_WRONGLENGTH;
			  }
			  break;
	
			case RESERVE2:
		//	  size	= var_val_len;
		//	  value = * (char *) var_val;
	
			  break;
	
			case FREE:
				 /* Release any resources that have been allocated */
			  break;
	
			case ACTION:
				memset(value,0,256);
				memset(tr069_channel,0,256);
				memcpy(value,var_val,var_val_len);
				strcpy(tr069_channel,value);
			  break;
	
			case UNDO:
				 /* Back out any changes made in the ACTION case */
			  break;
	
			case COMMIT:
				 /*
				  * Things are working well, so it's now safe to make the change
				  * permanently.  Make sure that anything done here can't fail!
				  */
			  break;
		}
		return SNMP_ERR_NOERROR;

}

int
write_tr069BasedServerIP(int action,
                u_char  *var_val,
                u_char   var_val_type,
                size_t   var_val_len,
                u_char   *statP,
                oid      *name,
                size_t   name_len)
{
	 static char value[NET_LEN];
	 static char cmd[256];
	
		switch ( action ) {
			case RESERVE1:
			  if (var_val_type != ASN_IPADDRESS) {
				  fprintf(stderr, "write to apNetworkInfo not ASN_OCTET_STR\n");
				  return SNMP_ERR_WRONGTYPE;
			  }
			  if (var_val_len >sizeof(long)) {
				  fprintf(stderr,"write to apNetworkInfo: bad length\n");
				  return SNMP_ERR_WRONGLENGTH;
			  }
			  break;
	
			case RESERVE2:
	
			  break;
	
			case FREE:
				 /* Release any resources that have been allocated */
			  break;
	
			case ACTION:
				  memset(value,0,NET_LEN);
				  memset(cmd,0,256);
				  sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
				  sprintf(cmd,"%s %s","/usr/sbin/settr069acs.sh",value);
				  system(cmd);
			//	   snmp_set_trapipaddr(value);
			  break;
	
			case UNDO:
				 /* Back out any changes made in the ACTION case */
			  break;
	
			case COMMIT:
				 /*
				  * Things are working well, so it's now safe to make the change
				  * permanently.  Make sure that anything done here can't fail!
				  */
			  break;
		}
		return SNMP_ERR_NOERROR;

}

int
write_tr069PlatCertAccount(int action,
              u_char   *var_val,
              u_char    var_val_type,
              size_t    var_val_len,
              u_char   *statP,
              oid      *name,
              size_t    name_len)
{
		char value[CHAR_LEN];
		char string[CHAR_LEN];
	
		switch ( action ) {
			case RESERVE1:
			  if (var_val_type != ASN_OCTET_STR) {
				  fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
				  return SNMP_ERR_WRONGTYPE;
			  }
			  if (var_val_len >128* sizeof(char)) {
				  fprintf(stderr,"write to apCommonInfo: bad length\n");
				  return SNMP_ERR_WRONGLENGTH;
			  }
			  break;
	
			case RESERVE2:
	
			  break;
	
			case FREE:
				 /* Release any resources that have been allocated */
			  break;
	
			case ACTION:
				 memset( value, 0, CHAR_LEN);
			     memset(string, 0, CHAR_LEN);		 
				 memcpy(value,var_val,var_val_len);
			 sprintf(string,"%s %s" , "/usr/sbin/settr069suser.sh",value);
			  system(string);   
			  break;
	
			case UNDO:
				 /* Back out any changes made in the ACTION case */
			  break;
	
			case COMMIT:
				 /*
				  * Things are working well, so it's now safe to make the change
				  * permanently.  Make sure that anything done here can't fail!
				  */
			  break;
		}
		return SNMP_ERR_NOERROR;

}

int
write_tr069PlatCertKey(int action,
             u_char    *var_val,
             u_char     var_val_type,
             size_t     var_val_len,
             u_char    *statP,
             oid       *name,
             size_t     name_len)
{
		char value[CHAR_LEN];
		char string[CHAR_LEN];
	
		switch ( action ) {
			case RESERVE1:
			  if (var_val_type != ASN_OCTET_STR) {
				  fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
				  return SNMP_ERR_WRONGTYPE;
			  }
			  if (var_val_len > 128*sizeof(char)) {
				  fprintf(stderr,"write to apCommonInfo: bad length\n");
				  return SNMP_ERR_WRONGLENGTH;
			  }
			  break;
	
			case RESERVE2:
			  //size  = var_val_len;
			 // value = * (char *) var_val;
	
			  break;
	
			case FREE:
				 /* Release any resources that have been allocated */
			  break;
	
			case ACTION:
			memset( value, 0, CHAR_LEN);
				memset( string, 0, CHAR_LEN);
				 memcpy(value,var_val,var_val_len);
			 sprintf(string, "%s %s" ,  "/usr/sbin/settr069spass.sh",value);
			  system(string);                     
			  break;
	
			case UNDO:
				 /* Back out any changes made in the ACTION case */
			  break;
	
			case COMMIT:
				 /*
				  * Things are working well, so it's now safe to make the change
				  * permanently.  Make sure that anything done here can't fail!
				  */
			  break;
		}
		return SNMP_ERR_NOERROR;

}
int
write_tr069TerminalCertAccount(int action,
             u_char    *var_val,
             u_char     var_val_type,
             size_t     var_val_len,
             u_char    *statP,
             oid       *name,
             size_t     name_len)
{
	
	
	char value[CHAR_LEN];
	char string[CHAR_LEN];
	
	switch ( action ) {
		case RESERVE1:
		  if (var_val_type != ASN_OCTET_STR) {
			  fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
			  return SNMP_ERR_WRONGTYPE;
		  }
		  if (var_val_len >128* sizeof(char)) {
			  fprintf(stderr,"write to apCommonInfo: bad length\n");
			  return SNMP_ERR_WRONGLENGTH;
		  }
		  break;
	
		case RESERVE2:
	
		  break;
	
		case FREE:
			 /* Release any resources that have been allocated */
		  break;
	
		case ACTION:
			 memset( value, 0, CHAR_LEN);
			 memset(string, 0, CHAR_LEN);		 
			 memcpy(value,var_val,var_val_len);
		 sprintf(string,"%s %s" , "/usr/sbin/settr069suser_r.sh",value);
		  system(string);	
		  break;
	
		case UNDO:
			 /* Back out any changes made in the ACTION case */
		  break;
	
		case COMMIT:
			 /*
			  * Things are working well, so it's now safe to make the change
			  * permanently.  Make sure that anything done here can't fail!
			  */
		  break;
	}
	return SNMP_ERR_NOERROR;
}
int
write_tr069TerminalCertKey(int action,
             u_char    *var_val,
             u_char     var_val_type,
             size_t     var_val_len,
             u_char    *statP,
             oid       *name,
             size_t     name_len)
{
	
	
	char value[CHAR_LEN];
	char string[CHAR_LEN];
	
	switch ( action ) {
		case RESERVE1:
		  if (var_val_type != ASN_OCTET_STR) {
			  fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
			  return SNMP_ERR_WRONGTYPE;
		  }
		  if (var_val_len > 128*sizeof(char)) {
			  fprintf(stderr,"write to apCommonInfo: bad length\n");
			  return SNMP_ERR_WRONGLENGTH;
		  }
		  break;
	
		case RESERVE2:
		  //size  = var_val_len;
		 // value = * (char *) var_val;
	
		  break;
	
		case FREE:
			 /* Release any resources that have been allocated */
		  break;
	
		case ACTION:
		memset( value, 0, CHAR_LEN);
			memset( string, 0, CHAR_LEN);
			 memcpy(value,var_val,var_val_len);
		 sprintf(string, "%s %s" ,	"/usr/sbin/settr069spass_r.sh",value);
		  system(string);					  
		  break;
	
		case UNDO:
			 /* Back out any changes made in the ACTION case */
		  break;
	
		case COMMIT:
			 /*
			  * Things are working well, so it's now safe to make the change
			  * permanently.  Make sure that anything done here can't fail!
			  */
		  break;
	}
	return SNMP_ERR_NOERROR;
}


