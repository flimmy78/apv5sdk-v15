/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: apCommonInfo.c
* description:  implementation for the description of AP common information
* 
*
* 
************************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "apCommonInfo.h"
#include <ap_interface.h>
#include "wapi/wapicgifunc.h"

#define APINFO_CONF	  		"/jffs/apinfo.conf"
int key_mode=0;
long igmp_flag=0;
long mld_flag=0;

#define CHAR_LEN  128
#define  debug_print  1

static int CWGetMemUseRatio(void);
void CWGetFlashSizeInfo(unsigned short *flashTotal, int *flashFree);
int CWGetIPMode(void);

/* 
 * apCommonInfo_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

//oid apCommonInfo_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,2,1,1 };

oid *apCommonInfo_variables_oid;

/* 
 * variable4 apCommonInfo_variables:
 *   this variable defines function callbacks and type return information 
 *   for the apCommonInfo mib section 
 */

struct variable4  apCommonInfo_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define APCPUMODEL		1
{APCPUMODEL,  ASN_OCTET_STR,  RONLY ,  var_apCommonInfo, 1,  { 1 }},
#define APBOGOMIPS		2
{APBOGOMIPS,  ASN_OCTET_STR,  RONLY ,  var_apCommonInfo, 1,  { 2 }},
#define APMEMTOTAL		3
{APMEMTOTAL,  ASN_OCTET_STR,  RONLY ,  var_apCommonInfo, 1,  { 3 }},
#define APMEMFREE		4
{APMEMFREE,  ASN_OCTET_STR,  RONLY ,  var_apCommonInfo, 1,  { 4 }},
#define APMTDSIZE		5
{APMTDSIZE,  ASN_OCTET_STR,  RONLY ,  var_apCommonInfo, 1,  { 5 }},
#define APNTPRECTIFY		6
{APNTPRECTIFY,  ASN_OCTET_STR,  RONLY ,  var_apCommonInfo, 1,  { 6 }},
#define APDEFAULTSET		7
{APDEFAULTSET,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 7 }},
#define RECEIVERSIGNALLEVEL		8
{RECEIVERSIGNALLEVEL,  ASN_OCTET_STR,  RONLY ,  var_apCommonInfo, 1,  { 8 }},
#define APUSECPURATE		9
{APUSECPURATE,  ASN_INTEGER,  RONLY ,  var_apCommonInfo, 1,  { 9 }},
#define APMEMUTILRATE		10
{APMEMUTILRATE,  ASN_INTEGER,  RONLY ,  var_apCommonInfo, 1,  { 10 }},
#define APFLASHCAPACITY		11
{APFLASHCAPACITY,  ASN_INTEGER,  RONLY ,  var_apCommonInfo, 1,  { 11 }},
#define APFLASHFREE		12
{APFLASHFREE,  ASN_INTEGER,  RONLY ,  var_apCommonInfo, 1,  { 12 }},
#define APTEMPERATURE		13
{APTEMPERATURE,  ASN_OCTET_STR,  RONLY ,  var_apCommonInfo, 1,  { 13 }},
#define APWORKPATTERN		14
{APWORKPATTERN,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 14 }},
#define APANTIATTACKDOS		15
{APANTIATTACKDOS,  ASN_INTEGER,  RWRITE,  var_apCommonInfo, 1,  { 15 }},
#define APVLANABILITY		16
{APVLANABILITY,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 16 }},
#define APVLANCONFIG		17
{APVLANCONFIG,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 17 }},
#define IGMPSNOOPING		18
{IGMPSNOOPING,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 18 }},
#define WIRELESSSECURITYMECHANISMS		19
{WIRELESSSECURITYMECHANISMS,  ASN_INTEGER,  RWRITE,  var_apCommonInfo, 1,  { 19 }},
#define ROUTINGSTATICCONFIG		20
{ROUTINGSTATICCONFIG,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 20 }},
#define REMOTELOGINACCOUNT		21
{REMOTELOGINACCOUNT,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 21 }},
#define REMOTELOGINKEY		22
{REMOTELOGINKEY,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 22 }},
#define APNAME		23
{APNAME,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 23 }},
#define APLOCATION		24
{APLOCATION,  ASN_OCTET_STR,  RWRITE,  var_apCommonInfo, 1,  { 24 }},
#define APDESCR		25
{APDESCR,  ASN_OCTET_STR,  RWRITE,	var_apCommonInfo, 1,  { 25 }},
#define APETHSPEED  26
{APETHSPEED, ASN_INTEGER,  RONLY,  var_apCommonInfo, 1, { 26 }},
#define IGMPSNOOPINGENABLE 27
{IGMPSNOOPINGENABLE, ASN_INTEGER,RWRITE, var_apCommonInfo, 1,{27}},
#define MLDSNOOPINGENABLE 28
{MLDSNOOPINGENABLE, ASN_INTEGER,RONLY ,var_apCommonInfo,1,{28}},
};
/*    (L = length of the oidsuffix) */


/** Initializes the apCommonInfo module */
void
init_apCommonInfo(void)
{
  //  'cat  /jffs/.OEM/.vendor_oid'
    FILE *fp;
    char oid_str[64]={0};
	char oid_tmp[64]={0};
	int  oid_len=0;
	int count = 0;
    char *p = NULL;
	char *ptr=NULL;

    fp=fopen( "/jffs/.OEM/.vendor_oid","r");
    if(fp)
    {
    	memset(oid_str,0,64);
    	fgets(oid_str,sizeof(oid_str),fp);
	    oid_str[strlen(oid_str)-1] = '\0';
	    fclose(fp);	
     }
    else
    {
    	 memset(oid_str,0,64);
         strcpy(oid_str, "1.3.6.1.4.1.31656"); 
	 }

    
	memset(oid_tmp,0,64);
	strcpy(oid_tmp,oid_str);
		 
    ptr = strtok(oid_tmp, "."); 
	while(NULL != ptr)
	{
		oid_len++;
		ptr = strtok(NULL,".");
	 }
	
    oid_len = oid_len + 5;	
	apCommonInfo_variables_oid=(oid *)malloc(sizeof(oid)*(oid_len));
  
     p = strtok(oid_str, "."); 
	 while(NULL != p)
	 {
	    apCommonInfo_variables_oid[count++] = (oid)atoi(p);	  
	    p = strtok(NULL,".");
	 }
			 
    apCommonInfo_variables_oid[count ++] = 2;
    apCommonInfo_variables_oid[count ++] = 3;
    apCommonInfo_variables_oid[count ++] = 2;
    apCommonInfo_variables_oid[count ++] = 1;
    apCommonInfo_variables_oid[count ++] = 1;

    DEBUGMSGTL(("apCommonInfo", "Initializing\n"));
   
    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("apCommonInfo", apCommonInfo_variables, variable4,
               apCommonInfo_variables_oid,count);

    /* place any other initialization junk you need here */
}

/*
 * var_apCommonInfo():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_apCommonInfo(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[CHAR_LEN];
    static unsigned char buffer[CHAR_LEN];

    static unsigned char string1[CHAR_LEN];
    static unsigned char string2[CHAR_LEN];

    static unsigned char buffer1[CHAR_LEN];
    static unsigned char buffer2[CHAR_LEN];

	static unsigned char strBuf[256];

    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    static  int flashfree=0,mode=0;
    static  unsigned  short flashTotal=0;

	prop_data properties[255];
    int prop_count=0;

	if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {

   case APCPUMODEL:
	{ 
		  FILE *fp;
		  fp=popen( "cat /proc/cpuinfo |awk -F \":\" '/cpu model/{print $NF}'","r");
		  if(fp)
		  	{
			  memset( string, 0, CHAR_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			  pclose(fp);
			  *var_len = strlen (string);
			  return (u_char*) string;
		  	}
	}

    
    case APBOGOMIPS:
      { 
		  FILE *fp;
		  fp=popen( "cat /proc/cpuinfo |awk -F \"[ ]+|:\" '/BogoMIPS/{print $NF}'","r");
		  if(fp)
		  	{
			  memset( string, 0, CHAR_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			  pclose(fp);
			  *var_len = strlen (string);
              		  return (u_char*) string ;
  	        }
       }

     
    case APMEMTOTAL:
	  { 
		  FILE *fp;
		  fp=popen( "cat /proc/meminfo |awk -F \"[ ]+|:\" '/MemTotal/{print $3}'","r");
		  if(fp)
		  	{
			  memset( string, 0, CHAR_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			  pclose(fp);
			  *var_len = strlen (string);
                        return (u_char*)string;
	  	     }
       }

    case APMEMFREE:
	 { 
		  FILE *fp;
		  fp=popen( "cat /proc/meminfo |awk -F \"[ ]+|:\" '/MemFree/{print $3}'","r");
		  if(fp)
		  	   {
				  memset( string, 0, CHAR_LEN );
				  fgets(string,sizeof(string),fp);
				  string[strlen(string)-1] = '\0';
				  pclose(fp);
				  *var_len = strlen (string);
     			 	  return (u_char*)string ;
		  	   }
       }

    case APMTDSIZE:
	{
	  memset( string, 0, CHAR_LEN );
         strcpy(string,"32M"); 
    	 *var_len = strlen ( string );
         return (u_char*)string;
	}

	case APNTPRECTIFY:
   	   { 
		  FILE *fp;
		  fp=popen( "/bin/date -R","r");
		  if(fp)
		  	{
			  memset( string, 0, CHAR_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			   pclose(fp);
			  *var_len = strlen (string );
		          return (u_char*) string;
			  }
          }

    case APDEFAULTSET:
     *write_method = write_apDefaultSet;
	  memset( string, 0, CHAR_LEN );
	 strcpy(string,"factory default setting");
	 *var_len = strlen ( string);
       return (u_char*)string ;

   case RECEIVERSIGNALLEVEL:
	  memset( string, 0, CHAR_LEN );
	 strcpy(string,"2.9v");
	 *var_len = strlen ( string);
	 return (u_char*) string;

	 case APUSECPURATE:      //modify by heyanhua----090911
         { 
		  FILE *fp;
		  fp=popen( "top -n 1 -d 1 | awk -F \"[ ]+|:\" '/average/{print $4}'","r");
		  if(fp)
		  	{
				  memset( string, 0, CHAR_LEN );
				  fgets(string,sizeof(string),fp);
			      string[strlen(string)-1] = '\0';
				//  long_ret=atoi(string);    
				  sscanf(string,"0.%2d",&long_ret);
				  long_ret=long_ret%100;
				  pclose(fp);
		  	}
        }
	  return (u_char*) &long_ret ;

   case APMEMUTILRATE:
               long_ret=CWGetMemUseRatio();
              return (u_char*) &long_ret;
			  
    case APFLASHCAPACITY:
        CWGetFlashSizeInfo(&flashTotal, &flashfree);
		long_ret=flashTotal;
	return(u_char*) &long_ret ;

    case APFLASHFREE:
      CWGetFlashSizeInfo(&flashTotal,&flashfree);
	  long_ret=flashfree;
	return(u_char*) &long_ret;

	   
    case APTEMPERATURE:
	 {  FILE *fp;
	     fp=popen( "/usr/bin/avrutil  -T","r");
		  if(fp)
		  	   {
				  memset( string, 0, CHAR_LEN );
				  fgets(string,sizeof(string),fp);
				  string[strlen(string)-1] = '\0';
				  pclose(fp);
				  *var_len = strlen (string);
     			          return (u_char*) string;
		  	   }
       }

      
    case APWORKPATTERN:
        *write_method = write_apWorkPattern;
          { 
		  FILE *fp;
		  fp=popen( "/usr/sbin/getapworkmode.sh","r");
		  memset( string, 0, CHAR_LEN );
		  memset( buffer, 0, CHAR_LEN );
		  fgets(string,sizeof(string),fp);
		  string[strlen(string)-1] = '\0';
		  mode= atoi(string);
		  if(mode==0)	  
			  strcpy(buffer,"ap-bridge");
		  else
			  strcpy(buffer,"route");
			  *var_len = strlen (buffer);
			  pclose(fp);
			  return (u_char*) buffer;
		}
		
	
      
    case APANTIATTACKDOS:
      *write_method = write_apAntiattackDOS;
	   long_ret=1;
	   return (u_char*)&long_ret;

    case APVLANABILITY:
        *write_method = write_apVlanAbility;
		{ 
			  FILE *fp;
			  
			  memset( buffer1, 0, CHAR_LEN );
			  memset( buffer2, 0, CHAR_LEN );
			  sprintf(buffer1,"%s %s","/usr/sbin/getvlanenable.sh","1");
			  sprintf(buffer2,"%s %s","/usr/sbin/getvlanenable.sh","2");

			 fp=popen( buffer1,"r");
			 if(fp)
			 {
			  memset( string1, 0, CHAR_LEN );
			  fgets(string1,sizeof(string1),fp);
			  string1[strlen(string1)-1] = '\0';
			  pclose(fp);
          		}
		
			 fp=popen( buffer2,"r");
			 if(fp)
			 {
			  memset( string2, 0, CHAR_LEN );
			  fgets(string2,sizeof(string2),fp);
			  string2[strlen(string2)-1] = '\0';
			  pclose(fp);
          		}
			 sprintf(string,"%s %s %s %s"," ath0vlanID:",string1,"ath1vlanID:",string2);
			 *var_len = strlen ( string);
			 return (u_char*)string ;
        }

    case APVLANCONFIG:  //heyanhua modify  2010-4-20 ---start
        *write_method = write_apVlanConfig;
		{ 
			  FILE *fp;
			  char *q,*s;
			  char cmd[256],string[256],*aths[1024];
			  static char status[1024];
			  int i,j=0,count=0;

			  memset(status, 0, 1024);
			  fp=fopen("/proc/net/wireless","r");
			  if(fp!=NULL)
			  	{
			  		char line[2048];
					memset(line, 0, 2048);
					while(fgets(line, sizeof(line), fp))
					{		
						q = strstr(line, "ath");
						if(q != NULL)
							count++;
					}
					fclose(fp);
		       	}
			  fp=popen("cat /proc/net/wireless |awk -F \"[ ]+|:\" '/ath/{print $2}'","r");
			  if(fp)
			  	{
			  		char line[1024];
					memset(line,0,1024);
			  		memset(aths,0,1024);
					while(fgets(line,sizeof(line),fp))
					{	aths[j]=(char *)malloc(strlen(line));
						strcpy(aths[j++],line);
					}
					fclose(fp);	
			  	}
			  for(i=0;i<count;i++)
			  	printf("aths[%d]:%s\n",i,aths[i]);
			  printf("hyh test--1-- %d\n",count);
			  s = status;
			  for(i=0; i<count; i++)
			  	{   int vapid;
			  		memset(cmd, 0, 256);
			  		memset(string, 0, 256);
					sscanf(aths[i],"ath%d",&vapid);
			  	    printf("heyanhua test!!\n");
			  		sprintf(cmd,"%s %d","/usr/sbin/getvlanvid.sh",vapid+1);
					printf("heyanhua test cmd:%s\n",cmd);
					printf("atoi(*(aths[i]+3)):%d\n",vapid);
					fp = popen(cmd,"r");
					if(fp)
					{
						fgets(string,sizeof(string),fp);
						pclose(fp);
					}
					printf("hyh test--2-- %s\n",string);
					sprintf(s,"%s %s %s\n",aths[i],"vlanID:",string);
					printf("hyh test--3-- %s\n",s);
					s = s+strlen(s);
			  	}
			  for(j=0;j<count;j++)
			  if(aths[j])
			  	free(aths[j]);
			  printf("heyh test! vlanID:%s\n",status);
			  *var_len=strlen(status);
			  return (u_char *)status;
        	}
		//heyanhua modify 2010-4-20  ---end
		
      
    case IGMPSNOOPING:
        *write_method = write_IGMPSnooping;
	  
     
    case WIRELESSSECURITYMECHANISMS:
        *write_method = write_WirelessSecurityMechanisms;
	  long_ret= key_mode;
	 return (u_char*)&long_ret;
      
    case ROUTINGSTATICCONFIG:
        *write_method = write_RoutingStaticConfig;
       
    case REMOTELOGINACCOUNT:
        *write_method = write_RemoteLoginAccount;
           { 
			  FILE *fp;
			  fp=popen( "/usr/sbin/getuserpassword.sh |awk 'NR==1'","r");
			  memset( string, 0, CHAR_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			  *var_len = strlen (string);
			  pclose(fp);
			  return (u_char*) string;
		}
		
		
    case REMOTELOGINKEY:
        *write_method = write_RemoteLoginKey;
             { 
			  FILE *fp;
			  fp=popen( "/usr/sbin/getuserpassword.sh |awk 'NR==2'","r");
			  memset( string, 0, CHAR_LEN );
			  fgets(string,sizeof(string),fp);
			  string[strlen(string)-1] = '\0';
			  *var_len = strlen (string);
			  pclose(fp);
			  return (u_char*)string;
		}
	case APNAME:
		*write_method=write_apName;
		 memset( strBuf, 0, 256 );
		 prop_count=load_prop(SEP_EQUAL,APINFO_CONF,properties);
		 get_prop("APNAME",strBuf,properties,prop_count);
		 free_prop(properties,prop_count) ; 	  
		 *var_len = strlen(strBuf);
		 return (u_char *) strBuf;    
		
	case APLOCATION:
		*write_method=write_apLocation;
		 memset( strBuf, 0, 256 );
		 prop_count=load_prop(SEP_EQUAL,APINFO_CONF,properties);
		 get_prop("APLOCATION",strBuf,properties,prop_count);
		 free_prop(properties,prop_count) ; 	  
		 *var_len = strlen(strBuf);
		 return (u_char *) strBuf;    
	case APDESCR:
		*write_method=write_apDescr;
		 memset( strBuf, 0, 256 );
		 prop_count=load_prop(SEP_EQUAL,APINFO_CONF,properties);
		 get_prop("APDESCR",strBuf,properties,prop_count);
		 free_prop(properties,prop_count) ; 	  
		 *var_len = strlen(strBuf);
		 return (u_char *) strBuf;  

	case APETHSPEED:   // -----add by heyh 20100325
		{ 
		  FILE *fp;
		  fp=popen( "ethtool eth0 | awk -F \"[ ]+|:\" '/Speed/{print $3}'","r");
		  if(fp)
		  	{
				  memset( string, 0, CHAR_LEN );
				  fgets(string,sizeof(string),fp);
			      string[strlen(string)-1] = '\0'; 
				  sscanf(string,"%3ldMb/s",&long_ret);
                  pclose(fp);
		  	}
        }
	 return (u_char*) &long_ret;

//heyanhua add 2010-5-7	 
	 case IGMPSNOOPINGENABLE:
	 	*write_method=write_IGMPSnoopingEnable;
		long_ret=igmp_flag;
		return (u_char *)&long_ret;

	 case MLDSNOOPINGENABLE:
	 	*write_method=write_MLDSnoopingEnable;
		long_ret=mld_flag;
		return (u_char *)&long_ret;


		
		
 default:
      ERROR_MSG ( "" );
  }
    return NULL;
}





int
write_apDefaultSet(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apWorkPattern(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[CHAR_LEN];
    char string[CHAR_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >128* sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
        //  value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
                     memset( value, 0, CHAR_LEN);
                     memset( string, 0, CHAR_LEN);
			memset( value, var_val, var_val_len);
			sprintf(string,"%s  %s" , "/usr/sbin/setapworkmode.sh ",value);
			system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apAntiattackDOS(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apCommonInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apVlanAbility(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apVlanConfig(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_IGMPSnooping(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_WirelessSecurityMechanisms(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apCommonInfo not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
/*		  long_ret=*((long *)var_val);
		  if((long_ret<1)||(long_ret>3)){
		  	fprintf(stderr,"write to apCommonInfo:bad value\n");
			return SNMP_ERR_WRONGVALUE;
			*/
          break;

        case RESERVE2:
       //   size  = var_val_len;
       //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
     /*        memset(ifName,0,21);
		      ifIndex=name[name_len-1];
               printf("nSe.ifIndex==%d\n",ifIndex);
	        if_indextoname(ifIndex,ifName);
		if(long_ret==1)
			{
				memset(string,0,128);
				strcpy(string,"wapi");
			}
		else if (long_ret==2)
			{
				memset(string,0,128);
				strcpy(string,"wpa");
			 }
		else if(long_ret==3)
			{
				memset(string,0,128);
				strcpy(string,"wpa2");
			 }
		printf("security type:string:%s\n",string);
		wireless_sec_set_type( get_vnum_by_vname(ifName ),string );
		*/
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_RoutingStaticConfig(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_RemoteLoginAccount(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[CHAR_LEN];
    char string[CHAR_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >128* sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             memset( value, 0, CHAR_LEN);
	      memset(string, 0, CHAR_LEN);		 
             memcpy(value,var_val,var_val_len);
	     sprintf(string,"%s %s %s %s" , "/usr/sbin/changepassword.sh  ", "admin", value,value);
	      system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_RemoteLoginKey(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[CHAR_LEN];
    char string[CHAR_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 128*sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            memset( value, 0, CHAR_LEN);
            memset( string, 0, CHAR_LEN);
             memcpy(value,var_val,var_val_len);
	     sprintf(string, "%s %s %s %s" ,  "/usr/sbin/changepassword.sh  ", "admin" ,value,value);
	      system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}




int
write_apName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[256];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 256*sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        //  size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(value,0,256);
			memcpy(value,var_val,var_val_len);
			value[var_val_len]='\0';
			save_global_conf(SEP_EQUAL,APINFO_CONF,"","APNAME",value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}





int
write_apLocation(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[256];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 256*sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(value,0,256);
			memcpy(value,var_val,var_val_len);
			value[var_val_len]='\0';
			save_global_conf(SEP_EQUAL,APINFO_CONF,"","APLOCATION",value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_apDescr(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[256];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apCommonInfo not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >256* sizeof(char)) {
              fprintf(stderr,"write to apCommonInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(value,0,256);
			memcpy(value,var_val,var_val_len);
			value[var_val_len]='\0';
			save_global_conf(SEP_EQUAL,APINFO_CONF,"","APDESCR",value);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

/*  add hy heyanhua 2010-04-13  */
int
write_IGMPSnoopingEnable(int action,
                        u_char    *var_val,
                        u_char    var_val_type,
                        size_t    var_val_len,
                        u_char    *statP,
                        oid       *name,
                        size_t     name_len)
{
	    char value[256];
		int size;
		long temp;
	
		switch ( action ) {
			case RESERVE1:
			  if (var_val_type != ASN_INTEGER) {
				  fprintf(stderr, "write to apCommonInfo not ASN_INTEGER\n");
				  return SNMP_ERR_WRONGTYPE;
			  }
			  if (var_val_len > sizeof(long)) {
				  fprintf(stderr,"write to apCommonInfo: bad length\n");
				  return SNMP_ERR_WRONGLENGTH;
			  }
			    temp=*(long *)var_val;
		  if((temp<0)||(temp>1)){
		  	fprintf(stderr,"write to apCommonInfo:bad value\n");
			return SNMP_ERR_WRONGVALUE;
		  	}
			  break;
	
			case RESERVE2:
			 // size  = var_val_len;
			 // value = * (char *) var_val;
	
			  break;
	
			case FREE:
				 /* Release any resources that have been allocated */
			  break;
	
			case ACTION:
				temp=*(long *)var_val;
				igmp_flag=temp;

			  break;
	
			case UNDO:
				 /* Back out any changes made in the ACTION case */
			  break;
	
			case COMMIT:
				 /*
				  * Things are working well, so it's now safe to make the change
				  * permanently.  Make sure that anything done here can't fail!
				  */
			  break;
		}
		return SNMP_ERR_NOERROR;

}

int
write_MLDSnoopingEnable(int action,
                   u_char  *var_val,
                   u_char  var_val_type,
                   size_t  var_val_len,
                   u_char  *statP,
                   oid     *name,
                   size_t  name_len)
{
	        char value[256];
			int size;
			long temp;
		
			switch ( action ) {
				case RESERVE1:
				  if (var_val_type != ASN_INTEGER) {
					  fprintf(stderr, "write to apCommonInfo not ASN_INTEGER\n");
					  return SNMP_ERR_WRONGTYPE;
				  }
				  if (var_val_len >sizeof(long)) {
					  fprintf(stderr,"write to apCommonInfo: bad length\n");
					  return SNMP_ERR_WRONGLENGTH;
				  }
				  temp=*(long *)var_val;
		  if((temp<0)||(temp>1)){
		  	fprintf(stderr,"write to apCommonInfo:bad value\n");
			return SNMP_ERR_WRONGVALUE;
		  	}
				  break;
		
				case RESERVE2:
				 // size  = var_val_len;
				 // value = * (char *) var_val;
		
				  break;
		
				case FREE:
					 /* Release any resources that have been allocated */
				  break;
		
				case ACTION:
					temp=*(long *)var_val;
					mld_flag=temp;
	
				  break;
		
				case UNDO:
					 /* Back out any changes made in the ACTION case */
				  break;
		
				case COMMIT:
					 /*
					  * Things are working well, so it's now safe to make the change
					  * permanently.  Make sure that anything done here can't fail!
					  */
				  break;
			}
			return SNMP_ERR_NOERROR;

}


static int CWGetMemUseRatio(void)
{
 char temp_str[100];
 char str[20];
 FILE *fp;
 int memTotal = 0;
 int memFree = 0;
 int memUseRatio = 0;
 
 memset(temp_str, 0, 100);
 sprintf(temp_str, "cat /proc/meminfo | awk -F \" \" '/MemTotal/ {print $2}'");
 fp = popen(temp_str, "r");
 if(fp)
 {
  memset(str, 0, 20);
  fgets(str, sizeof(str), fp);
  str[strlen(str)-1] = '\0';
  memTotal = atoi(str);
  if(debug_print)
   printf("memTotal: %s len:%d memTotal:%d\n", str, strlen(str), memTotal);
  pclose(fp);
 }
 
 memset(temp_str, 0, 100);
 sprintf(temp_str, "cat /proc/meminfo | awk -F \" \" '/MemFree/ {print $2}'");
 fp = popen(temp_str, "r");
 if(fp)
 {
  memset(str, 0, 20);
  fgets(str, sizeof(str), fp);
  str[strlen(str)-1] = '\0';
  memFree = atoi(str);
  if(debug_print)
   printf("memFree mode: %s len:%d memFree:%d\n", str, strlen(str), memFree);
  pclose(fp);
 }
 memUseRatio = (memTotal-memFree)*100/memTotal;   //heyanhua modify 2010-4-29
 if(debug_print)
  printf("memUseRatio:%d%", memUseRatio);
 
 return memUseRatio;
}




void CWGetFlashSizeInfo(unsigned short *flashTotal, int *flashFree)
{
 int flashConfigFree;
 char temp_str[100];
 char temp_str1[100];
 char str[20];
 char str1[20];
 FILE *fp;
 
 memset(temp_str, 0, 100);
 sprintf(temp_str, "/bin/df | awk -F \" \" '/jffs/ {print $4}'");
 fp = popen(temp_str, "r");
 if(fp)
 {
  memset(str, 0, 20);
  fgets(str, sizeof(str), fp);
  str[strlen(str)-1] = '\0';
  flashConfigFree = atoi(str);
  if(debug_print)
   printf("AP get IP mode: %s len:%d flashConfigFree:%d\n", str, strlen(str), flashConfigFree);
  pclose(fp);
 }
 //modify by heyanhua----090910
 memset(temp_str1,0,100);
 sprintf(temp_str1,"cat /proc/cpuinfo |awk -F : '/cpu model/ {print $2}'");
 fp=popen(temp_str1,"r");
 if(fp)
 	{
 	memset(str1,0,20);
	fgets(str1,sizeof(str1),fp);
	str1[strlen(str1)-1]='\0';
	pclose(fp);
 	}
 if(strstr(str1,"AQ2010"))
 	{
 	*flashTotal=4;
	*flashFree=flashConfigFree*8;
 	}
 if(strstr(str1,"Cavium"))
 	{
 	*flashTotal=32;
	*flashFree=((*flashTotal-15)*1024-128-(1024-flashConfigFree))*8;
 	}
/*#ifdef AQ2010
 *flashTotal = 4;
 *flashFree = flashConfigFree*8;
#endif
#ifdef CAVIUM_PLATFORM
 *flashTotal = 32;
 *flashFree = ((*flashTotal-15)*1024-128-(1024-flashConfigFree))*8;
#endif   */
 if(debug_print)
  printf("flashTotal:%dMB flashFree:%dKb\n", *flashTotal, *flashFree);
 
 return;
}


int CWGetIPMode(void)
{
 char temp_str[100];
 char str[20];
 FILE *fp;
 
 memset(temp_str, 0, 100);
 sprintf(temp_str, "awk -F \"[<>]\" '/proto/ {print $3}' /jffs/config.xml");
 fp = popen(temp_str, "r");
 if(fp)
 {
  memset(str, 0, 20);
  fgets(str, sizeof(str), fp);
  str[strlen(str)-1] = '\0';
  if(debug_print)
   printf("AP get IP mode: %s len:%d\n", str, strlen(str));
  pclose(fp);
 }
 if(!strcmp(str, "static"))
  return 0;
 
 return 1;
}


