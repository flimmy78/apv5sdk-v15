/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 *	designed by zhangwenyi
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "nscrtvRoot.h"
#include <ap_interface.h>
#include <stdlib.h>


//#include <conf_file_opt.h>


/* 
 * nscrtvRoot_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid nscrtvRoot_variables_oid[] = { 1,3,6,1,4,1,17409 };
static char *hextob ( char *s );
/* 
 * variable4 nscrtvRoot_variables:
 *   this variable defines function callbacks and type return information 
 *   for the nscrtvRoot mib section 
 */

struct variable7 nscrtvRoot_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define EOCCBATADMINLOGICALID		1
{EOCCBATADMINLOGICALID,  ASN_OCTET_STR,  RWRITE,  var_nscrtvRoot, 5,  { 2,4,1,1,1 }},
#define EOCCBATADMINTECHPROJECT		2
{EOCCBATADMINTECHPROJECT,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,1,2 }},
#define EOCCBATADMINMANUFACTORYINFO		3
{EOCCBATADMINMANUFACTORYINFO,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,1,3 }},
#define EOCCBATADMINMODELNUMBER		4
{EOCCBATADMINMODELNUMBER,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,1,4 }},
#define EOCCBATADMINSERIALNUMBER		5
{EOCCBATADMINSERIALNUMBER,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,1,5 }},
#define EOCCBATADMINSOFTWAREVERSION		6
{EOCCBATADMINSOFTWAREVERSION,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,1,6 }},
#define EOCCBATADMINHARDWAREVERSION		7
{EOCCBATADMINHARDWAREVERSION,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,1,7 }},
#define EOCCBATADMINVENDORSPECIALINFO		8
{EOCCBATADMINVENDORSPECIALINFO,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,1,8 }},
#define EOCCBATADMINMACADDRESS		9
{EOCCBATADMINMACADDRESS,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,2,1 }},
#define EOCCBATADMINIPMODE		10
{EOCCBATADMINIPMODE,  ASN_INTEGER,  RWRITE,  var_nscrtvRoot, 5,  { 2,4,1,2,2 }},
#define EOCCBATADMINIPADDRESS		11
{EOCCBATADMINIPADDRESS,  ASN_IPADDRESS,  RWRITE,  var_nscrtvRoot, 5,  { 2,4,1,2,3 }},
#define EOCCBATADMINIPMASK		12
{EOCCBATADMINIPMASK,  ASN_IPADDRESS,  RWRITE,  var_nscrtvRoot, 5,  { 2,4,1,2,4 }},
#define EOCCBATADMINIPGATEWAY		13
{EOCCBATADMINIPGATEWAY,  ASN_IPADDRESS,  RWRITE,  var_nscrtvRoot, 5,  { 2,4,1,2,5 }},
#define EOCCBATADMININTERNALTEMPERATURE		14
{EOCCBATADMININTERNALTEMPERATURE,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,3,3 }},
#define EOCCBATADMINDATEANDTIME		15
{EOCCBATADMINDATEANDTIME,  ASN_OCTET_STR,  RWRITE,  var_nscrtvRoot, 5,  { 2,4,1,3,5 }},
#define EOCCBATADMINRESET		16
{EOCCBATADMINRESET,  ASN_INTEGER,  RWRITE,  var_nscrtvRoot, 5,  { 2,4,1,3,6 }},
#define EOCCBATADMINRESETCAUSE		17
{EOCCBATADMINRESETCAUSE,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,3,7 }},
#define EOCCBATADMINSNMPVERSION		18
{EOCCBATADMINSNMPVERSION,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,1,4,2 }},
#define EOCSOFTWARETUPGRADESERVERIP		19
{EOCSOFTWARETUPGRADESERVERIP,  ASN_IPADDRESS,  RWRITE,  var_nscrtvRoot, 4,  { 2,4,4,1 }},
#define EOCSOFTWAREUPGRADESERVERPORT		20
{EOCSOFTWAREUPGRADESERVERPORT,  ASN_INTEGER,  RWRITE,  var_nscrtvRoot, 4,  { 2,4,4,2 }},
#define EOCSOFTWAREUPGRADELOGIN		21
{EOCSOFTWAREUPGRADELOGIN,  ASN_OCTET_STR,  RWRITE,  var_nscrtvRoot, 4,  { 2,4,4,3 }},
#define EOCSOFTWAREUPGRADEPASSWORD		22
{EOCSOFTWAREUPGRADEPASSWORD,  ASN_OCTET_STR,  RWRITE,  var_nscrtvRoot, 4,  { 2,4,4,4 }},
#define EOCCNUWHITELISTAMOUNTLIMITATION		23
{EOCCNUWHITELISTAMOUNTLIMITATION,  ASN_INTEGER,  RWRITE,  var_nscrtvRoot, 5,  { 2,4,5,1,1 }},
#define EOCCNUWHITELISTREGISTEREDAMOUNT		24
{EOCCNUWHITELISTREGISTEREDAMOUNT,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,5,1,2 }},
#define EOCCNUWHITELISTPHYRATEGATE		25
{EOCCNUWHITELISTPHYRATEGATE,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 5,  { 2,4,5,1,5 }},
#define EOCTRAPMAXTIMES		26
{EOCTRAPMAXTIMES,  ASN_INTEGER,  RWRITE,  var_nscrtvRoot, 4,  { 2,4,8,1 }},
#define EOCTRAPMININTERVAL		27
{EOCTRAPMININTERVAL,  ASN_INTEGER,  RWRITE,  var_nscrtvRoot, 4,  { 2,4,8,2 }},
#define EOCTRAPMAXINTERVAL		28
{EOCTRAPMAXINTERVAL,  ASN_INTEGER,  RWRITE,  var_nscrtvRoot, 4,  { 2,4,8,3 }},
#define EOCTRAPVERSION		29
{EOCTRAPVERSION,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 4,  { 2,4,8,4 }},
#define EOCVLANVERSIONNUMBER		30
{EOCVLANVERSIONNUMBER,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 4,  { 2,4,9,1 }},
#define EOCVLANMAXVID		31
{EOCVLANMAXVID,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 4,  { 2,4,9,2 }},
#define EOCVLANMAXSUPPORTEDVLANS		32
{EOCVLANMAXSUPPORTEDVLANS,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 4,  { 2,4,9,3 }},
#define EOCVLANCREATEDVLANNUMBER		33
{EOCVLANCREATEDVLANNUMBER,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 4,  { 2,4,9,4 }},
#define EOCVLANVIDLIST		34
{EOCVLANVIDLIST,  ASN_OCTET_STR,  RONLY ,  var_nscrtvRoot, 4,  { 2,4,9,5 }},
#define EOCVLANNEXTFREEVID		35
{EOCVLANNEXTFREEVID,  ASN_INTEGER,  RONLY ,  var_nscrtvRoot, 4,  { 2,4,9,6 }},

#define EOCCBATCARDRFINDEX		36
{EOCCBATCARDRFINDEX,  ASN_INTEGER,  RONLY,   var_eocCBATCardRFTable, 6,  { 2,4,2,1, 1, 1 }},
#define EOCCBATCARDRFLINKMAXIMUM		37
{EOCCBATCARDRFLINKMAXIMUM,  ASN_INTEGER,  RONLY,   var_eocCBATCardRFTable, 6,  { 2,4,2,1, 1, 2 }},
#define EOCCBATCARDRFOUTPUTLEVEL		38
{EOCCBATCARDRFOUTPUTLEVEL,  ASN_INTEGER,  RWRITE,  var_eocCBATCardRFTable, 6,  { 2,4,2,1, 1, 3 }},
#define EOCCBATCARDMACCNUISOLATIONINDEX		39
{EOCCBATCARDMACCNUISOLATIONINDEX,  ASN_INTEGER,  RONLY,   var_eocCBATCardMACCNUIsolationTable, 6,  { 2,4,3,1, 1, 1 }},
#define EOCCBATCARDMACCNUISOLATIONEN		40
{EOCCBATCARDMACCNUISOLATIONEN,  ASN_INTEGER,  RWRITE,  var_eocCBATCardMACCNUIsolationTable, 6,  { 2,4,3,1, 1, 2 }},
#define EOCSOFTWAREUPGRADECBATCARDINDEX		41
{EOCSOFTWAREUPGRADECBATCARDINDEX,  ASN_INTEGER,  RONLY,   var_eocSoftwareUpgradeTable, 6,  { 2,4,4,5, 1, 1 }},
#define EOCSOFTWAREUPGRADECNUINDEX		42
{EOCSOFTWAREUPGRADECNUINDEX,  ASN_INTEGER,  RONLY,   var_eocSoftwareUpgradeTable, 6,  { 2,4,4,5, 1, 2 }},
#define EOCSOFTWAREUPGRADEMACADDRESS		43
{EOCSOFTWAREUPGRADEMACADDRESS,  ASN_OCTET_STR,  RWRITE,  var_eocSoftwareUpgradeTable, 6,  { 2,4,4,5, 1, 3 }},
#define EOCSOFTWAREUPGRADEDEVTYPE		44
{EOCSOFTWAREUPGRADEDEVTYPE,  ASN_INTEGER,  RWRITE,  var_eocSoftwareUpgradeTable, 6,  { 2,4,4,5, 1, 4 }},
#define EOCSOFTWAREUPGRADEFILENAME		45
{EOCSOFTWAREUPGRADEFILENAME,  ASN_OCTET_STR,  RWRITE,  var_eocSoftwareUpgradeTable, 6,  { 2,4,4,5, 1, 5 }},
#define EOCSOFTWAREUPGRADEPROCEED		46
{EOCSOFTWAREUPGRADEPROCEED,  ASN_INTEGER,  RWRITE,  var_eocSoftwareUpgradeTable, 6,  { 2,4,4,5, 1, 6 }},
#define EOCSOFTWAREUPGRADERESULT		47
{EOCSOFTWAREUPGRADERESULT,  ASN_INTEGER,  RONLY,   var_eocSoftwareUpgradeTable, 6,  { 2,4,4,5, 1, 7 }},
#define EOCCNUWHITELISTINDEX		48
{EOCCNUWHITELISTINDEX,  ASN_INTEGER,  RONLY,   var_eocCNUWhiteListTable, 7,  { 2,4,5,1,6, 1, 1 }},
#define EOCCNUWHITELISTMACADDRESS		49
{EOCCNUWHITELISTMACADDRESS,  ASN_OCTET_STR,  RWRITE,  var_eocCNUWhiteListTable, 7,  { 2,4,5,1,6, 1, 3 }},
#define EOCCNUWHITELISTAUTHORIZATION		50
{EOCCNUWHITELISTAUTHORIZATION,  ASN_INTEGER,  RWRITE,  var_eocCNUWhiteListTable, 7,  { 2,4,5,1,6, 1, 4 }},
#define EOCREALTIMESTATISTICCBATCARDINDEX		51
{EOCREALTIMESTATISTICCBATCARDINDEX,  ASN_INTEGER,  RONLY,   var_eocRealTimeStatisticTable, 6,  { 2,4,6,1, 1, 1 }},
#define EOCREALTIMESTATISTICCNUINDEX		52
{EOCREALTIMESTATISTICCNUINDEX,  ASN_INTEGER,  RONLY,   var_eocRealTimeStatisticTable, 6,  { 2,4,6,1, 1, 2 }},
#define EOCREALTIMESTATISTICTXBYTE		53
{EOCREALTIMESTATISTICTXBYTE,  ASN_INTEGER,  RONLY,   var_eocRealTimeStatisticTable, 6,  { 2,4,6,1, 1, 3 }},
#define EOCREALTIMESTATISTICRXBYTE		54
{EOCREALTIMESTATISTICRXBYTE,  ASN_INTEGER,  RONLY,   var_eocRealTimeStatisticTable, 6,  { 2,4,6,1, 1, 4 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the nscrtvRoot module */
void
init_nscrtvRoot(void)
{

    DEBUGMSGTL(("nscrtvRoot", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("nscrtvRoot", nscrtvRoot_variables, variable7,
               nscrtvRoot_variables_oid);

    /* place any other initialization junk you need here */
}

unsigned char *
var_nscrtvRoot(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[COUNT_LEN];
	static unsigned char buffer[COUNT_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    static int  retu_addr=0;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case EOCCBATADMINLOGICALID:
        *write_method = write_eocCBATAdminLogicalID;
		memset( string, 0, COUNT_LEN);
		strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;       
    case EOCCBATADMINTECHPROJECT:
		{   
			FILE *fp;
			memset( buffer, 0, COUNT_LEN );	   
			sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/Device Type/{print $2}'");	    
			fp=popen(buffer,"r");		
			memset (string, 0, COUNT_LEN);		
			fgets(string,sizeof(string),fp);
			unsigned char tmp_str[COUNT_LEN];
			memset (tmp_str, 0, COUNT_LEN);
			strncpy(tmp_str,string,5);					
			memset (string, 0, COUNT_LEN);
			if( strcmp(tmp_str,"AGC12") == 0)
				strcpy(string,"wifi underclocking");
			if( strcmp(tmp_str,"AGC30") == 0)
				strcpy(string,"HomeplugAV");
			pclose(fp);
			*var_len = strlen(string);	       
			return (u_char *)string;	
		}
    case EOCCBATADMINMANUFACTORYINFO:
        {   
			FILE *fp;	    
			memset( buffer, 0, COUNT_LEN );	   
			sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/Company Name/{print $2}'");	    
			fp=popen(buffer,"r");		
			memset (string, 0, COUNT_LEN);		
			fgets(string,sizeof(string),fp);		
			string[strlen(string)-1] = '\0';		
			pclose(fp);		
			*var_len = strlen(string);	       
			return (u_char *)string;	
		}

    case EOCCBATADMINMODELNUMBER:
        {   
			FILE *fp;	    
			memset( buffer, 0, COUNT_LEN );	   
			sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/Device Type/{print $2}'");	    
			fp=popen(buffer,"r");		
			memset (string, 0, COUNT_LEN);		
			fgets(string,sizeof(string),fp);		
			string[strlen(string)-1] = '\0';		
			pclose(fp);		
			*var_len = strlen(string);	       
			return (u_char *)string;	
		}

    case EOCCBATADMINSERIALNUMBER:
        {   
			FILE *fp;	    
			memset( buffer, 0, COUNT_LEN );	   
			sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/SN/{print $2}'");	    
			fp=popen(buffer,"r");		
			memset (string, 0, COUNT_LEN);		
			fgets(string,sizeof(string),fp);		
			string[strlen(string)-1] = '\0';		
			pclose(fp);		
			*var_len = strlen(string);	       
			return (u_char *)string;	
		}

    case EOCCBATADMINSOFTWAREVERSION:
        {   
			FILE *fp;	    
			memset( buffer, 0, COUNT_LEN );	   
			sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/Software Version/{print $2}'");	    
			fp=popen(buffer,"r");		
			memset (string, 0, COUNT_LEN);		
			fgets(string,sizeof(string),fp);		
			string[strlen(string)-1] = '\0';		
			pclose(fp);		
			*var_len = strlen(string);	       
			return (u_char *)string;	
		}

    case EOCCBATADMINHARDWAREVERSION:
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/Hardware Version/{print $2}'");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			*var_len = strlen(string);
			return (u_char *)string;
    	}

    case EOCCBATADMINVENDORSPECIALINFO:
		memset( string, 0, COUNT_LEN);
        strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;

    case EOCCBATADMINMACADDRESS:
        {
			FILE * fp;
			int i = 0;		
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/MAC/{print $2 $3 $4 $5 $6 $7}'");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			int length = strlen(string);
			for (;i<length;i++)
				string[i]=tolower(string[i]);			 
			*var_len = 6;
			return (u_char*) (hextob(string));
    	}

    case EOCCBATADMINIPMODE:
        *write_method = write_eocCBATAdminIPMode;
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "/usr/sbin/get_ipmode.sh");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			if (strcmp(string,"static")== 0)
				VALUE = 0;
			if (strcmp(string,"dhcp")==0)
				VALUE = 1;
			return (u_char *) &VALUE;
    	}
	
    case EOCCBATADMINIPADDRESS:
        *write_method = write_eocCBATAdminIPAddress;
        {
        		FILE * fp;			
 		 	fp=popen( "/sbin/ifconfig  default |awk -F \"[ ]+|:\" '/inet addr/{print $4}'","r");
			if(fp)
			{
		 		 memset( buffer, 0, COUNT_LEN );
		 		 fgets(buffer,sizeof(buffer),fp);
		 		 buffer[strlen(buffer)-1] = '\0';
				 pclose(fp);
			}
			retu_addr = inet_addr(buffer);
		        *var_len = 4;      
		        return ( u_char * )&retu_addr;
	   
    	}

    case EOCCBATADMINIPMASK:
        *write_method = write_eocCBATAdminIPMask;
        {
        		FILE * fp;
			fp=popen( "/sbin/ifconfig  default |awk -F \"[ ]+|:\" '/Mask/{print $8}'","r");
		 	if(fp)
		     	{
		 		memset( buffer, 0, COUNT_LEN );
		 		fgets(buffer,sizeof(buffer),fp);
		 		buffer[strlen(buffer)-1] = '\0';
				pclose(fp);
		    	}
		 	retu_addr = inet_addr(buffer);
	        	*var_len = 4;      
	         	return ( u_char * )&retu_addr;
    	}

    case EOCCBATADMINIPGATEWAY:
        *write_method = write_eocCBATAdminIPGateway;
        {
        		FILE * fp;
			fp=popen( "/sbin/route -n|awk  'NR==\"4\"{print $2}'","r");
		 	if(fp)
		 	{
	 		 	memset( buffer, 0, COUNT_LEN );
	 		 	fgets(buffer,sizeof(buffer),fp);
	 		 	buffer[strlen(buffer)-1] = '\0';
		        	pclose(fp);
			 	retu_addr = inet_addr(buffer);
	              		*var_len = 4;      
	              		return ( u_char * )&retu_addr;
		  	}
    	}

    case EOCCBATADMININTERNALTEMPERATURE:
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "pro_ctl_util -T | awk -F \"=\" '{print $2}'");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			VALUE = atoi(string);
			return (u_char *) &VALUE;
    	}

    case EOCCBATADMINDATEANDTIME:
        *write_method = write_eocCBATAdminDateAndTime;
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "date -I");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			fp=NULL;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "date | awk '{print $4}'");
			fp=popen(buffer,"r");
			static unsigned char string1[COUNT_LEN];
			fgets(string1,sizeof(string1),fp);
			strcat(string,",");
			strcat(string,string1);
			strcat(string,".0,+8:0");
			string[strlen(string)-1] = '\0';
			pclose(fp);
			*var_len = strlen(string);
			return (u_char *)string;
    	}

    case EOCCBATADMINRESET:
        *write_method = write_eocCBATAdminReset;
        VALUE = 1;
        return (u_char *) &VALUE;

    case EOCCBATADMINRESETCAUSE:
		memset( string, 0, COUNT_LEN);
        strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;

    case EOCCBATADMINSNMPVERSION:		
		VALUE = 1;
		return (u_char*) &VALUE;

    case EOCSOFTWARETUPGRADESERVERIP:
		*write_method = write_eocSoftwaretUpgradeServerIP;
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "/usr/sbin/get_snmpserverip.sh");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			retu_addr = inet_addr(string);
	        	*var_len = 4;      
	         	return ( u_char * )&retu_addr;
    	}

    case EOCSOFTWAREUPGRADESERVERPORT:
        *write_method = write_eocSoftwareUpgradeServerPort;
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "/usr/sbin/get_snmpserverport.sh");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			VALUE =atoi(string);
			return (u_char *) &VALUE;
    	}

    case EOCSOFTWAREUPGRADELOGIN:
        *write_method = write_eocSoftwareUpgradeLogin;
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "/usr/sbin/get_snmpserverusername.sh");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			printf ("string_read:%s\n",string);
			pclose(fp);
			*var_len = strlen(string);
			return (u_char *)string;
    	}

    case EOCSOFTWAREUPGRADEPASSWORD:
        *write_method = write_eocSoftwareUpgradePassWord;
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "/usr/sbin/get_snmpserverpassword.sh");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			*var_len = strlen(string);
			return (u_char *)string;
    	}

    case EOCCNUWHITELISTAMOUNTLIMITATION:
        *write_method = write_eocCNUWhiteListAmountLimitation;
		memset( string, 0, COUNT_LEN);
        strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;

    case EOCCNUWHITELISTREGISTEREDAMOUNT:
		memset( string, 0, COUNT_LEN);
        strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;

    case EOCCNUWHITELISTPHYRATEGATE:
		memset( string, 0, COUNT_LEN);
        strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;

    case EOCTRAPMAXTIMES:
        *write_method = write_eocTrapMaxTimes;
		VALUE = -1;
		return (u_char*) &(VALUE);
    case EOCTRAPMININTERVAL:
        *write_method = write_eocTrapMinInterval;
        VALUE = 1024 ;	
        return (u_char*) &VALUE;
    case EOCTRAPMAXINTERVAL:
        *write_method = write_eocTrapMaxInterval;
        VALUE = 4096 ;	
        return (u_char*) &VALUE;
    case EOCTRAPVERSION:
        {
			FILE * fp;
			memset ( string, 0, COUNT_LEN);
			strcpy( string, netsnmp_get_version());
			*var_len = strlen(string);
			return (u_char *)string;
    	}

    case EOCVLANVERSIONNUMBER:        		
		VALUE = 1;
		return (u_char*) &VALUE;

    case EOCVLANMAXVID:
		VALUE = 4095;
		return (u_char*) &(VALUE);

    case EOCVLANMAXSUPPORTEDVLANS:
        VALUE = 4095;
		return (u_char*) &(VALUE);

    case EOCVLANCREATEDVLANNUMBER:
        VALUE = 4095;
		return (u_char*) &(VALUE);

    case EOCVLANVIDLIST:
		memset( string, 0, COUNT_LEN);
        strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;

    case EOCVLANNEXTFREEVID:
        VALUE = 1;
		return (u_char*) &(VALUE);

    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_eocCBATCardRFTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_nscrtvRoot above.
 */
unsigned char *
var_eocCBATCardRFTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[COUNT_LEN];
    static unsigned char buffer[COUNT_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
	int tablesize = 1;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the 5 parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tablesize)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case EOCCBATCARDRFINDEX:
        VALUE = 1;
	return (u_char*) &VALUE;

    case EOCCBATCARDRFLINKMAXIMUM:        
	VALUE = 10;
	return (u_char*) &VALUE;

    case EOCCBATCARDRFOUTPUTLEVEL:
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "iwconfig ath0 | awk -F \"=\" '/Tx-Power/{print $2}' | awk '{print $1}'");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			VALUE = atoi(string) + 107;
			return (u_char *) &VALUE;
    	}

    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_eocCBATCardMACCNUIsolationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_nscrtvRoot above.
 */
unsigned char *
var_eocCBATCardMACCNUIsolationTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[COUNT_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
	int tablesize = 1;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tablesize)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case EOCCBATCARDMACCNUISOLATIONINDEX:
        VALUE = 1;
	return (u_char*) &VALUE;
    case EOCCBATCARDMACCNUISOLATIONEN:
        *write_method = write_eocCBATCardMACCNUIsolationEN;
        VALUE = 0;
	return (u_char*) &VALUE;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_eocSoftwareUpgradeTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_nscrtvRoot above.
 */
unsigned char *
var_eocSoftwareUpgradeTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[COUNT_LEN];
    static unsigned char buffer[COUNT_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
	int tablesize = 1;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tablesize)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case EOCSOFTWAREUPGRADECBATCARDINDEX:
        VALUE = 1;
	return (u_char*) &VALUE;

    case EOCSOFTWAREUPGRADECNUINDEX:
        VALUE = 0;
	return (u_char*) &VALUE;

    case EOCSOFTWAREUPGRADEMACADDRESS:
        *write_method = write_eocSoftwareUpgradeMACAddress;
		
        {
			FILE * fp;
			int i = 0;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/MAC/{print $2 $3 $4 $5 $6 $7}'");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			int length = strlen(string);
			for (;i<length;i++)
				string[i]=tolower(string[i]);			 
			*var_len = 6;
			return (u_char*) (hextob(string));
    	}

    case EOCSOFTWAREUPGRADEDEVTYPE:
        *write_method = write_eocSoftwareUpgradeDevType;
        {   
			FILE *fp;
			memset( buffer, 0, COUNT_LEN );	   
			sprintf( buffer, "%s", "/usr/sbin/showsysinfo |awk -F \":\" '/Device Type/{print $2}'");	    
			fp=popen(buffer,"r");		
			memset (string, 0, COUNT_LEN);		
			fgets(string,sizeof(string),fp);
			unsigned char tmp_str[COUNT_LEN];
			memset (tmp_str, 0, COUNT_LEN);
			strncpy(tmp_str,string,3);					
			memset (string, 0, COUNT_LEN);
			if( strcmp(tmp_str,"AGC") == 0)
				VALUE = 1;
			if( strcmp(tmp_str,"AGU") == 0)
				VALUE = 3;
			pclose(fp);				       
			return (u_char *) &VALUE;	
		}

    case EOCSOFTWAREUPGRADEFILENAME:
        *write_method = write_eocSoftwareUpgradeFileName;
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "/usr/sbin/get_snmpupgradefilename.sh");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			*var_len = strlen(string);
			return (u_char *)string;
    	}

    case EOCSOFTWAREUPGRADEPROCEED:
        VALUE = -1;
	return (u_char*) &VALUE;

    case EOCSOFTWAREUPGRADERESULT:
        VALUE = 0;
	return (u_char*) &VALUE;

    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_eocCNUWhiteListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_nscrtvRoot above.
 */
unsigned char *
var_eocCNUWhiteListTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[COUNT_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
	int tablesize = 1;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tablesize)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case EOCCNUWHITELISTINDEX:
		memset( string, 0, COUNT_LEN);
        strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;
    case EOCCNUWHITELISTMACADDRESS:
        *write_method = write_eocCNUWhiteListMACAddress;
		memset( string, 0, COUNT_LEN);
        strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;
    case EOCCNUWHITELISTAUTHORIZATION:
        *write_method = write_eocCNUWhiteListAuthorization;
		memset( string, 0, COUNT_LEN);
        strcpy(string,"TO BE DESIGNED");
		*var_len = strlen(string);
		return (u_char*) string;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_eocRealTimeStatisticTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_nscrtvRoot above.
 */
unsigned char *
var_eocRealTimeStatisticTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static oid objid[MAX_OID_LEN];
	static unsigned char string[COUNT_LEN];
	static unsigned char buffer[COUNT_LEN];
	int tablesize = 1 ;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tablesize)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case EOCREALTIMESTATISTICCBATCARDINDEX:
		VALUE = -1;
		return (u_char*) &(VALUE);
    case EOCREALTIMESTATISTICCNUINDEX:
        VALUE = -1;
		return (u_char*) &(VALUE);
    case EOCREALTIMESTATISTICTXBYTE:
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "ifconfig eth1 |awk -F \":\" '/TX bytes/{print $3}' | awk '{print $1}'");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';			
			pclose(fp);					
			VALUE = atol(string);
			return (u_char *) &VALUE;
    	}
    	
    case EOCREALTIMESTATISTICRXBYTE:
        {
			FILE * fp;
			memset ( buffer, 0, COUNT_LEN);
			sprintf( buffer, "%s", "ifconfig eth1 |awk -F \":\" '/RX bytes/{print $2}' | awk '{print $1}'");
			fp=popen(buffer,"r");
			memset (string,0 ,COUNT_LEN);
			fgets(string,sizeof(string),fp);
			string[strlen(string)-1] = '\0';
			pclose(fp);
			VALUE = atol(string);
			return (u_char *) &VALUE;
    	}
    default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_eocCBATAdminLogicalID(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
/*    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to nscrtvRoot not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
            
          break;

        case ACTION:
            
          break;

        case UNDO:
            
          break;

        case COMMIT:
             
          break;
    }
    return SNMP_ERR_NOERROR;  */
}


int
write_eocCBATAdminIPMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
	static  char value[COUNT_LEN];
	static  char string[COUNT_LEN];
	   
	switch ( action ) {
		case RESERVE1:
			if (var_val_type != ASN_INTEGER) {
				fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
				return SNMP_ERR_WRONGTYPE;
			}
			if (var_val_len > sizeof(long)) {
				fprintf(stderr,"write to nscrtvRoot: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
			long_ret = *( (long *) var_val);
			break;
   
		case RESERVE2:
			break;
   
		case FREE:
				/* Release any resources that have been allocated */
			break;
   
		case ACTION:
			
			memset( string, 0, COUNT_LEN);
			long_ret = *( (long *) var_val);
			if(long_ret == 0)
				set_data_by_path("/etc/config/config.xml","/config/network/lan","proto","static");
			if(long_ret == 1)
				set_data_by_path("/etc/config/config.xml","/config/network/lan","proto","dhcp");
			break;
   
		case UNDO:
				/* Back out any changes made in the ACTION case */
			break;
   
		case COMMIT:
				/*
				 * Things are working well, so it's now safe to make the change
				 * permanently.  Make sure that anything done here can't fail!
				 */
			break;
	 }
	return SNMP_ERR_NOERROR;
}


int
write_eocCBATAdminIPAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
	static  char  value[COUNT_LEN];
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to nscrtvRoot not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(value,0,COUNT_LEN);
		       sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
		       network_set_ip("default", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eocCBATAdminIPMask(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char  value[COUNT_LEN];
 
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apNetworkInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
 
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,COUNT_LEN);
		   sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
		   network_set_netmask("default", value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eocCBATAdminIPGateway(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char value[COUNT_LEN ];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to apNetworkInfo not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apNetworkInfo: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:


          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,COUNT_LEN);
		  sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
                 network_set_gw( value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eocCBATAdminDateAndTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
/*  char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to nscrtvRoot not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
              
          break;

        case ACTION:
              
          break;

        case UNDO:
              
          break;

        case COMMIT:
              
          break;
    }
    return SNMP_ERR_NOERROR;  */
}


int
write_eocCBATAdminReset(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char value[COUNT_LEN];
	static  char string[COUNT_LEN];
	   
	switch ( action ) {
		case RESERVE1:
			if (var_val_type != ASN_INTEGER) {
				fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
				return SNMP_ERR_WRONGTYPE;
			}
			if (var_val_len > sizeof(long)) {
				fprintf(stderr,"write to nscrtvRoot: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
			long_ret = *( (long *) var_val);
			break;
   
		case RESERVE2:
			break;
   
		case FREE:
				/* Release any resources that have been allocated */
			break;
   
		case ACTION:
			
			memset( string, 0, COUNT_LEN);
			long_ret = *( (long *) var_val);
			if(long_ret == 1)
			{
				sprintf (string,"%s","sysreboot");
				system(string);
			}
				
			break;

        case UNDO:
             
          break;

        case COMMIT:
             
          break;
    }
    return SNMP_ERR_NOERROR;   
}


int
write_eocSoftwaretUpgradeServerIP(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char value[COUNT_LEN];
	static  char string[COUNT_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to nscrtvRoot not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(u_long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            memset( value, 0, COUNT_LEN);
        	memset( string, 0, COUNT_LEN);
			sprintf(value,"%d.%d.%d.%d",var_val[0],var_val[1],var_val[2],var_val[3]);
			set_data_by_path("/etc/config/config.xml","/config/administrator/snmp/eoc/upgradeserver","ip",value);
          	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eocSoftwareUpgradeServerPort(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char value[COUNT_LEN];
	static  char string[COUNT_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        	long_ret = *( (long *) var_val);
            memset( value, 0, COUNT_LEN);
			sprintf(value,"%d",long_ret);
			set_data_by_path("/etc/config/config.xml","/config/administrator/snmp/eoc/upgradeserver","port",value);
          	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eocSoftwareUpgradeLogin(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char value[COUNT_LEN];
	static  char string[COUNT_LEN];

    switch ( action ) {
        case RESERVE1:

          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to nscrtvRoot not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            memset( value, 0, COUNT_LEN);
			memset( string, 0, COUNT_LEN);
		    memcpy(value,var_val,var_val_len);
			set_data_by_path("/etc/config/config.xml","/config/administrator/snmp/eoc/upgradeserver","username",value);
          	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eocSoftwareUpgradePassWord(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char value[COUNT_LEN];
	static  char string[COUNT_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to nscrtvRoot not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 32*sizeof(char)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            memset( value, 0, COUNT_LEN);
			memset( string, 0, COUNT_LEN);
		    memcpy(value,var_val,var_val_len);
			set_data_by_path("/etc/config/config.xml","/config/administrator/snmp/eoc/upgradeserver","password",value);
          	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_eocCNUWhiteListAmountLimitation(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
/*  long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
              
          break;

        case ACTION:
              
          break;

        case UNDO:
              
          break;

        case COMMIT:
              
          break;
    }
    return SNMP_ERR_NOERROR;  */
}


int
write_eocTrapMaxTimes(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
/*  long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
              
          break;

        case ACTION:
              
          break;

        case UNDO:
             
          break;

        case COMMIT:
              
          break;
    }
    return SNMP_ERR_NOERROR;  */
}

int
write_eocTrapMinInterval(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
 /*   long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             
          break;

        case ACTION:
             
          break;

        case UNDO:
             
          break;

        case COMMIT:
             
          break;
    }
    return SNMP_ERR_NOERROR;*/
}


int
write_eocTrapMaxInterval(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
 /*   long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
            
          break;

        case ACTION:
             
          break;

        case UNDO:
             
          break;

        case COMMIT:
             
          break;
    }
    return SNMP_ERR_NOERROR;*/
}
int
write_eocCBATCardRFOutputLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
/*    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             
          break;

        case ACTION:
             
          break;

        case UNDO:
             
          break;

        case COMMIT:
            
          break;
    }
    return SNMP_ERR_NOERROR;  */
}
int
write_eocCBATCardMACCNUIsolationEN(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
/*    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:

          break;

        case ACTION:
            
          break;

        case UNDO:
             
          break;

        case COMMIT:
             
          break;
    }
    return SNMP_ERR_NOERROR;   */
}
int
write_eocSoftwareUpgradeMACAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char value[COUNT_LEN];
	static  char string[COUNT_LEN];
	

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to nscrtvRoot not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len !=6) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             
          break;

        case ACTION:
        	printf("start action\n");
            memset( value, 0, COUNT_LEN);
			memset( string, 0, COUNT_LEN);
						
		    sprintf(value,"%02X%02X%02X%02X%02X%02X",var_val[0],var_val[1],var_val[2],var_val[3],var_val[4],var_val[5]);
		    sprintf(string,"%s  %s","pro_ctl_util -m ",value);
		    printf("cmd:%s\n",string);
		    system(string);
			break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_eocSoftwareUpgradeDevType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char value[COUNT_LEN];
	static  char string[COUNT_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            memset( value, 0, COUNT_LEN);
			memset( string, 0, COUNT_LEN);
		    memcpy(value,var_val,var_val_len);
		    sprintf(string,"%s  %s","pro_ctl_util -p ",value);
		    system(string);
          	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_eocSoftwareUpgradeFileName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static  char value[COUNT_LEN];
	static  char string[COUNT_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to nscrtvRoot not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            memset( value, 0, COUNT_LEN);
			memset( string, 0, COUNT_LEN);
		    memcpy(value,var_val,var_val_len);
			set_data_by_path("/etc/config/config.xml","/config/administrator/snmp/eoc/upgradeserver","filename",value);
          	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_eocSoftwareUpgradeProceed(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
/*  long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
              
          break;

        case ACTION:
              
          break;

        case UNDO:
              
          break;

        case COMMIT:
              
          break;
    }
    return SNMP_ERR_NOERROR;  */
}
int
write_eocCNUWhiteListMACAddress(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
/*    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to nscrtvRoot not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
            
          break;

        case ACTION:
             
          break;

        case UNDO:
            
          break;

        case COMMIT:
            
          break;
    }
    return SNMP_ERR_NOERROR;   */
}
int
write_eocCNUWhiteListAuthorization(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
/*  long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to nscrtvRoot not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to nscrtvRoot: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
 
          break;

        case ACTION:
        
          break;

        case UNDO:
              
          break;

        case COMMIT:
              
          break;
    }
    return SNMP_ERR_NOERROR;  */
}

static char *hextob ( char *s )
{
    char nibl, *byt;
    static char bin[20];

    byt = bin;

    while ((nibl = *s++) && nibl != ' ') {    /* While not end of string. */
      nibl -= ( nibl > '9') ?  ('a' - 10): '0';
      *byt = nibl << 4;                              /* place high nibble */
      if((nibl = *s++) && nibl != ' ') {
        nibl -= ( nibl > '9') ?  ('a' - 10): '0';
        *byt |= nibl;                                /*  place low nibble */
      }
      else break;
      ++byt;
    }
    *++byt = '\0';
    return ( bin );
}

